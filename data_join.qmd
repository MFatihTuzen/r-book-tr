# Veri BirleÅŸtirme {#part-datajoin .unnumbered}

[![https://r4ds.hadley.nz/joins](images/joins.png){fig-align="center"}](https://r4ds.hadley.nz/joins)

Veri analizi sÃ¼recinde, Ã§oÄŸu zaman birden fazla tabloyu **ortak bir anahtar** Ã¼zerinden birleÅŸtirmemiz gerekir.\
Bu iÅŸlem, farklÄ± kaynaklardaki bilgileri **tek bir veri yapÄ±sÄ±nda bÃ¼tÃ¼nleÅŸtirmemizi** saÄŸlar.\
Ã–rneÄŸin, bir tabloda mÃ¼ÅŸteri bilgileri, diÄŸerinde sipariÅŸ bilgileri olabilir; analiz yapmak iÃ§in bu tablolarÄ± birleÅŸtirmemiz gerekir.

Râ€™da veri birleÅŸtirme iÅŸlemleri hem **base R fonksiyonlarÄ±** (`merge()`) hem de **dplyr paketindeki** join fonksiyonlarÄ± (`left_join()`, `inner_join()`, vb.) ile yapÄ±labilir.\
Bu bÃ¶lÃ¼mde iki yaklaÅŸÄ±mÄ± da aynÄ± veri seti Ã¼zerinden adÄ±m adÄ±m gÃ¶stereceÄŸiz.

::: callout-tip
**AmaÃ§:**\
Bu bÃ¶lÃ¼mÃ¼n sonunda, birleÅŸtirme tÃ¼rlerini ve hangi durumda hangisinin kullanÄ±lacaÄŸÄ±nÄ± Ã¶ÄŸreneceksiniz.\
AyrÄ±ca aynÄ± iÅŸlemi hem `dplyr` hem de `base R` ile nasÄ±l yapabileceÄŸinizi gÃ¶receksiniz.
:::

------------------------------------------------------------------------

```{r}
#| label: setup
#| include: false
#| message: false
#| warning: false

knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  cache = TRUE
)
```

## KullanacaÄŸÄ±mÄ±z Veri Setleri

Bu bÃ¶lÃ¼mde `nycflights13` paketindeki veri setlerini kullanacaÄŸÄ±z. Bu paket, **2013 yÄ±lÄ± New York uÃ§uÅŸ verilerini** iÃ§erir ve iliÅŸkisel yapÄ±dadÄ±r. Yani birkaÃ§ tablo, ortak anahtarlar aracÄ±lÄ±ÄŸÄ±yla birbirine baÄŸlanabilir.

```{r}
library(dplyr)
library(nycflights13)
```

| Tablo      | Ä°Ã§erik              | Anahtar DeÄŸiÅŸken  | KayÄ±t SayÄ±sÄ±       | SÃ¼tun SayÄ±sÄ±       |
|---------------|---------------|---------------|---------------|---------------|
| `flights`  | UÃ§uÅŸ detaylarÄ±      | `carrier`, `dest` | `r nrow(flights)`  | `r ncol(flights)`  |
| `airlines` | Havayolu adlarÄ±     | `carrier`         | `r nrow(airlines)` | `r ncol(airlines)` |
| `airports` | HavaalanÄ± bilgileri | `faa`             | `r nrow(airports)` | `r ncol(airports)` |

```{r}
glimpse(flights)
glimpse(airlines)
glimpse(airports)
```

## Anahtar DeÄŸiÅŸken Nedir?

BirleÅŸtirme iÅŸlemlerinde kullanÄ±lan sÃ¼tunlara **anahtar deÄŸiÅŸken** denir. Bu deÄŸiÅŸkenler, iki tablo arasÄ±nda eÅŸleÅŸtirmeyi saÄŸlar. Ã–rneÄŸin:

-   `flights` tablosundaki **`carrier`**, `airlines` tablosundaki **`carrier`** ile eÅŸleÅŸtirilir.

-   `flights` tablosundaki **`dest`**, `airports` tablosundaki **`faa`** ile eÅŸleÅŸtirilir.

::: callout-note
**Anahtar DeÄŸiÅŸken Ã–zellikleri**

-   Ä°ki tabloda da aynÄ± bilgiyi temsil eder.

-   Veri tipleri uyumlu olmalÄ±dÄ±r (Ã¶rneÄŸin, her ikisi de karakter olmalÄ±).

-   Tekil veya tekrar eden deÄŸerler iÃ§erebilir. Tekrarlara gÃ¶re **iliÅŸki tÃ¼rÃ¼ (1â€“1, 1â€“N, Nâ€“M)** belirlenir.
:::

# Join KavramÄ± ve TÃ¼rleri

### Join Nedir?

**Join**, iki veya daha fazla veri tablosunu ortak bir anahtar Ã¼zerinden birleÅŸtirme iÅŸlemidir. SonuÃ§ta, tablolar tek bir veri Ã§erÃ§evesinde birleÅŸtirilir. Join tÃ¼rleri, hangi satÄ±rlarÄ±n korunacaÄŸÄ±na veya eleneceÄŸine gÃ¶re farklÄ±lÄ±k gÃ¶sterir.

| Join TÃ¼rÃ¼    | TanÄ±m                                                        | Tutulan SatÄ±rlar          |
|------------------------|------------------------|------------------------|
| `left_join`  | Soldaki tÃ¼m satÄ±rlarÄ± korur, saÄŸdan eÅŸleÅŸenleri getirir      | TÃ¼m sol tablo             |
| `inner_join` | Her iki tabloda eÅŸleÅŸen satÄ±rlarÄ± getirir                    | Ortak anahtarlar          |
| `right_join` | SaÄŸdaki tÃ¼m satÄ±rlarÄ± korur                                  | TÃ¼m saÄŸ tablo             |
| `full_join`  | Her iki tablodaki tÃ¼m satÄ±rlarÄ± birleÅŸtirir                  | Her iki tablo             |
| `semi_join`  | Sadece sol tablodan, eÅŸleÅŸen satÄ±rlarÄ±n alt kÃ¼mesini getirir | Sol tablo (eÅŸleÅŸenler)    |
| `anti_join`  | Sol tablodan, eÅŸleÅŸmeyen satÄ±rlarÄ± getirir                   | Sol tablo (eÅŸleÅŸmeyenler) |

### Kardinalite (Ä°liÅŸki TÃ¼rÃ¼)

Ä°ki tablo arasÄ±ndaki iliÅŸki, anahtar deÄŸiÅŸkenlerin yapÄ±sÄ±na baÄŸlÄ±dÄ±r:

| Ä°liÅŸki TÃ¼rÃ¼      | TanÄ±m                                    | Ã–rnek                       |
|------------------------|------------------------|------------------------|
| 1â€“1 (bire bir)   | Her anahtar her tabloda bir kez geÃ§er    | T.C. kimlik numarasÄ± â†” kiÅŸi |
| 1â€“N (bire Ã§ok)   | Sol tablo tekil, saÄŸ tablo tekrar iÃ§erir | Havayolu â†” UÃ§uÅŸlar          |
| Nâ€“M (Ã§oktan Ã§ok) | Her iki tabloda da tekrarlar vardÄ±r      | Ã–ÄŸrenci â†” Ders              |

Bu durum, birleÅŸtirme sonrasÄ± satÄ±r sayÄ±sÄ±nÄ± doÄŸrudan etkiler. Ã–rneÄŸin 1â€“N iliÅŸkisinde satÄ±r sayÄ±sÄ± artabilir.

### Râ€™de Join YaklaÅŸÄ±mlarÄ±

R dilinde iki temel yaklaÅŸÄ±m vardÄ±r:

| YaklaÅŸÄ±m  | Fonksiyon                                                                                  | Paket   |
|------------------------|------------------------|------------------------|
| Base R    | `merge()`                                                                                  | Temel R |
| Tidyverse | `left_join()`, `inner_join()`, `right_join()`, `full_join()`, `semi_join()`, `anti_join()` | `dplyr` |

::: callout-note
`dplyr` fonksiyonlarÄ± daha **okunabilir**, **tutarlÄ±**, ve **pipe (%\>%)** yapÄ±sÄ± ile Ã§alÄ±ÅŸmaya uygundur.\
Ancak `merge()` hÃ¢lÃ¢ birÃ§ok eski kodda ve kÃ¼Ã§Ã¼k projelerde yaygÄ±n biÃ§imde kullanÄ±lÄ±r.\
Bu yÃ¼zden bu bÃ¶lÃ¼mde her iki yÃ¶ntemi de gÃ¶receÄŸiz.
:::

## Left Join

`left_join()` veya `merge(..., all.x = TRUE)` iÅŸlemleri, **soldaki tablodaki tÃ¼m satÄ±rlarÄ±** koruyup, saÄŸdaki tablodan yalnÄ±zca eÅŸleÅŸen kayÄ±tlarÄ± ekler. Bu en sÄ±k kullanÄ±lan birleÅŸtirme tÃ¼rÃ¼dÃ¼r; Ã§Ã¼nkÃ¼ genellikle â€œasÄ±l veri setiniâ€ korumak isteriz.

**AmaÃ§:** Her uÃ§uÅŸun `carrier` bilgisine karÅŸÄ±lÄ±k gelen **havayolu adÄ±nÄ±** ekleyelim. Yani `flights` tablosundaki `carrier` deÄŸiÅŸkenini, `airlines` tablosundaki `carrier` ile eÅŸleÅŸtireceÄŸiz.

**Beklenti**

-   SatÄ±r sayÄ±sÄ± **flights ile aynÄ±** kalmalÄ±.
-   EÅŸleÅŸmeyen `carrier` deÄŸerleri varsa `NA` gÃ¶zÃ¼kecek.
-   SonuÃ§ta yeni sÃ¼tun: `name` (= havayolu adÄ±).

------------------------------------------------------------------------

```{r}

fl_joined <- flights %>%
  left_join(airlines, by = "carrier")

# SatÄ±r sayÄ±sÄ± deÄŸiÅŸti mi?
tibble(
  onceki = nrow(flights),
  sonraki = nrow(fl_joined)
)
```

SonuÃ§ deÄŸiÅŸmedi: `left_join()` soldaki tabloyu (flights) esas alÄ±r.

Yeni deÄŸiÅŸkenleri gÃ¶relim:

```{r}
fl_joined %>%
select(year, month, day, carrier, name) %>%
distinct(carrier, name) %>%
arrange(carrier) %>%
head(10)
```

::: callout-note
Burada `name` sÃ¼tunu `airlines` tablosundan geldi.\
EÄŸer iki tabloda aynÄ± isimli baÅŸka sÃ¼tunlar olsaydÄ±, `dplyr` otomatik olarak `.x` ve `.y` sonekleri eklerdi.
:::

**Base R ile AynÄ± Ä°ÅŸlem**

Base Râ€™de aynÄ± iÅŸlem `merge()` ile yapÄ±lÄ±r. `all.x = TRUE` parametresi, soldan birleÅŸtirme anlamÄ±na gelir.

```{r}
fl_joined_base <- merge(
flights,
airlines,
by = "carrier",
all.x = TRUE
)

# SatÄ±r sayÄ±sÄ± kontrolÃ¼

c(before = nrow(flights), after = nrow(fl_joined_base))

```

```{r}
head(fl_joined_base[c("carrier", "name")], 10)

```

| Ã–zellik       | `dplyr::left_join()`              | `base::merge()`                                                     |
|------------------------|------------------------|------------------------|
| SÃ¶zdizimi     | Daha okunaklÄ± (`by = "carrier"`)  | Uzun, parametre odaklÄ±                                              |
| VarsayÄ±lan    | Sadece belirttiÄŸin `by` Ã¼zerinden | EÄŸer `by` yoksa, ortak isimleri bulup otomatik join yapar (dikkat!) |
| Sonekler      | `.x` ve `.y`                      | `.x` ve `.y` veya `.1` ve `.2`                                      |
| Performans    | Genelde daha hÄ±zlÄ±                | BÃ¼yÃ¼k veride yavaÅŸ olabilir                                         |
| Okunabilirlik | ğŸ‘                                | ğŸŸ¡                                                                  |

### KÃ¼Ã§Ã¼k Deneme: EÅŸleÅŸmeyen Anahtar Durumu

VarsayalÄ±m `airlines` tablosundan bir satÄ±rÄ± Ã§Ä±karalÄ±m ve join yapalÄ±m; ne olur?

```{r}
airlines_miss <- airlines %>% filter(carrier != "UA")
fl_test <- flights %>% left_join(airlines_miss, by = "carrier")

fl_test %>%
filter(is.na(name)) %>%
distinct(carrier) %>%
head()

```

SonuÃ§ta `name = NA` olan satÄ±rlar, `airlines` tablosunda karÅŸÄ±lÄ±ÄŸÄ± olmayan taÅŸÄ±yÄ±cÄ±lardÄ±r.

::: callout-note
Bu tip satÄ±rlar **veri tutarlÄ±lÄ±ÄŸÄ±** aÃ§Ä±sÄ±ndan Ã¶nemlidir.\
GerÃ§ek analizlerde bu tÃ¼r durumlar genellikle hatalÄ± veya eksik kod anlamÄ±na gelir.
:::

## KÄ±sa Ã–zet

-   `left_join()`: soldaki tÃ¼m satÄ±rlarÄ± korur.

-   `merge(..., all.x = TRUE)`: aynÄ± iÅŸlevi base Râ€™de yapar.

-   EÅŸleÅŸmeyen kayÄ±tlar â†’ `NA`.

-   Kontrol: satÄ±r sayÄ±sÄ± deÄŸiÅŸmemeli.

-   Kod tablolarÄ± eklemek iÃ§in en gÃ¼venli yÃ¶ntemdir.

## Inner Join

`inner_join()` veya `merge(..., all = FALSE)` iÅŸlemleri, iki tablodaki **ortak anahtar deÄŸerlerine sahip** satÄ±rlarÄ± getirir. Yani her iki tabloda da eÅŸleÅŸen kayÄ±tlar kalÄ±r; eÅŸleÅŸmeyenler atÄ±lÄ±r.

**AmaÃ§:** YalnÄ±zca hem `flights` hem de `airlines` tablolarÄ±nda **karÅŸÄ±lÄ±ÄŸÄ± olan havayolu kodlarÄ±nÄ±** iÃ§eren satÄ±rlarÄ± tutmak.

**Beklenti**

-   SatÄ±r sayÄ±sÄ± `flights`â€™tan **daha az** olabilir.
-   Her iki tablodan da `carrier` eÅŸleÅŸmeyenler Ã§Ä±karÄ±lÄ±r.
-   `NA` deÄŸer **olmamalÄ±dÄ±r** Ã§Ã¼nkÃ¼ sadece eÅŸleÅŸenler alÄ±nÄ±r.

------------------------------------------------------------------------

**dplyr ile Inner Join**

```{r}

fl_inner <- flights %>%
  inner_join(airlines, by = "carrier")

tibble(
  flights_satir = nrow(flights),
  inner_join_satir = nrow(fl_inner)
)
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi satÄ±r sayÄ±sÄ± azaldÄ±ysa, bazÄ± `carrier` deÄŸerleri yalnÄ±zca bir tabloda var demektir. SonuÃ§tan kÃ¼Ã§Ã¼k bir Ã¶rnek:

```{r}
fl_inner %>%
select(year, month, day, carrier, name) %>%
distinct(carrier, name) %>%
arrange(carrier) %>%
head(10)
```

::: callout-tip
`inner_join()` genellikle **veri kesiÅŸimlerini** bulmak iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin, yalnÄ±zca hem satÄ±ÅŸ listesinde hem stok listesinde bulunan Ã¼rÃ¼nleri gÃ¶rmek istediÄŸinizde.
:::

**Base R ile Inner Join**

AynÄ± mantÄ±k `merge()` fonksiyonunda varsayÄ±lan olarak geÃ§erlidir. Yani `all = FALSE` (veya hiÃ§ yazmazsanÄ±z) **inner join** anlamÄ±na gelir.

```{r}
fl_inner_base <- merge(
flights,
airlines,
by = "carrier",
all = FALSE
)

c(before = nrow(flights), after = nrow(fl_inner_base))
```

```{r}
head(fl_inner_base[c("carrier", "name")], 10)
```

| Ã–zellik             | `dplyr::inner_join()`         | `base::merge()`               |
|------------------------|------------------------|------------------------|
| VarsayÄ±lan davranÄ±ÅŸ | YalnÄ±zca eÅŸleÅŸenleri tutar    | AynÄ±                          |
| SatÄ±r sayÄ±sÄ±        | Azalabilir                    | Azalabilir                    |
| `NA` deÄŸerler       | OluÅŸmaz                       | OluÅŸmaz                       |
| KullanÄ±m alanÄ±      | EÅŸleÅŸen kayÄ±tlarÄ± filtrelemek | EÅŸleÅŸen kayÄ±tlarÄ± filtrelemek |

::: callout-note
**KÄ±sa HatÄ±rlatma:**\

`inner_join()` sadece **ortak anahtarlarÄ±** getirir. Bir tabloda olup diÄŸerinde olmayan kayÄ±tlar **tamamen dÄ±ÅŸlanÄ±r**. Bu nedenle veri kaybÄ± olmamasÄ± istenen durumlarda `left_join()` tercih edilmelidir.
:::

## Right Join ve Full Join

Bu iki join tÃ¼rÃ¼, kapsayÄ±cÄ± birleÅŸtirmeler olarak adlandÄ±rÄ±lÄ±r.\
AmaÃ§, iki tablodaki **tÃ¼m bilgileri korumaktÄ±r** â€” ancak satÄ±rlarÄ±n hangi taraftan korunduÄŸu deÄŸiÅŸir.

### Right Join

`right_join()` veya `merge(..., all.y = TRUE)` iÅŸlemleri, **saÄŸdaki tablonun tÃ¼m satÄ±rlarÄ±nÄ±** korur.\
Soldaki tablodan yalnÄ±zca eÅŸleÅŸen kayÄ±tlar getirilir.

**AmaÃ§:** TÃ¼m `airlines` kayÄ±tlarÄ±nÄ± koruyalÄ±m, fakat `flights` tablosundan sadece eÅŸleÅŸenleri alalÄ±m. Bu, â€œsaÄŸ tarafÄ± referans alanâ€ bir birleÅŸtirmedir.

------------------------------------------------------------------------

**dplyr ile Right Join**

```{r}
fl_right <- flights %>%
  right_join(airlines, by = "carrier")

tibble(
  flights_satir = nrow(flights),
  airlines_satir = nrow(airlines),
  right_join_satir = nrow(fl_right)
)
```

```{r}
fl_right %>%
select(carrier, name) %>%
distinct(carrier, name)
```

::: callout-note
`right_join()` iÅŸlemi Ã¶zellikle â€œkod tablosuâ€ tarafÄ±ndaki tÃ¼m deÄŸerlerin korunmasÄ±nÄ± istediÄŸimiz durumlarda kullanÄ±lÄ±r.\
Ã–rneÄŸin: tÃ¼m mÃ¼ÅŸteri listesi saÄŸda, yalnÄ±zca satÄ±ÅŸ yapanlar soldaysa.
:::

**Base R ile Right Join**

Base Râ€™de aynÄ± iÅŸlem `merge(..., all.y = TRUE)` parametresiyle yapÄ±lÄ±r.

```{r}
fl_right_base <- merge(
flights,
airlines,
by = "carrier",
all.y = TRUE
)

c(before = nrow(airlines), after = nrow(fl_right_base))
```

```{r}
head(fl_right_base[c("carrier", "name")], 10)
```

### Full Join

`full_join()` veya `merge(..., all = TRUE)` iÅŸlemleri, **her iki tablodaki tÃ¼m anahtar deÄŸerlerini** birleÅŸtirir.\
EÅŸleÅŸmeyen satÄ±rlarÄ±n bulunduÄŸu taraflarda `NA` deÄŸerler oluÅŸur.

**AmaÃ§:** `flights` ve `airlines` tablolarÄ±nÄ± tÃ¼m anahtarlarla birleÅŸtirelim. BÃ¶ylece her iki tarafta olup diÄŸerinde olmayan kayÄ±tlar da gÃ¶rÃ¼nÃ¼r.

**dplyr ile Full Join**

```{r}
fl_full <- flights %>%
full_join(airlines, by = "carrier")

tibble(
flights_satir = nrow(flights),
airlines_satir = nrow(airlines),
full_join_satir = nrow(fl_full)
)
```

```{r}
fl_full %>%
select(carrier, name) %>%
distinct(carrier, name) %>%
arrange(carrier) %>%
head(10)
```

**Base R ile Full Join**

Base Râ€™de `all = TRUE` kullanÄ±ldÄ±ÄŸÄ±nda **full join** elde edilir:

```{r}
fl_full_base <- merge(
flights,
airlines,
by = "carrier",
all = TRUE
)

c(before = nrow(flights) + nrow(airlines), after = nrow(fl_full_base))
```

```{r}
head(fl_full_base[c("carrier", "name")], 10)
```

## Ã–zet

| Join TÃ¼rÃ¼  | dplyr Fonksiyonu | Base R EÅŸdeÄŸeri            | Korunan Taraf | EÅŸleÅŸmeyenler                    |
|---------------|---------------|---------------|---------------|---------------|
| Left Join  | `left_join()`    | `merge(..., all.x = TRUE)` | Sol tablo     | SaÄŸ taraf `NA`                   |
| Right Join | `right_join()`   | `merge(..., all.y = TRUE)` | SaÄŸ tablo     | Sol taraf `NA`                   |
| Full Join  | `full_join()`    | `merge(..., all = TRUE)`   | Her iki tablo | Her iki tarafta da `NA` olabilir |

::: callout-note
`full_join()` verilerin iki farklÄ± kaynaktan geldiÄŸi ve **birleÅŸtirmenin tamlÄ±ÄŸÄ±** kontrol edilmek istendiÄŸi durumlarda kullanÄ±ÅŸlÄ±dÄ±r. Ã–rneÄŸin: iki dÃ¶nem verisini, iki kurum listesini veya iki sÃ¼rÃ¼mÃ¼ birleÅŸtirirken.
:::

## Filtreleme TÃ¼rÃ¼ Joinâ€™ler (Semi Join ve Anti Join)

Bu iki join tÃ¼rÃ¼, tablo yapÄ±sÄ±nÄ± deÄŸiÅŸtirmez; yalnÄ±zca **satÄ±r seÃ§imi (filtreleme)** yapar. Yani `semi_join()` ve `anti_join()` yeni sÃ¼tunlar eklemez, sadece **sol tablodan** bazÄ± satÄ±rlarÄ± seÃ§er. Bu iÅŸlemler SQLâ€™de sÄ±rasÄ±yla *WHERE EXISTS* ve *WHERE NOT EXISTS* karÅŸÄ±lÄ±ÄŸÄ±na denktir.

### semi_join()

`semi_join()` sol tablodaki satÄ±rlardan, saÄŸ tablodaki anahtarlarla **eÅŸleÅŸenleri** tutar. EÅŸleÅŸmeyen satÄ±rlar atÄ±lÄ±r. Yeni sÃ¼tun eklenmez, sadece satÄ±r sayÄ±sÄ± azalabilir.

**AmaÃ§:** `flights` tablosundan, `airlines` tablosunda karÅŸÄ±lÄ±ÄŸÄ± bulunan `carrier` kayÄ±tlarÄ±nÄ± alalÄ±m.

------------------------------------------------------------------------

**dplyr ile Semi Join**

```{r}
fl_semi <- flights %>%
  semi_join(airlines, by = "carrier")

tibble(
  flights_satir = nrow(flights),
  semi_join_satir = nrow(fl_semi)
)
```

```{r}
fl_semi %>%
select(carrier) %>%
distinct(carrier) %>%
arrange(carrier)
```

::: callout-note
`semi_join()` Ã¶zellikle veri filtreleme veya â€œkesiÅŸimde olan kayÄ±tlarÄ± korumaâ€ amacÄ±yla kullanÄ±lÄ±r. Ã–rneÄŸin, sadece aktif mÃ¼ÅŸteriler listesinde bulunan sipariÅŸleri gÃ¶rmek istediÄŸinizde.
:::

**Base R ile Semi Join Benzeri Ä°ÅŸlem**

Base Râ€™de doÄŸrudan `semi_join()` yoktur, ancak aynÄ± etkiyi `merge()` veya `%in%` operatÃ¶rÃ¼yle elde edebiliriz.

```{r}
fl_semi_base <- subset(
flights,
carrier %in% airlines$carrier
)

unique(fl_semi_base$carrier)
```

YukarÄ±daki iÅŸlemde `flights` iÃ§inden sadece `airlines`â€™ta yer alan `carrier` deÄŸerlerine sahip satÄ±rlar alÄ±ndÄ±. Yani bu da `semi_join()` ile aynÄ± sonucu verir.

::: callout-note
### ğŸ’¡ Neden `semi_join()` KullanÄ±lÄ±r?

BazÄ± durumlarda yalnÄ±zca bir tablodaki kayÄ±tlarÄ±n, baÅŸka bir tabloda **var olup olmadÄ±ÄŸÄ±nÄ±** kontrol etmek isteriz.\
Bu durumda `inner_join()` gereksiz ek sÃ¼tunlar Ã¼retir, `filter()` ise Ã¶zellikle birden fazla anahtar deÄŸiÅŸken olduÄŸunda karmaÅŸÄ±k hale gelir.

`semi_join()` bu iki uÃ§ arasÄ±nda denge kurar ve yalnÄ±zca **eÅŸleÅŸen satÄ±rlarÄ±** dÃ¶ndÃ¼rÃ¼r, ama **sadece sol tablonun sÃ¼tunlarÄ±nÄ±** korur.

BÃ¶ylece hem daha okunaklÄ± hem de iliÅŸkiselliÄŸi koruyan bir filtreleme yapÄ±lmÄ±ÅŸ olur.
:::

### anti_join()

`anti_join()` ise tam tersini yapar: sol tablodaki satÄ±rlardan, saÄŸda **eÅŸleÅŸmeyenleri** getirir. Bu, veri temizliÄŸi iÃ§in Ã§ok kullanÄ±ÅŸlÄ±dÄ±r.

**AmaÃ§:** `flights` tablosunda olup `airlines` tablosunda **karÅŸÄ±lÄ±ÄŸÄ± olmayan** `carrier` deÄŸerlerini bulalÄ±m.

**dplyr ile Anti Join**

```{r}
fl_anti <- flights %>%
  anti_join(airlines, by = "carrier")

fl_anti %>%
select(carrier) %>%
distinct()
```

Bu, `flights` iÃ§inde olup `airlines` tablosunda bulunmayan `carrier` kodlarÄ±nÄ± listeler. Bu, veri kalitesi kontrolÃ¼nde Ã§ok iÅŸe yarar. Ã–rneÄŸin, `flights` verisinde bir `carrier` kodu geÃ§iyor ama bu kod `airlines` tablosunda tanÄ±mlÄ± deÄŸilse, muhtemelen bu kod hatalÄ± ya da eski bir deÄŸerdir.

::: callout-note
`anti_join()` veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼ testleri iÃ§in gÃ¼Ã§lÃ¼ bir araÃ§tÄ±r.\
Ã–rneÄŸin; satÄ±ÅŸ tablosundaki mÃ¼ÅŸteri kodlarÄ±ndan bazÄ±larÄ± mÃ¼ÅŸteri kayÄ±t tablosunda yoksa bu durum veri tutarsÄ±zlÄ±ÄŸÄ±na iÅŸaret eder.
:::

**Base R ile Anti Join Benzeri Ä°ÅŸlem**

AynÄ± mantÄ±ÄŸÄ± base Râ€™de `%in%` operatÃ¶rÃ¼yle kurabiliriz:

```{r}
fl_anti_base <- subset(
flights,
!(carrier %in% airlines$carrier)
)

unique(fl_anti_base$carrier)
```

### Ã–zet

| Join TÃ¼rÃ¼ | AmaÃ§                   | dplyr Fonksiyonu | Base R YaklaÅŸÄ±mÄ±     | DÃ¶nen SatÄ±rlar              |
|---------------|---------------|---------------|---------------|---------------|
| Semi Join | EÅŸleÅŸenleri getirir    | `semi_join()`    | `subset(..., %in%)`  | Sol tablodan, eÅŸleÅŸenler    |
| Anti Join | EÅŸleÅŸmeyenleri getirir | `anti_join()`    | `subset(..., !%in%)` | Sol tablodan, eÅŸleÅŸmeyenler |

::: callout-tip
**Ã–zetle:**\
Bu iki fonksiyon tabloyu â€œfiltrelerâ€, yeni sÃ¼tun eklemez.

-   `semi_join()` â†’ ortak kayÄ±tlarÄ± bulur.

-   `anti_join()` â†’ eksik veya hatalÄ± kayÄ±tlarÄ± bulur. Ã–zellikle veri temizliÄŸi, kalite kontrolÃ¼ ve kod doÄŸrulama sÃ¼reÃ§lerinde sÄ±klÄ±kla kullanÄ±lÄ±r.
:::

## **Join Ä°ÅŸlemlerinde Anahtar YÃ¶netimi**

### ğŸ”‘ Anahtar DeÄŸiÅŸkenlerin Ä°simleri FarklÄ±ysa

BazÄ± durumlarda iki tablodaki anahtar sÃ¼tunlarÄ±n isimleri **aynÄ± olmayabilir**. Ã–rneÄŸin `flights` tablosunda **`dest`**, `airports` tablosunda ise **`faa`** deÄŸiÅŸkeni aynÄ± bilgiyi temsil eder. Bu durumda, her iki tabloda da hangi sÃ¼tunun kullanÄ±lacaÄŸÄ±nÄ± `by` argÃ¼manÄ± ile aÃ§Ä±kÃ§a belirtmemiz gerekir.

**âœ… dplyr Ã–rneÄŸi**

```{r}
flights %>%
  left_join(airports, by = c("dest" = "faa")) %>%
  select(dest, name, lat, lon) %>%
  head()
```

Burada `"dest" = "faa"` ifadesi:

-   Sol tablodaki (`flights`) `dest` sÃ¼tunu,

-   SaÄŸ tablodaki (`airports`) `faa` sÃ¼tunu ile eÅŸleÅŸtirileceÄŸini belirtir.

**âœ… Base R Ã–rneÄŸi**

Base Râ€™de aynÄ± iÅŸlem ÅŸu ÅŸekilde yapÄ±lÄ±r:

```{r}
merge(
flights,
airports,
by.x = "dest",  # sol tablodaki deÄŸiÅŸken
by.y = "faa",   # saÄŸ tablodaki deÄŸiÅŸken
all.x = TRUE
)[c("dest", "name", "lat", "lon")] %>% head()
```

EÄŸer iki tabloda anahtar isimleri aynÄ±ysa, `by = "carrier"` veya `by.x = "carrier", by.y = "carrier"` ÅŸeklinde aÃ§Ä±kÃ§a belirtmek her zaman iyi bir pratiktir. BÃ¶ylece hem okunabilirlik artar hem de gelecekte deÄŸiÅŸiklik olduÄŸunda hatalar Ã¶nlenir.

### ğŸ§© Birden Fazla Anahtar DeÄŸiÅŸken ile Join

Bazen iki tabloyu birden fazla deÄŸiÅŸken Ã¼zerinden eÅŸleÅŸtirmemiz gerekir. Ã–rneÄŸin `flights` tablosunu baÅŸka bir tabloyla hem **yÄ±l**, hem **ay**, hem de **havayolu kodu (`carrier`)** Ã¼zerinden birleÅŸtirmek isteyebiliriz. Bu durumda anahtarlarÄ± `by` argÃ¼manÄ± iÃ§inde bir **vektÃ¶r** olarak belirtiriz.

**âœ… dplyr Ã–rneÄŸi**

```{r}
# Ã–rnek amaÃ§lÄ± kÃ¼Ã§Ã¼k bir tablo oluÅŸturalÄ±m
stats <- flights %>%
  group_by(year, month, carrier) %>%
  summarise(avg_delay = mean(dep_delay, na.rm = TRUE), .groups = "drop")

# AynÄ± Ã¼Ã§ deÄŸiÅŸken Ã¼zerinden birleÅŸtirme
fl_enriched <- flights %>%
  left_join(stats, by = c("year", "month", "carrier"))

fl_enriched %>% select(year, month, carrier, avg_delay) %>% head()
```

**âœ… Base R Ã–rneÄŸi**

```{r}
fl_enriched_base <- merge(
flights,
stats,
by = c("year", "month", "carrier"),
all.x = TRUE
)

head(fl_enriched_base[c("year", "month", "carrier", "avg_delay")])
```

Birden fazla deÄŸiÅŸken kullanmak Ã¶zellikle **panel veriler** veya **zaman serileri** ile Ã§alÄ±ÅŸÄ±rken oldukÃ§a yaygÄ±ndÄ±r. Ancak anahtarlarÄ±n her iki tabloda da **aynÄ± sÄ±rayla ve aynÄ± tipte** (Ã¶rneÄŸin karakter veya sayÄ±) olduÄŸuna emin olun. )

### ğŸ”„ FarklÄ± Ä°simli Birden Fazla Anahtar DeÄŸiÅŸken ile Join

EÄŸer iki tabloda **birden fazla anahtar deÄŸiÅŸken** var ve bu deÄŸiÅŸkenlerin isimleri her iki tabloda **aynÄ± deÄŸilse**,\
her bir Ã§ifti eÅŸleÅŸtirerek aÃ§Ä±kÃ§a belirtmemiz gerekir.

**âœ… dplyr Ã–rneÄŸi**

```{r}
# flights -> other_tbl_keys : sadece anahtarlar, tekilleÅŸtirilmiÅŸ
other_tbl_keys <- flights %>%
  distinct(year, month, day, carrier) %>%
  rename(yil = year, ay = month, gun = day)

fl_merge <- flights %>%
  left_join(
    other_tbl_keys,
    by = c("year" = "yil", "month" = "ay", "day" = "gun", "carrier" = "carrier")
  )

# SatÄ±r sayÄ±sÄ± beklenen: flights kadar
dplyr::tibble(before = nrow(flights), after = nrow(fl_merge))


```

**âœ… Base R Ã–rneÄŸi**

```{r}

other_tbl_keys <- flights %>%
  distinct(year, month, day, carrier) %>%
  rename(yil = year, ay = month, gun = day)

fl_merge_ok2 <- merge(
  flights, other_tbl_keys,
  by.x = c("year","month","day","carrier"),
  by.y = c("yil","ay","gun","carrier"),
  all.x = TRUE,
  sort = FALSE
)

c(before = nrow(flights), after = nrow(fl_merge_ok2))
```

::: callout-note
### ğŸ’¡ Neden `distinct()` ile tekilleÅŸtirdik? (dplyr + Base R)

`flights`â€™tan tÃ¼rettiÄŸimiz saÄŸ tablolarda (`other_tbl_keys`) anahtarlar (`year`, `month`, `day`, `carrier`) **tekrar ediyordu**.\
Bu durumda `left_join()` / `merge()` her eÅŸleÅŸen kombinasyonu **Ã§arpan** ÅŸekilde birleÅŸtirir.

â†’ **Nâ€“M patlamasÄ±**: satÄ±r sayÄ±sÄ± Ã§ok bÃ¼yÃ¼r, bellek/iÅŸlem sÃ¼resi artar.

**Ã‡Ã¶zÃ¼m:** SaÄŸ tabloyu join Ã¶ncesinde `distinct()` ile **tekilleÅŸtir** â†’ iliÅŸkiyi **Nâ€“Mâ€™den 1â€“Nâ€™e** indir.\
BÃ¶ylece her anahtar **yalnÄ±zca bir kez** eÅŸleÅŸir; hem hÄ±zlÄ± hem mantÄ±ksal olarak doÄŸru sonuÃ§ alÄ±rsÄ±n.
:::
