[
  {
    "objectID": "basics.html#çalışma-dizini",
    "href": "basics.html#çalışma-dizini",
    "title": "1  Temel Fonksiyonlar",
    "section": "1.1 Çalışma Dizini",
    "text": "1.1 Çalışma Dizini\nÇalışma Dizini, üzerinde çalıştığınız projenin tüm gerekli dosya ve belgelerini içerdiği yerdir. Çalışma dizininizi ayarlamanın iki yolu vardır. İlk yol getwd ve setwd işlevlerini kullanmaktır. Diğer yol ise RStudio üzerinden Session&gt;Set Working Directory youluyla yapılabilir.\n\ngetwd()\n\n\ndir veya list.files komutları ile dizinde yer alan dosyalar öğrenilebilir.\ndir.create komutu ile yeni bir klasör oluşturmak mümkündür.\nfile.exists kullanılarak klasörün var olup olmadığı sorgulanabilir."
  },
  {
    "objectID": "basics.html#yardımcı-bilgiler",
    "href": "basics.html#yardımcı-bilgiler",
    "title": "1  Temel Fonksiyonlar",
    "section": "1.2 Yardımcı Bilgiler",
    "text": "1.2 Yardımcı Bilgiler\nR komutlarında Büyük-küçük harf duyarlılığı (case sensitive) vardır.\n\na &lt;- 5  \nprint(a)  \n\n[1] 5\n\nA &lt;- 6  \nprint(A) \n\n[1] 6\n\n\nNoktalı virgül (;) işareti ile aynı satırda birden fazla kod çalıştırılabilir hale getirilir.\n\nx &lt;- 1 ; y &lt;- 2 ; z &lt;- 3  \nx; y; z\n\n[1] 1\n\n\n[1] 2\n\n\n[1] 3\n\n\nKomutlar arası açıklamaları ve yorumları #(hashtag) ile yazabiliriz. Hastagli satırlar, kod olarak algılanıp çalıştırılmaz. Bu kısımlara yazılan kodlar ile ilgili hatırlatıcı bilgiler (comment) yazılabilir.\n\n#6 ile başyalan ve  10 ile  biten tamsayıları c vektörüne atayalım  \nc &lt;- 6:10 \nc\n\n[1]  6  7  8  9 10\n\n\n\nls() çalışma alanındaki nesne ve fonksiyonları listeler.\nrm(a) çalışma alanından a nesnesini siler.\nrm(list=ls()) bütün çalışma alanını temizler.\nq() R’dan çıkış yapmayı sağlar.\ninstall.packages(\"package\") paket yüklemeyi sağlar.\nlibrary(\"package\") yüklü olan paketi getirir.\ninstalled.packages() yüklü olan paketleri listeler\noptions(digits=10) sayılarda ondalık kısmın basamak sayısını ifade eder.\nhelp() fonksiyonu ya da ? ile bir fonksiyon hakkında yardım alınabilir. Örneğin mean fonksiyonu ile ilgili yardım almak için scripte ?mean ya da help(mean) yazmanız ve çalıştırmanız yeterlidir. Bunun yanı sıra R Studio penceresinin sağ alt kısmındaki help alanını kullanabilirsiniz."
  },
  {
    "objectID": "basics.html#atama-operatörü",
    "href": "basics.html#atama-operatörü",
    "title": "1  Temel Fonksiyonlar",
    "section": "1.3 Atama Operatörü",
    "text": "1.3 Atama Operatörü\nBir değişkene, tabloya veya objeye değer atarken ‘&lt;-’ veya ‘=’ operatörü kullanılır. ‘&lt;-’ atama operatöründe ok hangi yöndeyse o tarafa atama yapılır. Genellikle ‘&lt;-’ operatörü kullanılmaktadır. Çünkü ‘=’ operatörü filtrelemelerde veya işlemlerdeki ‘==’ ile karıştırılabilmektedir. Ayrıca fonksiyonlar içinde de kullanılabildiği için kod karmaşasına sebebiyet verebilir. Her iki operatör de aynı işlevi görmektedir.\n\n# a'ya 20 değerini atayalım  \na &lt;- 20    \n# tabloyu ya da değeri görüntülemek için nesnenin kendisi de direkt yazılabilir.  \n# ya da print fonksiyonu kullanılabilir.   \nprint(a)    \n\n[1] 20\n\n# b'ye 12 değerini atayalım  \nb &lt;- 12  \nprint(b)   \n\n[1] 12\n\n# a ve b değerlerinden üretilen bir c değeri üretelim.   \nc &lt;- 2 * a + 3 * b  \nprint(c) \n\n[1] 76\n\n\nc() ile vektör oluştutulabilir. c “combine” (birleştirmek) kelimesinin ilk harfini ifade eder. Bir değişkene birden fazla değer atamak istediğimizde kullanılır.\n\n# d adında bir vektör oluşturalım ve değerler atayalım.   \nd &lt;- c(4,7,13)  \nd \n\n[1]  4  7 13\n\n\nBir metini değişkene atamak istersek de aşağıdaki gibi metin “” işareti içine yazılmalıdır.\n\nmetin &lt;- \"Merhaba Arkadaşlar\"  \nprint(metin)\n\n[1] \"Merhaba Arkadaşlar\""
  },
  {
    "objectID": "basics.html#matematiksel-operatörler",
    "href": "basics.html#matematiksel-operatörler",
    "title": "1  Temel Fonksiyonlar",
    "section": "1.4 Matematiksel Operatörler",
    "text": "1.4 Matematiksel Operatörler\nR ve R Studio, güçlü bir hesap makinesi olarak kabul edilebilir.\n\n3+5 \n\n[1] 8\n\n7*8 \n\n[1] 56\n\n88/2 \n\n[1] 44\n\n3*(12+(15/3-2)) \n\n[1] 45\n\n9^2 # karesini alır \n\n[1] 81\n\na &lt;-  3 \nb &lt;-  a^2 \nprint(b) \n\n[1] 9\n\nlog(15) #ln15 yani doğal logaritma \n\n[1] 2.70805\n\nlog10(1000) # 10 tabanına göre hesaplama \n\n[1] 3\n\nexp(12) #exponential power of the number. e (2.718) üzeri 12 \n\n[1] 162754.8\n\nfactorial(6) # faktöriyel hesaplama yapar \n\n[1] 720\n\nsqrt(81) # karekök alma \n\n[1] 9\n\nabs(-3) # mutlak değer \n\n[1] 3\n\nsign(-5) # işaret bulma \n\n[1] -1\n\nsin(45) # sinüs \n\n[1] 0.8509035\n\ncos(90) # cosinüs \n\n[1] -0.4480736\n\npi # pi sayısı \n\n[1] 3.141593\n\ntan(pi) # tanjant\n\n[1] -1.224647e-16"
  },
  {
    "objectID": "basics.html#mantıksal-operatörler",
    "href": "basics.html#mantıksal-operatörler",
    "title": "1  Temel Fonksiyonlar",
    "section": "1.5 Mantıksal Operatörler",
    "text": "1.5 Mantıksal Operatörler\nMantıksal sorgulamalar, koşullarda ve filtrelerde kullanılmaktadır. Verilen koşul veya filtre sağlandığında TRUE, sağlanmadığında ise FALSE değerleri elde edilmektedir. Bu mantıksal operatörler ayrıca komutlar içindeki özellikleri aktifleştirmek ve pasifleştirmek için de kullanılmaktadır.\nMantıksal operatörler aşağıdaki şekilde kullanılmaktadır:\n\neşittir : ==\neşit değildir : !=\nküçüktür : &lt;\nküçük eşittir : &lt;=\nbüyüktür : &gt;\nbüyük eşittir : &gt;=\nx değil : !x\nx ve y : x&y\nx veya y: x|y\n\n\n3 &gt; 5\n\n[1] FALSE\n\n# & (ve) operatörü\n# iki durumda TRUE ise sonuç TRUE döner.\n3 &lt; 5 & 8 &gt; 7\n\n[1] TRUE\n\n# bir durum FALSE diğer durum TRUE ise sonuç FALSE döner.\n3 &lt; 5 & 6 &gt; 7\n\n[1] FALSE\n\n# iki durumda FALSE ise sonuç FALSE döner.\n6 &lt; 5 & 6 &gt; 7\n\n[1] FALSE\n\n# | (veya) operatörü\n# Her iki durumdan birisi TRUE ise TRUE döner\n(5==4) | (3!=4)\n\n[1] TRUE"
  },
  {
    "objectID": "data_analysis.html#veri-ile-tanışma",
    "href": "data_analysis.html#veri-ile-tanışma",
    "title": "Keşifçi Veri Analizi",
    "section": "Veri ile Tanışma",
    "text": "Veri ile Tanışma\nVeri analizinin başlangıç aşamasında, verinin yapısına, ne tür değişkenler içerdiğine, çeşitli özet istatistiklerine bakmak ve gerekli ise ne tür dönüşümler yapmak gerektiğini bilmek önemlidir. Bu süreçler daha derin analizlere daha kolay devam edebilmek için de önemlidir. Bunları gerçekleştirmek için hem özet tablolar hem de grafikler yardımıyla verileri tanımak gerekmektedir.\nTek ve iki değişkenli olarak sayısal ve kategorik veri analizi mpg verisi kullanılarak yapılacaktır. Bu veri setinde 38 farklı aracın yakıt verileri bulunmaktadır.\n\n# mpg verisi ggplot2 paketinde olduğundan paketi çağırıyoruz\nlibrary(ggplot2)\n\nhead(mpg)\n\n# A tibble: 6 × 11\n  manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class \n  &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; \n1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…\n2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…\n3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…\n4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…\n5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…\n6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…\n\nnrow(mpg)\n\n[1] 234\n\nncol(mpg)\n\n[1] 11\n\nstr(mpg)\n\ntibble [234 × 11] (S3: tbl_df/tbl/data.frame)\n $ manufacturer: chr [1:234] \"audi\" \"audi\" \"audi\" \"audi\" ...\n $ model       : chr [1:234] \"a4\" \"a4\" \"a4\" \"a4\" ...\n $ displ       : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ...\n $ year        : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ...\n $ cyl         : int [1:234] 4 4 4 4 6 6 6 4 4 4 ...\n $ trans       : chr [1:234] \"auto(l5)\" \"manual(m5)\" \"manual(m6)\" \"auto(av)\" ...\n $ drv         : chr [1:234] \"f\" \"f\" \"f\" \"f\" ...\n $ cty         : int [1:234] 18 21 20 21 16 18 18 18 16 20 ...\n $ hwy         : int [1:234] 29 29 31 30 26 26 27 26 25 28 ...\n $ fl          : chr [1:234] \"p\" \"p\" \"p\" \"p\" ...\n $ class       : chr [1:234] \"compact\" \"compact\" \"compact\" \"compact\" ...\n\ncolnames(mpg)\n\n [1] \"manufacturer\" \"model\"        \"displ\"        \"year\"         \"cyl\"         \n [6] \"trans\"        \"drv\"          \"cty\"          \"hwy\"          \"fl\"          \n[11] \"class\"       \n\nsummary(mpg)\n\n manufacturer          model               displ            year     \n Length:234         Length:234         Min.   :1.600   Min.   :1999  \n Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999  \n Mode  :character   Mode  :character   Median :3.300   Median :2004  \n                                       Mean   :3.472   Mean   :2004  \n                                       3rd Qu.:4.600   3rd Qu.:2008  \n                                       Max.   :7.000   Max.   :2008  \n      cyl           trans               drv                 cty       \n Min.   :4.000   Length:234         Length:234         Min.   : 9.00  \n 1st Qu.:4.000   Class :character   Class :character   1st Qu.:14.00  \n Median :6.000   Mode  :character   Mode  :character   Median :17.00  \n Mean   :5.889                                         Mean   :16.86  \n 3rd Qu.:8.000                                         3rd Qu.:19.00  \n Max.   :8.000                                         Max.   :35.00  \n      hwy             fl               class          \n Min.   :12.00   Length:234         Length:234        \n 1st Qu.:18.00   Class :character   Class :character  \n Median :24.00   Mode  :character   Mode  :character  \n Mean   :23.44                                        \n 3rd Qu.:27.00                                        \n Max.   :44.00                                        \n\ndf &lt;- mpg\n\n# class değişkenini faktöre çevirip, kategorilerine bakalım\ndf$class &lt;- factor(df$class)\nlevels(df$class)\n\n[1] \"2seater\"    \"compact\"    \"midsize\"    \"minivan\"    \"pickup\"    \n[6] \"subcompact\" \"suv\"       \n\ndplyr::glimpse(df)\n\nRows: 234\nColumns: 11\n$ manufacturer &lt;chr&gt; \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"…\n$ model        &lt;chr&gt; \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4 quattro\", \"…\n$ displ        &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.…\n$ year         &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200…\n$ cyl          &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, …\n$ trans        &lt;chr&gt; \"auto(l5)\", \"manual(m5)\", \"manual(m6)\", \"auto(av)\", \"auto…\n$ drv          &lt;chr&gt; \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"4\", \"4\", \"4\", \"4\", \"4…\n$ cty          &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1…\n$ hwy          &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2…\n$ fl           &lt;chr&gt; \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p…\n$ class        &lt;fct&gt; compact, compact, compact, compact, compact, compact, com…"
  },
  {
    "objectID": "data_analysis.html#sürekli-değişkenler",
    "href": "data_analysis.html#sürekli-değişkenler",
    "title": "Keşifçi Veri Analizi",
    "section": "Sürekli Değişkenler",
    "text": "Sürekli Değişkenler\nVeri analizi, birçok farklı değişken türünün incelenmesini gerektirir. Bu değişkenler arasında sürekli değişkenler özellikle önemlidir. Sürekli değişkenler, belirli bir aralıktaki değerleri alabilen ve sonsuz sayıda mümkün değer içeren değişkenlerdir. Örnek olarak, yaş, gelir, sıcaklık gibi değerler sürekli değişkenlere örnektir. Sürekli değişkenlerin analizi, verileri anlamak ve içindeki örüntüleri keşfetmek için kullanılır. Bu analiz, genellikle aşağıdaki adımları içerir:\n\nVeri Görselleştirme:Sürekli değişkenlerin analizine başlamak için verilerinizi görselleştirmek önemlidir. Histogramlar, kutu grafikleri, yoğunluk grafikleri ve saçılım grafikleri gibi grafikler, veri dağılımını ve örüntülerini görsel olarak incelemenize yardımcı olur. Bu grafikler, veri setinizin merkezi eğilimini (ortalama veya medyan), yayılımını ve aykırı değerleri hızla görmeye yardımcı olur.\nMerkezi Eğilim ve Dağılım Ölçüleri: Sürekli değişkenlerin merkezi eğilimini ve dağılımını hesaplamak verileri özetlemenin önemli bir yoludur. Bu ölçümler, veri setinin merkezi noktasını ve veri noktalarının nasıl dağıldığını anlamamıza yardımcı olur. Örnek olarak, ortalama (mean), medyan (median), standart sapma (standard deviation) ve varyans (variance) gibi ölçümler bu aşamada kullanılır.\nKorelasyon Analizi: Eğer birden fazla sürekli değişken arasındaki ilişkiyi anlamak istiyorsanız, korelasyon analizi yapabilirsiniz. Korelasyon, iki değişken arasındaki ilişkinin gücünü ve yönünü ölçer. Korelasyon katsayısı, bu ilişkiyi değerlendirmek için kullanılır. Pozitif bir korelasyon, iki değişkenin aynı yönde değiştiğini, negatif bir korelasyon ise iki değişkenin ters yönde değiştiğini gösterir.\nHipotez Testleri: Sürekli değişkenler arasındaki farklılıkları değerlendirmek için hipotez testleri kullanılabilir. Örneğin, iki grup arasındaki ortalama değerlerin istatistiksel olarak anlamlı bir farklılık gösterip göstermediğini belirlemek için t-testleri veya ANOVA analizi kullanılabilir.\nGüven Aralıkları: Sürekli değişkenlerin analizi sırasında, belirli bir parametre (örneğin, ortalama) hakkında güven aralıkları hesaplanabilir. Bu güven aralıkları, parametrenin belirli bir güven düzeyinde bulunduğu aralığı gösterir. Bu, parametrenin tahmini kesinliğini değerlendirmek için kullanışlıdır.\n\nSürekli değişkenlerin analizi, verileri anlama ve kararlarınızı destekleme sürecinin önemli bir parçasıdır. İyi bir analiz, veri setinizdeki örüntüleri ve ilişkileri açığa çıkarmanıza yardımcı olur ve bilinçli kararlar almanıza yardımcı olur. Bu nedenle, sürekli değişkenlerin analizi yaparken yukarıda belirtilen adımları takip etmek önemlidir.\n\n# cty ve hwy değişkenlerini inceleyelim. \n# cty şehiriçi, hwy şehirarasını ifade ediyor.\n\nsummary(df$cty)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   9.00   14.00   17.00   16.86   19.00   35.00 \n\nvar(df$cty)\n\n[1] 18.11307\n\nmean(df$cty)\n\n[1] 16.85897\n\nsummary(df$hwy)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  12.00   18.00   24.00   23.44   27.00   44.00 \n\nvar(df$hwy)\n\n[1] 35.45778\n\nmean(df$hwy)\n\n[1] 23.44017\n\n# 1 mile= 1.609 km\n# 1 galon = 3.79 lt\n\n# litre başına km hesaplama\ngalonmil_to_ltkm &lt;- function(x){\n  \n  km &lt;- x * 1.609/3.79\n  return(km)\n}\n\ndf$cty_ltkm &lt;- galonmil_to_ltkm(df$cty)\ndf$hwy_ltkm &lt;- galonmil_to_ltkm(df$hwy)\nquantile(df$cty_ltkm) \n\n       0%       25%       50%       75%      100% \n 3.820844  5.943536  7.217150  8.066227 14.858839 \n\n# şehiriçi araçların % 75'i 1 lt ile 8.06 km den az yol alıyor.\nquantile(df$hwy_ltkm)\n\n       0%       25%       50%       75%      100% \n 5.094459  7.641689 10.188918 11.462533 18.679683 \n\n# şehirlerarası araçların % 75'i 1 lt ile 11.46 km den az yol alıyor.\n\n\n# değişken dağılımı için histogram grafiği kullanılabilir.\nhist(df$cty_ltkm,freq = FALSE,col = \"red\",border = \"blue\")\nlines(density(df$cty_ltkm), col = \"black\", lwd = 2,)\n\n\n\nhist(df$hwy_ltkm,xlim = c(4,20), ylim = c(0,60), breaks = 10)\n\n\n\n# Boxplot\nboxplot(df$cty_ltkm, main = \"Boxplot cty\")\n\n\n\nfivenum(df$cty_ltkm) # minimum, Q1, median, Q3, maximum\n\n[1]  3.820844  5.943536  7.217150  8.066227 14.858839\n\n# outliers \nboxplot(df$cty_ltkm)$out\n\n\n\n\n[1] 11.88707 11.88707 14.00976 14.85884 12.31161\n\n# outliers hangi sıralarda\nwhich(df$cty_ltkm %in% boxplot(df$cty_ltkm)$out)\n\n[1] 100 197 213 222 223\n\nboxplot(df$hwy_ltkm, main = \"Boxplot cty\")\n\n\n\nfivenum(df$hwy_ltkm) # minimum, Q1, median, Q3, maximum\n\n[1]  5.094459  7.641689 10.188918 11.462533 18.679683\n\nboxplot(hwy_ltkm ~ cyl, data = df, xlab = \"Silindir Sayısı\",\n   ylab = \"Litre Başına KM\", main = \"Mileage Data\")\n\n\n\nboxplot(hwy_ltkm ~ cyl, data = df, \n   xlab = \"Silindir Sayısı\",\n   ylab = \"Litre Başına KM\", \n   main = \"Mileage Data\",\n   notch = TRUE, \n   varwidth = TRUE, \n   col = c(\"green\",\"yellow\",\"purple\",\"blue\"),\n   names = c(\"2 Silindir\",\"4 Silindir\",\"6 Silindir\",\"8 Silindir\")\n)\n\nWarning in (function (z, notch = FALSE, width = NULL, varwidth = FALSE, : some\nnotches went outside hinges ('box'): maybe set notch=FALSE\n\n\n\n\n# Sürekli iki değişken incelemek istersek;\n\n# displ ve cty_ltkm değişkenlerini inceleyelim\n# displ motor hacmini ifade ediyor\n\nsummary(df$displ)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.600   2.400   3.300   3.472   4.600   7.000 \n\nwith(df,cor(displ,cty_ltkm))\n\n[1] -0.798524\n\n# motor hacmi ile lt başına km ters ilişkili\n\nplot(df$displ,df$cty_ltkm, \n     main = \"Motor Hacmi- Yakıt Tüketimi Saçılım Grafiği\",\n     col=\"red\",\n     xlab = \"Motor Hacmi\",\n     ylab = \"Yakıt Tüketimi\")\n\n\n\n# birden fazla değişkenin saçılım grafiği\npairs(~hwy_ltkm+cty_ltkm+displ+cyl,data = df,main = \"Scatterplot Matrix\")"
  },
  {
    "objectID": "data_analysis.html#kategorik-değişkenler",
    "href": "data_analysis.html#kategorik-değişkenler",
    "title": "Keşifçi Veri Analizi",
    "section": "Kategorik Değişkenler",
    "text": "Kategorik Değişkenler\nVeri analizi sürecinde, kategorik değişkenler (veya gruplar) genellikle çok önemli bir rol oynar. Kategorik değişkenler, belirli bir sınıfı veya kategoriyi temsil eden değişkenlerdir ve tipik olarak metin veya sembollerle ifade edilirler. Örnek olarak, cinsiyet, eğitim seviyesi, ürün kategorileri gibi değişkenler kategorik değişkenlere örnektir. Kategorik değişkenlerin analizi, bu değişkenlerin içindeki örüntüleri, dağılımları ve ilişkileri anlamamıza yardımcı olur. Aşağıda, kategorik değişkenlerin analizi için izlenebilecek temel adımları bulabilirsiniz:\n\nFrekans Tabloları ve Görselleştirme: Kategorik değişkenlerin frekans tablolarını ve grafiklerini oluşturarak, her kategori veya sınıfın veri setinde ne kadar sık görüldüğünü anlayabilirsiniz. Örneğin, bar grafikleri, pasta grafikleri veya çubuk grafikleri kullanarak kategori frekanslarını görselleştirebilirsiniz. summary() ve table() gibi R fonksiyonları ile bu verileri inceleyebilirsiniz.\nİlişkileri İnceleme: Kategorik değişkenler arasındaki ilişkileri anlamak önemlidir. İki kategorik değişken arasındaki ilişkiyi değerlendirmek için çapraz tablolar (cross-tabulation) ve ki-kare (chi-squared) istatistiksel testleri kullanabilirsiniz. Bu testler, iki değişken arasındaki bağımlılığı değerlendirmek için kullanılır.\nİstatistiksel Testler: Kategorik değişkenlerin analizi sırasında, gruplar arasındaki farkları değerlendirmek için hipotez testleri kullanabilirsiniz. İki kategorik değişken arasındaki ilişkinin istatistiksel olarak anlamlı olup olmadığını belirlemek için ki-kare testi veya Fisher’in kesin testi gibi testler kullanabilirsiniz. Ayrıca ANOVA gibi testler, bir kategorik değişkenin birden fazla grup üzerindeki etkisini değerlendirmek için kullanılabilir.\nVeri Görselleştirme: Kategorik değişkenlerin analizinde, gruplar arasındaki farkları daha iyi anlamak için grafikler kullanabilirsiniz. Bar grafikleri, grupların frekanslarını görselleştirmek için sıklıkla kullanılırken, gruplar arasındaki ilişkiyi anlamak için mozaik grafikleri veya heatmap’leri de kullanabilirsiniz.\n\nKategorik değişkenlerin analizi, veri setinizin içindeki desenleri ve ilişkileri anlamanıza yardımcı olur. Bu analiz, kararlarınızı desteklemek ve veriyi daha iyi anlamak için önemlidir. R programlama dili, kategorik değişkenlerin analizi için bir dizi kullanışlı fonksiyon ve paket sunar. Bu adımları takip ederek, veri analiz projelerinizde kategorik değişkenleri etkili bir şekilde analiz edebilirsiniz.\n\n# class ve trans değişkenlerine bakalım\n# class araç sınıfı, trans ise vites türünü ifade ediyor.\n\nsummary(df$class)\n\n   2seater    compact    midsize    minivan     pickup subcompact        suv \n         5         47         41         11         33         35         62 \n\ntable(df$class)\n\n\n   2seater    compact    midsize    minivan     pickup subcompact        suv \n         5         47         41         11         33         35         62 \n\nxtabs(~class,data=df)\n\nclass\n   2seater    compact    midsize    minivan     pickup subcompact        suv \n         5         47         41         11         33         35         62 \n\ntable(df$trans)\n\n\n  auto(av)   auto(l3)   auto(l4)   auto(l5)   auto(l6)   auto(s4)   auto(s5) \n         5          2         83         39          6          3          3 \n  auto(s6) manual(m5) manual(m6) \n        16         58         19 \n\nprop.table(table(df$class))\n\n\n   2seater    compact    midsize    minivan     pickup subcompact        suv \n0.02136752 0.20085470 0.17521368 0.04700855 0.14102564 0.14957265 0.26495726 \n\ntab &lt;- table(df$class)\nbarplot(tab,col=\"blue\",border=\"red\")\n\n\n\npie(tab)\n\n\n\npar(mfrow = c(1, 2))\nbarplot(tab)\npie(tab)\n\n\n\n# Kategorik iki değişken incelemek istersek;\n\nxtabs(~trans+class,data=df)\n\n            class\ntrans        2seater compact midsize minivan pickup subcompact suv\n  auto(av)         0       2       3       0      0          0   0\n  auto(l3)         0       1       0       1      0          0   0\n  auto(l4)         1       8      14       8     12         11  29\n  auto(l5)         0       4       5       0      8          4  18\n  auto(l6)         0       0       0       2      0          0   4\n  auto(s4)         0       2       1       0      0          0   0\n  auto(s5)         0       2       0       0      0          0   1\n  auto(s6)         1       5       6       0      0          1   3\n  manual(m5)       0      18       9       0      8         16   7\n  manual(m6)       3       5       3       0      5          3   0\n\nprop.table(table(df$year,df$class),1) # satır toplamları 1' eşittir\n\n      \n          2seater    compact    midsize    minivan     pickup subcompact\n  1999 0.01709402 0.21367521 0.17094017 0.05128205 0.13675214 0.16239316\n  2008 0.02564103 0.18803419 0.17948718 0.04273504 0.14529915 0.13675214\n      \n              suv\n  1999 0.24786325\n  2008 0.28205128\n\nprop.table(table(df$year,df$class),2) # sütun toplamları 1' eşittir\n\n      \n         2seater   compact   midsize   minivan    pickup subcompact       suv\n  1999 0.4000000 0.5319149 0.4878049 0.5454545 0.4848485  0.5428571 0.4677419\n  2008 0.6000000 0.4680851 0.5121951 0.4545455 0.5151515  0.4571429 0.5322581\n\nproportions(xtabs(~ manufacturer + year, data = df), 1)\n\n            year\nmanufacturer      1999      2008\n  audi       0.5000000 0.5000000\n  chevrolet  0.3684211 0.6315789\n  dodge      0.4324324 0.5675676\n  ford       0.6000000 0.4000000\n  honda      0.5555556 0.4444444\n  hyundai    0.4285714 0.5714286\n  jeep       0.2500000 0.7500000\n  land rover 0.5000000 0.5000000\n  lincoln    0.6666667 0.3333333\n  mercury    0.5000000 0.5000000\n  nissan     0.4615385 0.5384615\n  pontiac    0.6000000 0.4000000\n  subaru     0.4285714 0.5714286\n  toyota     0.5882353 0.4117647\n  volkswagen 0.5925926 0.4074074\n\n# araç sınıfı ile drv değişkenine birlikte bakalım\n# f = front-wheel drive (önden çekiş), \n# r = rear wheel drive (arkadan çekiş), \n# 4 = 4wd (4 çeker)\n\nplot(class ~ factor(drv), data = df)\n\n\n\n\nEğer hem sürekli hem de kategorik değişkenleri incelemek istersek, benzer şekilde görselleştirme ve kategoriler arasında merkezi eğilim ölçüleri hesaplanabilir. Bunlar dışında uygun istatistiksel testler de gerçekleştirilebilir.\n\n# Silindir düzeyinde yakıt tüketimi \ntapply(df$cty_ltkm, df$cyl, mean)\n\n       4        5        6        8 \n8.920545 8.703034 6.883968 5.337052 \n\n# Same using aggregate()\naggregate(cty_ltkm ~ cyl, data = df, FUN = mean)\n\n  cyl cty_ltkm\n1   4 8.920545\n2   5 8.703034\n3   6 6.883968\n4   8 5.337052\n\nboxplot(cty_ltkm ~ cyl, data = df)"
  },
  {
    "objectID": "data_analysis.html#zaman-serileri",
    "href": "data_analysis.html#zaman-serileri",
    "title": "Keşifçi Veri Analizi",
    "section": "Zaman Serileri",
    "text": "Zaman Serileri\nR programlama dili, zaman serileri analizi için kapsamlı bir dizi fonksiyon ve paket sunar. Zaman serileri analizi, zaman içindeki veri noktalarının örüntülerini ve trendlerini incelemeyi amaçlar. R’de zaman serileri ile çalışmak için ts (time series) nesnesi kullanılır. Bu nesne, zaman serisi verilerini zaman dilimleri (örneğin aylar, yıllar) veya tarihler ile ilişkilendirerek işlem yapmanıza olanak tanır.\n\nAirPassengers\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949 112 118 132 129 121 135 148 148 136 119 104 118\n1950 115 126 141 135 125 149 170 170 158 133 114 140\n1951 145 150 178 163 172 178 199 199 184 162 146 166\n1952 171 180 193 181 183 218 230 242 209 191 172 194\n1953 196 196 236 235 229 243 264 272 237 211 180 201\n1954 204 188 235 227 234 264 302 293 259 229 203 229\n1955 242 233 267 269 270 315 364 347 312 274 237 278\n1956 284 277 317 313 318 374 413 405 355 306 271 306\n1957 315 301 356 348 355 422 465 467 404 347 305 336\n1958 340 318 362 348 363 435 491 505 404 359 310 337\n1959 360 342 406 396 420 472 548 559 463 407 362 405\n1960 417 391 419 461 472 535 622 606 508 461 390 432\n\nclass(AirPassengers)\n\n[1] \"ts\"\n\ndiff(AirPassengers) # fark alma\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n1949         6   14   -3   -8   14   13    0  -12  -17  -15   14\n1950   -3   11   15   -6  -10   24   21    0  -12  -25  -19   26\n1951    5    5   28  -15    9    6   21    0  -15  -22  -16   20\n1952    5    9   13  -12    2   35   12   12  -33  -18  -19   22\n1953    2    0   40   -1   -6   14   21    8  -35  -26  -31   21\n1954    3  -16   47   -8    7   30   38   -9  -34  -30  -26   26\n1955   13   -9   34    2    1   45   49  -17  -35  -38  -37   41\n1956    6   -7   40   -4    5   56   39   -8  -50  -49  -35   35\n1957    9  -14   55   -8    7   67   43    2  -63  -57  -42   31\n1958    4  -22   44  -14   15   72   56   14 -101  -45  -49   27\n1959   23  -18   64  -10   24   52   76   11  -96  -56  -45   43\n1960   12  -26   28   42   11   63   87  -16  -98  -47  -71   42\n\nstats::lag(AirPassengers,-1) # 1. gecikmesini alma\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949     112 118 132 129 121 135 148 148 136 119 104\n1950 118 115 126 141 135 125 149 170 170 158 133 114\n1951 140 145 150 178 163 172 178 199 199 184 162 146\n1952 166 171 180 193 181 183 218 230 242 209 191 172\n1953 194 196 196 236 235 229 243 264 272 237 211 180\n1954 201 204 188 235 227 234 264 302 293 259 229 203\n1955 229 242 233 267 269 270 315 364 347 312 274 237\n1956 278 284 277 317 313 318 374 413 405 355 306 271\n1957 306 315 301 356 348 355 422 465 467 404 347 305\n1958 336 340 318 362 348 363 435 491 505 404 359 310\n1959 337 360 342 406 396 420 472 548 559 463 407 362\n1960 405 417 391 419 461 472 535 622 606 508 461 390\n1961 432                                            \n\nplot(AirPassengers,type = \"p\", col = \"red\") # points\n\n\n\nplot(AirPassengers,type = \"l\", col = \"red\") # line\n\n\n\nplot(AirPassengers,type = \"o\", col = \"red\") # points and line\n\n\n\nplot(log(AirPassengers),type = \"l\", col = \"red\") # line\n\n\n\nplot(diff(AirPassengers),type = \"l\", col = \"red\") # line\n\n\n\nplot(diff(log(AirPassengers)),type = \"l\", col = \"red\") # line\n\n\n\n# çoklu zaman serisi\nts &lt;- ts(rnorm(length(AirPassengers),250,100),start = c(1949,1),frequency=12)\nts\n\n           Jan       Feb       Mar       Apr       May       Jun       Jul\n1949 278.96535 114.53522 116.78620 361.73318 182.41074 225.06181  67.45037\n1950 226.77935 285.45601 240.48110 249.82423 335.34842 184.67030 272.92566\n1951 233.54479 333.87056 332.54276 110.43874 319.18811 402.50463 203.34418\n1952 205.55658 352.07189 302.37655 409.72353 212.77281 189.54196 264.48528\n1953 254.10484 229.24681 187.46337 222.35826 439.73750 178.01008 172.71463\n1954 279.33018 201.51951 -21.68321 327.16029 158.09051 298.24599 203.67413\n1955  50.03159 147.42826 196.76799 166.06033 172.49158 154.28273 360.84180\n1956 212.81279 265.21671  40.52710 435.51436 372.57653 335.31943 210.92622\n1957 322.67948 203.87736 435.02266 206.19576 204.11664  94.22509 414.59607\n1958 154.05305 213.44239 198.15454  49.50637 468.91369 156.13108 267.89070\n1959 343.32304 345.15140 316.27060 217.39409 262.30882 403.76765 181.74899\n1960 254.52051 191.22889 200.13586 135.01184 215.05186  96.39628 338.77372\n           Aug       Sep       Oct       Nov       Dec\n1949 317.15196 158.78602 225.62738 476.01834 244.49575\n1950 384.03229 223.46846 170.31565  85.78947 240.42425\n1951 114.99765 128.07276 321.31852 238.56674  90.62292\n1952 125.87453 226.56875  93.89823 388.97714 320.72613\n1953 347.62228 406.59737 275.87203 173.82779  91.47566\n1954 119.09888  98.55656 207.25911 166.74977 203.14970\n1955 124.43062 264.82667 185.24413 357.77833 393.71958\n1956 226.08741 423.68081 114.97916 197.01657 213.75413\n1957 123.35400 433.62748 348.89537  72.72973 131.10108\n1958 311.81814 211.44119 100.34773 244.00268 399.01858\n1959 302.78804  61.56371 290.50066 235.58686 149.11884\n1960 341.97458 425.73843 283.06990 230.35078 257.20417\n\nplot(AirPassengers,type = \"l\",col = \"red\")\nlines(ts, type = \"l\", col = \"blue\")\n\n\n\n# yüzde değişim\ngrowth &lt;- AirPassengers/stats::lag(AirPassengers,-1)*100-100\ngrowth\n\n             Jan         Feb         Mar         Apr         May         Jun\n1949               5.3571429  11.8644068  -2.2727273  -6.2015504  11.5702479\n1950  -2.5423729   9.5652174  11.9047619  -4.2553191  -7.4074074  19.2000000\n1951   3.5714286   3.4482759  18.6666667  -8.4269663   5.5214724   3.4883721\n1952   3.0120482   5.2631579   7.2222222  -6.2176166   1.1049724  19.1256831\n1953   1.0309278   0.0000000  20.4081633  -0.4237288  -2.5531915   6.1135371\n1954   1.4925373  -7.8431373  25.0000000  -3.4042553   3.0837004  12.8205128\n1955   5.6768559  -3.7190083  14.5922747   0.7490637   0.3717472  16.6666667\n1956   2.1582734  -2.4647887  14.4404332  -1.2618297   1.5974441  17.6100629\n1957   2.9411765  -4.4444444  18.2724252  -2.2471910   2.0114943  18.8732394\n1958   1.1904762  -6.4705882  13.8364780  -3.8674033   4.3103448  19.8347107\n1959   6.8249258  -5.0000000  18.7134503  -2.4630542   6.0606061  12.3809524\n1960   2.9629630  -6.2350120   7.1611253  10.0238663   2.3861171  13.3474576\n             Jul         Aug         Sep         Oct         Nov         Dec\n1949   9.6296296   0.0000000  -8.1081081 -12.5000000 -12.6050420  13.4615385\n1950  14.0939597   0.0000000  -7.0588235 -15.8227848 -14.2857143  22.8070175\n1951  11.7977528   0.0000000  -7.5376884 -11.9565217  -9.8765432  13.6986301\n1952   5.5045872   5.2173913 -13.6363636  -8.6124402  -9.9476440  12.7906977\n1953   8.6419753   3.0303030 -12.8676471 -10.9704641 -14.6919431  11.6666667\n1954  14.3939394  -2.9801325 -11.6040956 -11.5830116 -11.3537118  12.8078818\n1955  15.5555556  -4.6703297 -10.0864553 -12.1794872 -13.5036496  17.2995781\n1956  10.4278075  -1.9370460 -12.3456790 -13.8028169 -11.4379085  12.9151292\n1957  10.1895735   0.4301075 -13.4903640 -14.1089109 -12.1037464  10.1639344\n1958  12.8735632   2.8513238 -20.0000000 -11.1386139 -13.6490251   8.7096774\n1959  16.1016949   2.0072993 -17.1735242 -12.0950324 -11.0565111  11.8784530\n1960  16.2616822  -2.5723473 -16.1716172  -9.2519685 -15.4013015  10.7692308\n\nplot(growth,type = \"l\", col = \"red\")"
  },
  {
    "objectID": "data_analysis.html#veri-analizi-bazı-paketler",
    "href": "data_analysis.html#veri-analizi-bazı-paketler",
    "title": "Keşifçi Veri Analizi",
    "section": "Veri Analizi Bazı Paketler",
    "text": "Veri Analizi Bazı Paketler\nVeri analizi için skimr paketi de kullanılabilir. skimr, R programlama dilinde veri setlerinin hızlı bir şekilde özetlenmesini sağlayan bir pakettir. Veri setlerinin yapısını, özelliklerini ve bazı istatistiksel özetlerini görsel ve açıklayıcı bir şekilde sunar. Bu paket, veri keşfi aşamasında veri setinin genel özelliklerini anlamak için kullanılır.\nskimr paketi, veri setinizdeki değişkenlerin türlerine göre istatistiksel özetler sunar. Örneğin, sayısal değişkenler için merkezi eğilim ölçüleri (ortalama, medyan), dağılım (standart sapma, min-max değerleri), faktör değişkenleri için sınıf sayısı, en sık rastlanan sınıf ve eksik veri durumları gibi bilgileri sunar.\nBu paket, veri setinin yapısını hızlıca anlamak ve önemli özelliklerini keşfetmek için kullanılır. Özellikle veri setlerinin keşfedilmesi, temizlenmesi ve analiz edilmesi aşamalarında oldukça faydalıdır. Bu, veri analiz sürecinde veriye daha derinlemesine bakmayı ve hangi analiz tekniklerinin kullanılacağına dair daha iyi bir anlayış geliştirmeyi sağlar.\nBunun yanında, modelsummary paketi de, R programlama dili için geliştirilmiş olan bir pakettir ve istatistiksel modellerin özetlenmesi, karşılaştırılması ve görselleştirilmesi için kullanılır. Bu paket, farklı türdeki modellerin çıktılarını standartlaştırarak, bunları karşılaştırmak ve analiz etmek için kullanıcıya kolaylık sağlar.\nBu paket genellikle doğrusal regresyon, lojistik regresyon, karar ağaçları, destek vektör makineleri gibi çeşitli istatistiksel ve makine öğrenimi modellerinin özet istatistiklerini, katsayılarını, belirlilik ölçülerini, hata ölçümlerini ve diğer önemli çıktıları sunar. Bunların yanı sıra, çıktıları tablolar halinde gösterir ve görselleştirmeler yaparak model performansını karşılaştırmak için grafikler oluşturabilir.\nBu paket, araştırmacılar, veri bilimcileri veya istatistikçilerin farklı modelleri anlamak, karşılaştırmak ve raporlamak için verimli bir araç sunar. Model sonuçlarını görselleştirme ve karşılaştırma açısından kullanışlıdır. Paket, model özetlerinin ötesinde, veri kümesine genel bakış, korelasyon matrisleri, (çok seviyeli) çapraz tablolar ve denge tabloları gibi son derece esnek veri özet tabloları üretmek için bir dizi araç da içerir.\n\n# Paketin birkaç özelliğine bakalım\n\nlibrary(modelsummary)\n\nWarning: package 'modelsummary' was built under R version 4.2.3\n\n# kategorik verilere hızlı bir bakış\ndatasummary_skim(mpg, \"categorical\")\n\n\n\n\n\n\nN\n%\n\n\n\n\nmanufacturer\naudi\n18\n7.7\n\n\n\nchevrolet\n19\n8.1\n\n\n\ndodge\n37\n15.8\n\n\n\nford\n25\n10.7\n\n\n\nhonda\n9\n3.8\n\n\n\nhyundai\n14\n6.0\n\n\n\njeep\n8\n3.4\n\n\n\nland rover\n4\n1.7\n\n\n\nlincoln\n3\n1.3\n\n\n\nmercury\n4\n1.7\n\n\n\nnissan\n13\n5.6\n\n\n\npontiac\n5\n2.1\n\n\n\nsubaru\n14\n6.0\n\n\n\ntoyota\n34\n14.5\n\n\n\nvolkswagen\n27\n11.5\n\n\nmodel\n4runner 4wd\n6\n2.6\n\n\n\na4\n7\n3.0\n\n\n\na4 quattro\n8\n3.4\n\n\n\na6 quattro\n3\n1.3\n\n\n\naltima\n6\n2.6\n\n\n\nc1500 suburban 2wd\n5\n2.1\n\n\n\ncamry\n7\n3.0\n\n\n\ncamry solara\n7\n3.0\n\n\n\ncaravan 2wd\n11\n4.7\n\n\n\ncivic\n9\n3.8\n\n\n\ncorolla\n5\n2.1\n\n\n\ncorvette\n5\n2.1\n\n\n\ndakota pickup 4wd\n9\n3.8\n\n\n\ndurango 4wd\n7\n3.0\n\n\n\nexpedition 2wd\n3\n1.3\n\n\n\nexplorer 4wd\n6\n2.6\n\n\n\nf150 pickup 4wd\n7\n3.0\n\n\n\nforester awd\n6\n2.6\n\n\n\ngrand cherokee 4wd\n8\n3.4\n\n\n\ngrand prix\n5\n2.1\n\n\n\ngti\n5\n2.1\n\n\n\nimpreza awd\n8\n3.4\n\n\n\njetta\n9\n3.8\n\n\n\nk1500 tahoe 4wd\n4\n1.7\n\n\n\nland cruiser wagon 4wd\n2\n0.9\n\n\n\nmalibu\n5\n2.1\n\n\n\nmaxima\n3\n1.3\n\n\n\nmountaineer 4wd\n4\n1.7\n\n\n\nmustang\n9\n3.8\n\n\n\nnavigator 2wd\n3\n1.3\n\n\n\nnew beetle\n6\n2.6\n\n\n\npassat\n7\n3.0\n\n\n\npathfinder 4wd\n4\n1.7\n\n\n\nram 1500 pickup 4wd\n10\n4.3\n\n\n\nrange rover\n4\n1.7\n\n\n\nsonata\n7\n3.0\n\n\n\ntiburon\n7\n3.0\n\n\n\ntoyota tacoma 4wd\n7\n3.0\n\n\ntrans\nauto(av)\n5\n2.1\n\n\n\nauto(l3)\n2\n0.9\n\n\n\nauto(l4)\n83\n35.5\n\n\n\nauto(l5)\n39\n16.7\n\n\n\nauto(l6)\n6\n2.6\n\n\n\nauto(s4)\n3\n1.3\n\n\n\nauto(s5)\n3\n1.3\n\n\n\nauto(s6)\n16\n6.8\n\n\n\nmanual(m5)\n58\n24.8\n\n\n\nmanual(m6)\n19\n8.1\n\n\ndrv\n4\n103\n44.0\n\n\n\nf\n106\n45.3\n\n\n\nr\n25\n10.7\n\n\nfl\nc\n1\n0.4\n\n\n\nd\n5\n2.1\n\n\n\ne\n8\n3.4\n\n\n\np\n52\n22.2\n\n\n\nr\n168\n71.8\n\n\nclass\n2seater\n5\n2.1\n\n\n\ncompact\n47\n20.1\n\n\n\nmidsize\n41\n17.5\n\n\n\nminivan\n11\n4.7\n\n\n\npickup\n33\n14.1\n\n\n\nsubcompact\n35\n15.0\n\n\n\nsuv\n62\n26.5\n\n\n\n\n\n\n# nümerik verilere hızlı bir bakış\ndatasummary_skim(mpg, \"numeric\")\n\n\n\n\n\nUnique (#)\nMissing (%)\nMean\nSD\nMin\nMedian\nMax\n\n\n\n\n\ndispl\n35\n0\n3.5\n1.3\n1.6\n3.3\n7.0\n\n\n\nyear\n2\n0\n2003.5\n4.5\n1999.0\n2003.5\n2008.0\n\n\n\ncyl\n4\n0\n5.9\n1.6\n4.0\n6.0\n8.0\n\n\n\ncty\n21\n0\n16.9\n4.3\n9.0\n17.0\n35.0\n\n\n\nhwy\n27\n0\n23.4\n6.0\n12.0\n24.0\n44.0"
  },
  {
    "objectID": "ggplot2.html",
    "href": "ggplot2.html",
    "title": "ggplot2 ile Veri Görselleştirme",
    "section": "",
    "text": "Dağılım Grafikleri\nDağılım grafikleri, veri setinin dağılımını görsel olarak temsil etmek için kullanılan grafik türleridir. Bu grafikler, veri noktalarının, değerlerinin veya gözlemlerinin nasıl dağıldığını incelemek ve veri setindeki desenleri, eğilimleri ve aykırı değerleri anlamak için kullanılır. En yaygın olanı histogram grafikleridir.\nHistogram, veri setinin sayısal dağılımını gösteren bir grafiktir. Veri aralığı belli bir aralığa bölen çubuklardan oluşur ve her çubuk, bu aralıktaki veri noktalarının sayısını temsil eder. Histogramlar genellikle sürekli verilerin dağılımını göstermek için kullanılır.\nBunun dışında boxplot (kutu) grafikleri de dağılımı görselleştirmek için kullanılmaktadır. Boxplot, veri setinin beş özet istatistiği (minimum, ilk çeyrek, medyan, üçüncü çeyrek, maksimum) kullanarak veri dağılımını temsil eder. Bu grafik, aykırı değerleri tanımlamak ve merkezi eğilim ile dağılımın yayılmasını görsel olarak incelemek için kullanılır.\ngeom_histogram fonksiyonu, ggplot2 paketinde kullanılan bir grafik geometrisidir ve histogram oluşturmak için kullanılır.\nlibrary(ggplot2)\nlibrary(dplyr)\n\nggplot(diamonds, aes(price)) +\n  geom_histogram()\nbinwidth parametresi, histogramdaki sütunların genişliğini (veya “bin” genişliğini) belirlemek için kullanılır. Histogram, veri setini belirli aralıklara böler ve her aralıkta kaç gözlem olduğunu gösteren sütunlardan oluşur. Bu aralıklara “bin” denir ve binwidth parametresi, bu aralıkların genişliğini belirler.\nggplot(diamonds, aes(price)) +\n  geom_histogram(binwidth = 1000,fill = \"green\")\nBu örnekte, binwidth = 1000 ifadesiyle belirtilen bin genişliği ile bir histogram oluşturulmuştur. Bu, veri setini 1000 birim genişliğinde olan aralıklara bölecektir.\ngeom_histogram fonksiyonu aynı zamanda bins parametresini de kullanarak histogramdaki sütun sayısını belirlemenize olanak tanır. bins parametresi, veri setinin aralıklara bölünme sayısını belirler.\n# Karat değerlerinin histogramı\nggplot(diamonds, aes(x = carat)) +\n  geom_histogram(bins = 30, fill = \"skyblue\", color = \"black\") +\n  labs(title = \"Histogram of Diamond Carat\",\n       x = \"Carat\",\n       y = \"Frequency\")\nBu örnekte, bins = 30 ifadesiyle belirtilen 30 sütunlu bir histogram oluşturulmuştur. fill ve color parametreleri, sütunların içinin ve kenar çizgilerinin renklendirilmesi için kullanılmıştır.\nalpha argümanı, ggplot2 paketinde kullanılan bir estetiktir ve bir geometrinin (örneğin, nokta, çizgi, sütun, vb.) saydamlığını kontrol etmek için kullanılır. alpha değeri, 0 ile 1 arasında bir sayıdır; 0 tamamen şeffaflığı (görünmez) ve 1 tam opaklığı temsil eder.\nÖzellikle, alpha argümanı, bir nesnenin diğer nesnelerle örtüldüğü durumları görselleştirmek için kullanışlıdır. Örneğin, nokta, sütun veya çizgilerin birbirini örttüğü durumlarda kullanılabilir.\n# Kesim sınıflarına göre karat yoğunluk fonksiyonları ile grafik oluştur\nggplot(diamonds, aes(x = carat, fill = cut)) +\n  geom_density(alpha = 0.5, color = \"black\") +\n  labs(title = \"Density Plot of Carat by Cut\",\n       x = \"Carat\",\n       y = \"Density\",\n       fill = \"Cut\") +\n  theme_minimal()\nBu örnekte, geom_density fonksiyonunu kullanarak elmasların karat değerlerinin kesim sınıflarına göre yoğunluk fonksiyonlarını gösteren bir grafik oluşturduk. alpha = 0.5 ifadesiyle belirtilen saydamlık düzeyi, farklı kesim sınıflarına ait yoğunluk fonksiyonlarının birbirini örttüğü bölgeleri daha iyi görselleştirmek için kullanılmıştır. color = \"black\" ifadesi ise çizgi renklerini belirtir.\ntheme_minimal, ise ggplot2 paketinde bulunan bir tema (theme) fonksiyonudur. Tema fonksiyonları, grafiklerin görünümünü özelleştirmek için kullanılır ve çeşitli özellikleri kontrol eder. theme_minimal özel bir temadır ve belirli bir stilde basitleştirilmiş bir görünüm sağlar. Bu tema, grafik üzerindeki çizgi ve arka plan öğelerini minimalist bir şekilde düzenler. Yani, daha az çerçeve, gölgeleme ve artı dekoratif özellik içerir. Bu, veriyi vurgulamak ve grafiği daha okunabilir hale getirmek amacıyla kullanılır.\nfacet_wrap fonksiyonu, ggplot2 paketinde bir tema (facet) fonksiyonudur ve veriyi belirli bir faktör veya değişkenle bölerken, aynı grafik tasarımını korumak için kullanılır. Bu, veri setinizin bir kategorisine göre alt grafikler oluşturmanıza olanak tanır.\nÖrneğin, “diamonds” veri setindeki kesim sınıflarına (cut) göre karat (carat) değerlerini gösteren bir grafik oluşturalım ve bunu facet_wrap kullanarak kesim sınıflarına göre ayrı alt grafiklere bölelim.\n# Kesim sınıflarına göre karat değerlerini gösteren grafik oluştur\nggplot(diamonds, aes(x = carat, fill = cut)) +\n  geom_density(alpha = 0.5, color = \"black\") +\n  labs(title = \"Density Plot of Carat by Cut\",\n       x = \"Carat\",\n       y = \"Density\",\n       fill = \"Cut\") +\n  facet_wrap(~cut, scales = \"free_y\") +\n  theme_minimal()\nBu örnekte, facet_wrap(~cut, scales = \"free_y\") ifadesi ile “cut” değişkenine göre alt grafiklere bölme işlemi gerçekleştirilmiştir. scales = \"free_y\" ifadesi, y eksenlerinin serbest bırakılmasını, yani her bir alt grafikte y eksen ölçeğinin kendi içinde adapte edilmesini sağlar. Bu, alt grafikler arasında karşılaştırma yapmayı kolaylaştırır.\nfacet_grid fonksiyonu, ggplot2 paketinde bir başka tema (facet) fonksiyonudur ve iki faktörü kullanarak bir tabloyu alt grafiklere böler. facet_wrap fonksiyonu ile benzerdir, ancak farklı bir düzenleme yapısına sahiptir. Örneğin, “diamonds” veri setindeki kesim sınıflarına (cut) ve renklere (color) göre karat (carat) değerlerini gösteren bir grafik oluşturalım.\n# Kesim sınıflarına ve renklere göre karat değerlerini gösteren grafik oluştur\nggplot(diamonds, aes(x = carat, fill = cut)) +\n  geom_density(alpha = 0.5, color = \"black\") +\n  labs(title = \"Density Plot of Carat by Cut and Color\",\n       x = \"Carat\",\n       y = \"Density\",\n       fill = \"Cut\") +\n  facet_grid(cut ~ color, scales = \"free_y\") +\n  theme_minimal()\ngeom_boxplot, ggplot2 paketinde kullanılan bir geometri fonksiyonudur ve veri setindeki bir sayısal değişkenin (örneğin, fiyat, karat, vb.) dağılımını görselleştirmek için kullanılır. Bu fonksiyon, bir kutu çizgisinin çizilmesi ve altında ve üstünde yer alan uç (whisker) hatlarıyla birlikte medyan ve çeyrekliklerin görüntülenmesini sağlar.\nKutu grafikleri, veri dağılımının merkezi eğilimini, yayılımını ve simetrisini hızlı bir şekilde gösteren etkili bir araçtır. Aşağıda, “diamonds” veri setindeki kesim sınıflarına göre fiyatların geom_boxplot kullanılarak nasıl görselleştirileceğine dair bir örnek bulunmaktadır.\n# Kesim sınıflarına göre fiyatları gösteren boxplot oluştur\nggplot(diamonds, aes(x = cut, y = price, fill = cut)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot of Prices by Cut\",\n       x = \"Cut\",\n       y = \"Price\",\n       fill = \"Cut\") +\n  theme_minimal()\nBu kod, her bir kesim sınıfının fiyat dağılımını gösteren bir boxplot oluşturur. Her bir kutu, verinin çeyrekliklerini (Q1, medyan, Q3) temsil eder ve uç hatlar (whisker) genellikle verinin genel yayılımını gösterir. Bu şekilde, elmas fiyatlarının kesim sınıfları arasındaki dağılımı hızlı bir şekilde görebilirsiniz.\ngeom_boxplot kullanırken ortalamayı göstermek için bazı ek ayarlamalar yapabiliriz. Özellikle, stat_summary fonksiyonunu kullanarak ortalamayı içeren bir çizgi ekleyebiliriz. Aşağıda, stat_summary fonksiyonunu kullanarak her kutu içindeki ortalamayı gösteren bir örnek bulunmaktadır.\n# Kesim sınıflarına göre fiyatları gösteren boxplot oluştur\nggplot(diamonds, aes(x = cut, y = price, fill = cut)) +\n  geom_boxplot() +\n  stat_summary(\n    fun = mean,\n    geom = \"point\",\n    shape = 18,\n    size = 3,\n    color = \"red\",\n    position = position_dodge(0.75)\n  ) +\n  labs(title = \"Boxplot of Prices by Cut with Mean\",\n       x = \"Cut\",\n       y = \"Price\",\n       fill = \"Cut\") +\n  theme_minimal()\nposition = position_dodge(0.75) ifadesi, stat_summary fonksiyonu içinde kullanılarak ortalamayı temsil eden noktaların (mean points) yatay yönde bir miktar kaydırılmasını ifade eder. Bu, ortalamayı gösteren noktaların, boxplot içinde daha düzenli ve anlamlı bir şekilde görünmesini sağlamak için kullanılır.\nDetaylı olarak açıklamak gerekirse; position_dodge(0.75), noktaların kutuların içinde yatay yönde ne kadar kaydırılacağını belirtir. Bu değer 0 ile 1 arasında bir sayıdır ve 0, hiç kaydırma anlamına gelirken, 1, tamamen ayrık bir konumu temsil eder. Yani, 0.75, noktaların bir miktar sağa kaydırılmasını ifade eder. Bu birim genellikle x-eksenindeki veri genişliği ya da ölçeğine bağlıdır. Eğer x-eksenindeki veriler sayısal değilse (örneğin, kategorik değişkenler) birim genişliği birimi anlam taşımaz ve yatay konumları düzenlemede başka bir anlam ifade edebilir. Ancak, sayısal veri genişliği olan durumlarda, bu birim genişliği x-eksenindeki veri aralığına karşılık gelir.\nBu şekilde, ortalamayı gösteren noktalar, kutular içinde daha rahat bir şekilde görünebilir ve boxplot üzerinde daha net bir şekilde ayrılabilir. Bu tür ayarlamalar, grafiklerin daha okunabilir ve anlaşılır olmasına katkıda bulunabilir.\nBoxplot grafiğine benzer şekilde kullanabileceğimiz başka bir grafik çeşidi ise violin grafikleridir. Violin grafiği, bir sayısal değişkenin dağılımını görselleştirmek için kullanılır. Violin grafiği, bir kutu plotunun etrafına simetrik olarak yerleştirilen birer çift yay (kernel density estimate) içerir. Bu yaylar, veri setinin yoğunluk fonksiyonunu temsil eder ve kutu plotunun içindeki medyan, çeyreklikler ve diğer istatistiklerle birleştirilir.\nViolin grafiği, kutu plotunun sunduğu merkezi eğilim ve yayılım bilgilerine ek olarak, veri setinin dağılımının şekli ve yoğunluğu hakkında daha fazla bilgi sağlar. Grafiğin geniş kısımları, veri setinin yoğun olduğu bölgeleri temsil ederken, dar kısımlar daha düşük yoğunluğa sahip alanları gösterir. Bu sayede, violin grafiği veri setinin dağılımının görsel bir özetini sunar.\n# Kesim sınıflarına göre fiyatların violin grafiği\nggplot(diamonds, aes(x = cut, y = price, fill = cut)) +\n  geom_violin() +\n  labs(title = \"Violin Plot of Prices by Cut\",\n       x = \"Cut\",\n       y = \"Price\",\n       fill = \"Cut\") +\n  theme_minimal()\nBu violin grafiği, kesim sınıfları arasında fiyat dağılımlarını karşılaştırmak için kullanılır. Violin grafiği, her bir kesim sınıfının fiyat yoğunluğunu ve merkezi eğilimini görsel olarak özetler.",
    "crumbs": [
      "ggplot2 ile Veri Görselleştirme"
    ]
  },
  {
    "objectID": "ggplot2.html#zaman-serisi-grafikleri",
    "href": "ggplot2.html#zaman-serisi-grafikleri",
    "title": "ggplot2 ile Veri Görselleştirme",
    "section": "Zaman Serisi Grafikleri",
    "text": "Zaman Serisi Grafikleri\nZaman serisi grafikleri, zamanla değişen verileri görsel olarak temsil etmek için kullanılan grafiklerdir. Bu tür grafikler, belirli bir süre boyunca gözlemlenen verileri analiz etmek, eğilimleri belirlemek, dönemsel desenleri tanımak ve istatistiksel analizler yapmak için yaygın olarak kullanılır. Zaman serisi verileri genellikle sabit aralıklarla veya farklı zaman dilimlerinde toplanır. En yaygın olan türü çizgi grafikleri olmakla birlikte sütun ve alan grafikleri de zaman serilerinin görselleştirilmesinde kullanılabilmektedir.\nÖrnekler ggplot2 paketi ile birlikte gelen economics veri seti ile yapılacaktır.\n\n# verileri inceleyelim\neconomics\n\n# A tibble: 574 × 6\n   date         pce    pop psavert uempmed unemploy\n   &lt;date&gt;     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n 1 1967-07-01  507. 198712    12.6     4.5     2944\n 2 1967-08-01  510. 198911    12.6     4.7     2945\n 3 1967-09-01  516. 199113    11.9     4.6     2958\n 4 1967-10-01  512. 199311    12.9     4.9     3143\n 5 1967-11-01  517. 199498    12.8     4.7     3066\n 6 1967-12-01  525. 199657    11.8     4.8     3018\n 7 1968-01-01  531. 199808    11.7     5.1     2878\n 8 1968-02-01  534. 199920    12.3     4.5     3001\n 9 1968-03-01  544. 200056    11.7     4.1     2877\n10 1968-04-01  544  200208    12.3     4.6     2709\n# ℹ 564 more rows\n\nsummary(economics)\n\n      date                 pce               pop            psavert      \n Min.   :1967-07-01   Min.   :  506.7   Min.   :198712   Min.   : 2.200  \n 1st Qu.:1979-06-08   1st Qu.: 1578.3   1st Qu.:224896   1st Qu.: 6.400  \n Median :1991-05-16   Median : 3936.8   Median :253060   Median : 8.400  \n Mean   :1991-05-17   Mean   : 4820.1   Mean   :257160   Mean   : 8.567  \n 3rd Qu.:2003-04-23   3rd Qu.: 7626.3   3rd Qu.:290291   3rd Qu.:11.100  \n Max.   :2015-04-01   Max.   :12193.8   Max.   :320402   Max.   :17.300  \n    uempmed          unemploy    \n Min.   : 4.000   Min.   : 2685  \n 1st Qu.: 6.000   1st Qu.: 6284  \n Median : 7.500   Median : 7494  \n Mean   : 8.609   Mean   : 7771  \n 3rd Qu.: 9.100   3rd Qu.: 8686  \n Max.   :25.200   Max.   :15352  \n\n\neconomics veri setinde bulunan date ve pce (Personal Consumption Expenditures - Kişisel Tüketim Harcamaları) değişkenlerini kullanarak bir zaman serisi grafiği oluşturalım.\n\np &lt;- economics %&gt;% \n  ggplot(aes(x=date,y=pce)) +\n  geom_line(color=\"blue\") +\n  theme_minimal() +\n  labs(x = \"\",\n       y = \"Personal Consumption Expenditures\",\n       title = \"Personal Consumption Expenditures Time Series\",\n       caption = \"Economics Data\",\n       subtitle = \"Economics Data (1967-2015)\")\np\n\n\n\n\n\n\n\n\nAşağıda bu kodun adım adım açıklamasını bulabilirsiniz:\n\neconomics %&gt;%: Bu işlem, “pipe” (%&gt;%) operatörünü kullanarak economics veri setini bir dizi başka işleme yönlendirir. Bu, veri manipülasyonunu daha okunabilir ve zincirleme bir şekilde yapmamıza olanak tanır.\nggplot(aes(x=date, y=pce)): ggplot() fonksiyonu, temel bir grafik oluşturur. aes() fonksiyonu içinde x ve y argümanları, grafiğin x ve y eksenine hangi verilerin yerleştirileceğini belirtir. Bu durumda, x ekseni date değişkenini, y ekseni ise pce değişkenini kullanır.\ngeom_line(color=\"blue\"): geom_line() fonksiyonu, bir çizgi grafiği ekler. Bu durumda, color=\"blue\" argümanı ile çizgi rengi mavi olarak belirlenmiştir.\ntheme_minimal(): Bu fonksiyon, grafiği daha sade bir görünüme getirmek için kullanılır. Başka temalar da seçilebilir.\nlabs(x=\"\", y=\"Personal Consumption Expenditures\", title=\"Personal Consumption Expenditures Time Series\", caption=\"Economics Data\", subtitle=\"Economics Data (1967-2015)\"): labs() fonksiyonu, grafiğin başlığını, eksen etiketlerini ve diğer metin öğelerini ayarlar. x=\"\" ile x ekseninin başlığı kaldırılmış, y=\"Personal Consumption Expenditures\" ile y ekseninin başlığı belirlenmiş, title=\"Personal Consumption Expenditures Time Series\" ile grafik başlığı belirlenmiş, subtitle=\"Economics Data (1967-2015)\" ile alt başlık eklenmiştir.\n\nBu kod, economics veri setindeki tüketim harcamalarının zaman içindeki değişimini mavi bir çizgi grafiği ile gösteren bir ggplot2 grafiği oluşturur.\n\n# zaman eksenini ve legend ayarlama\np + \n  scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\") +\n  theme(axis.text.x = element_text(angle = 45), legend.position = \"top\")\n\n\n\n\n\n\n\n\np ismini verdiğimiz grafik objesine eklenen kısım, scale_x_date() ve theme() fonksiyonlarıyla grafiğin x ekseni üzerindeki tarih etiketlerini ve genel görünümü özelleştirmektedir. Aşağıda bu kodun eklenmiş haliyle birlikte açıklamasını bulabilirsiniz:\n\nscale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\"): Bu bölüm, x ekseni üzerindeki tarih etiketlerini özelleştirmek için kullanılır. date_breaks argümanı, tarih etiketlerinin kaç yılda bir görüneceğini belirler. date_labels argümanı ise tarih etiketlerinin nasıl formatlanacağını belirler. Bu örnekte, her yılın gösterilmesi ve yıl formatında görüntülenmesi belirlenmiştir.\ntheme(axis.text.x = element_text(angle = 45), legend.position = \"top\"): Bu bölüm, genel görünümü özelleştirmek için kullanılır. axis.text.x ile x ekseni etiketlerinin açısını belirleyebiliriz (burada 45 derece olarak belirlenmiştir). legend.position ile ise lejantın grafiğin neresinde yer alacağını belirleyebiliriz (burada “top” olarak belirlenmiştir).\n\nBu eklemelerle birlikte, grafiğin x ekseni üzerinde yıllık tarih etiketleri görünecek ve bu etiketler 45 derece eğimli olacak. Ayrıca, lejant grafiğin üst kısmına yerleştirilecektir.\n\np + \n  scale_x_date(date_breaks = \"2 year\", date_labels = \"%Y\",expand = c(0,0)) +\n  theme(axis.text.x = element_text(angle = 45), legend.position = \"top\")\n\n\n\n\n\n\n\n\nEklendiğiniz bu kod parçası ile x eksenindeki tarih etiketleri, 2 yılda bir görünecek şekilde ayarlanmıştır (date_breaks = \"2 year\"). Ayrıca, expand = c(0, 0) ile x ekseninin başlangıç ve bitişindeki boşluklar sıfır olarak belirlenmiştir. Bu, x ekseninin kenarlarına sıfır boşluk bırakarak grafiği daha kompakt hale getirir.\n\n# çizgi türü değiştirilebilir\neconomics %&gt;% \n  ggplot(aes(x=date,y=pce)) +\n  geom_line(linetype = \"dashed\", size = 1, colour = \"blue\")\n\n\n\n\n\n\n\n\nlinetype argümanı, çizgi tipini belirler (burada “dashed” olarak belirlenmiştir). size argümanı, çizgi kalınlığını belirler (1 olarak belirlenmiştir). colour argümanı ise çizgi rengini belirler (mavi olarak belirlenmiştir).\n\n\n\n\n\n\nEk Bilgi\n\n\n\nlinetype parametresi, geom_line() fonksiyonu ile çizgi grafiği oluştururken çizgi tipini belirlemek için kullanılır. Bu parametre, çeşitli değerleri kabul eder. İşte yaygın olarak kullanılan bazı linetype değerleri:\n\n\"solid\": Tam çizgi (Varsayılan).\n\"dashed\": Kesikli çizgi.\n\"dotted\": Noktalı çizgi.\n\"dotdash\": Noktalı-kesikli çizgi.\n\"longdash\": Uzun kesikli çizgi.\n\"twodash\": Çift kesikli çizgi.\n\"blank\": Hiç çizgi çizme (görselde görüntülenmez).\n\nÖrneğin, linetype = \"dashed\" ifadesi, çizginin kesikli olacağını belirtir. Bu değeri dışında başka özelleştirmeler de yapabilirsiniz. linetype parametresi, daha karmaşık çizgi tipleri oluşturmak için farklı uzunluk ve boşluk kombinasyonlarına da izin verir.\nlinetype parametresine yerine sayısal değerleri de atanabilir. Örneğin linetype = 1 ifadesi linetype = \"solid\" ile aynı anlama gelir. Yukarıda verilen linetype türlerinin yanındaki da rakamlar da kullanılabilir.\n\n\neconomics veri setinden sadece 2010 yılı ve sonrasındaki verileri filtreleyip, bu verileri kullanarak bir zaman serisi çizgi grafiği oluşturalım. Aynı zamanda, geom_point() fonksiyonu kullanılarak çizgilerin üzerine kırmızı renkte ve büyük boyutta daireler ekleyelim.\n\n# zaman grafiğine noktalar ekleme\neconomics %&gt;% \n  filter(lubridate::year(date) &gt;= 2010) %&gt;% \n  ggplot(aes(x=date,y=pce)) +\n  geom_line()+\n  geom_point(size = 3, shape= 7, colour = \"red\")\n\n\n\n\n\n\n\n\n\nfilter(lubridate::year(date) &gt;= 2010): Bu satır, lubridate paketini kullanarak date sütunundaki yıl bilgisine göre filtreleme yapar. Yalnızca 2010 yılı ve sonrasındaki verileri içeren bir alt küme oluşturur.\nggplot(aes(x = date, y = pce)): Bu satır, ggplot nesnesini oluşturur ve x ekseni olarak date sütununu, y ekseni olarak ise pce sütununu belirler.\ngeom_line(): Bu fonksiyon, çizgi grafiğini oluşturur.\ngeom_point(size = 3, shape = 7, colour = \"red\"): Bu fonksiyon, nokta grafiğini oluşturur. size argümanı noktaların boyutunu, shape argümanı nokta tipini (7, çizgi içeren bir daire), colour argümanı ise nokta rengini belirler. Bu durumda, noktalar kırmızı renkte ve büyük boyutta çizgi içeren daireler olarak belirlenmiştir.\n\n\n\n\n\n\n\nEk Bilgi\n\n\n\nsize Parametresi:\n\nSayılar (Numeric): Noktaların boyutunu belirtir. Örneğin, size = 3 noktaları küçük, size = 5 noktaları büyük yapar.\n\nshape Parametresi:\nshape parametresi, noktaların farklı şekillerde görüntülenmesini sağlar. İşte bazı yaygın shape değerleri:\n\nSayılar (Numeric): Noktanın şeklini belirtir. Örneğin, shape = 0 noktaları daire, shape = 1 noktaları üçgen yapar.\nKarakterler (Characters): Belirli bir karakteri kullanarak şekli belirtirsiniz. Örneğin, shape = \"A\" noktaları yıldız, shape = \"B\" noktaları kare yapar.\nÖzel Semboller: Belirli sembollerle ilişkilendirilmiş değerleri kullanabilirsiniz. Örneğin, shape = 16 noktaları çarpı sembolü yapar.\nÖzel Sembollerin İsimleri: Özel sembollerin adlarını da kullanabilirsiniz. Örneğin, shape = \"cross\" noktaları çarpı sembolü yapar.\n\nBu değerlerin tam listeleri, R’nin resmi belgelerinde ve ggplot2’nin belgelerinde bulunabilir. Ayrıca, ?geom_point komutunu R ortamında kullanarak doğrudan yardım belgesine erişebilir ve orada kullanılabilecek değerleri inceleyebilirsiniz.\n\n\nZaman serilerini görselleştirmek için alan grafikleri de kullanılabilir. Alan grafiği (Area Plot), bir değişkenin zaman içinde veya başka bir değişkenle ilişkili olarak nasıl değiştiğini görselleştirmek için kullanılan bir grafik türüdür. Bu grafik, genellikle bir değişkenin toplamını veya yüzey alanını temsil eder. Alan grafiği, bir çizgi grafiği gibi trendleri gösterirken, aynı zamanda altındaki alanın renklendirilmesi ile de değişkenin toplamını anlamamıza yardımcı olur.\neconomics veri setindeki date ve pce değişkenleri kullanılarak bir alan grafiği (area plot) oluşturalım. Aynı zamanda, y ekseni aralıkları belirli bir düzenle (scale_y_continuous fonksiyonu kullanılarak) özelleştirelim.\n\n# gölgeli zaman grafiği\neconomics %&gt;% \n  ggplot(aes(x=date,y=pce)) +\n  geom_area(color=\"blue\",fill=\"red\",alpha=0.6) +\n  # y ekseni aralıklarını ayarlama\n  scale_y_continuous(breaks = seq(0, max(economics$pce), by = 1000))\n\n\n\n\n\n\n\n\n\ngeom_area(color = \"blue\", fill = \"red\", alpha = 0.6): Bu satır, alan grafiğini oluşturur. color parametresi çizgi rengini, fill parametresi dolgu rengini, ve alpha parametresi saydamlığı belirler. Bu durumda, çizgi rengi mavi (blue), dolgu rengi kırmızı (red), ve saydamlık değeri 0.6 olarak belirlenmiştir.\nscale_y_continuous(breaks = seq(0, max(economics$pce), by = 1000)): Bu satır, y ekseni aralıklarını belirler. breaks parametresi ile belirli aralıklarda y ekseni etiketlerini belirleyebilirsiniz. Bu örnekte, 0’dan başlayarak pce sütunundaki maksimum değere kadar 1000’lik aralıklarla etiketler belirlenmiştir. Bu, y ekseni etiketlerini daha düzenli bir şekilde göstermeye yardımcı olur.\n\nSonuç olarak, bu kod economics veri setindeki kişisel tüketim harcamalarını temsil eden bir alan grafiği oluşturur.\neconomics verisi geniş formatlı (wide format) bir veri setidir. Bu, her bir zaman noktasında bir satır ve değişkenleri sütunlarda içerir. Fakat bazı durumlarda uzun formatlı verileri kullanmak daha fazla avantaj sağlayabilir. economics_long ise uzun formatlı (long format) bir veri setidir. Bu, her bir gözlem biriminin (örneğin, bir tarih ve bir değişken kombinasyonu) bir satırda yer aldığı ve bir sütunun gözlemlenen değerleri içerdiği bir yapıdır. economics ve economics_long veri setleri, temelde aynı veri setini temsil eden farklı yapılandırmalara sahip veri setleridir.\nGeniş formatlı veri setleri genellikle analizlerde daha kolay okunabilir olabilir, ancak bazı analiz teknikleri için uygun olmayabilir. Uzun formatlı veri setleri genellikle analiz ve görselleştirmelerde daha esneklik sağlar. ggplot2 gibi paketlerle kullanıldığında, farklı değişkenlere göre grafikler oluşturmak daha kolaydır.\neconomics_long veri seti içindeki date , value ve variable değişkenlerini kullanarak çoklu bir zaman serisi çizgi grafiği oluşturalım.\n\n# verinin yapısını inceleyelim\nglimpse(economics_long)\n\nRows: 2,870\nColumns: 4\n$ date     &lt;date&gt; 1967-07-01, 1967-08-01, 1967-09-01, 1967-10-01, 1967-11-01, …\n$ variable &lt;chr&gt; \"pce\", \"pce\", \"pce\", \"pce\", \"pce\", \"pce\", \"pce\", \"pce\", \"pce\"…\n$ value    &lt;dbl&gt; 506.7, 509.8, 515.6, 512.2, 517.4, 525.1, 530.9, 533.6, 544.3…\n$ value01  &lt;dbl&gt; 0.0000000000, 0.0002652497, 0.0007615234, 0.0004706043, 0.000…\n\n# ilk 10 gözleme bakalım\nhead(economics_long,10)\n\n# A tibble: 10 × 4\n   date       variable value  value01\n   &lt;date&gt;     &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n 1 1967-07-01 pce       507. 0       \n 2 1967-08-01 pce       510. 0.000265\n 3 1967-09-01 pce       516. 0.000762\n 4 1967-10-01 pce       512. 0.000471\n 5 1967-11-01 pce       517. 0.000916\n 6 1967-12-01 pce       525. 0.00157 \n 7 1968-01-01 pce       531. 0.00207 \n 8 1968-02-01 pce       534. 0.00230 \n 9 1968-03-01 pce       544. 0.00322 \n10 1968-04-01 pce       544  0.00319 \n\n# çoklu zaman serisi grafiği oluşturalım\neconomics_long %&gt;% \n  ggplot(aes(x=date,y=value))+\n  geom_line() +\n  facet_wrap(~variable,scales = \"free_y\")+\n  scale_y_log10() # y eksenlerinin logaritması alınır\n\n\n\n\n\n\n\n\n\nggplot(aes(x = date, y = value)): Bu satır, ggplot nesnesini oluşturur ve x ekseni olarak date sütununu, y ekseni olarak ise value sütununu belirler.\ngeom_line(): Bu fonksiyon, çizgi grafiğini oluşturur.\nfacet_wrap(~variable, scales = \"free_y\"): Bu fonksiyon, variable değişkenine göre alt grafiklere ayrılmasını sağlar (facet_wrap). scales = \"free_y\" parametresi ile y ekseni ölçeğinin her alt grafikte bağımsız olarak ayarlanmasını sağlar.\nscale_y_log10(): Bu fonksiyon, y ekseni ölçeğini logaritmik olarak değiştirir. Bu, verilerin logaritmik ölçekte daha iyi anlaşılmasına yardımcı olabilir, özellikle büyük değerler arasında değişim olduğunda.\n\nSonuç olarak, bu kod, economics_long veri setindeki farklı değişkenlere (variable) ait zaman serisi çizgi grafiklerini logaritmik y ekseni ile birleştirilmiş bir şekilde gösterir.",
    "crumbs": [
      "ggplot2 ile Veri Görselleştirme"
    ]
  },
  {
    "objectID": "ggplot2.html#sütun-grafikleri",
    "href": "ggplot2.html#sütun-grafikleri",
    "title": "ggplot2 ile Veri Görselleştirme",
    "section": "Sütun Grafikleri",
    "text": "Sütun Grafikleri\nSütun grafikleri, verileri kategorik veya gruplara göre temsil etmek için kullanılan bir grafik türüdür. Bu grafik türü, farklı kategorilerin veya grupların sayısal değerlerini karşılaştırmak veya görselleştirmek için kullanılır. Sütun grafikleri dikey çubuklardan oluşur ve her çubuk, bir kategori veya grup için bir değeri temsil eder. Sütun grafiklerinin temel bileşenleri şunlardır:\n\nYatay Eksen (X-Eksen): Bu eksende kategoriler veya gruplar yer alır. Örneğin, bir yıl boyunca aylar, ürün kategorileri, bölgeler veya şirket departmanları gibi farklı kategoriler olabilir.\nDikey Eksen (Y-Eksen): Bu eksende sayısal değerler yer alır ve sütunların yükseklikleri bu değerleri temsil eder. Değerler genellikle sayısal verilerdir ve karşılaştırılabilir bir ölçü birimi içinde bulunurlar.\nSütunlar: Sütunlar, her bir kategori veya grup için bir değeri temsil eder. Sütunların yükseklikleri, karşılaştırılan değerlerin büyüklüğünü veya ilişkilerini gösterir.\n\nSütun grafikleri, aşağıdaki amaçlar için kullanılır:\n\nKarşılaştırmalar: Farklı kategorilerin veya grupların değerlerini karşılaştırmak için kullanılır. Örneğin, farklı ülkelerin gayri safi yurtiçi hasıla (GSYİH) değerlerini karşılaştırmak için sütun grafikleri kullanılabilir.\nZaman İçi Değişim: Zaman serisi verilerini temsil etmek için kullanılabilir. Her sütun, belirli bir zaman dilimindeki değerleri gösterebilir.\nKategorik Verilerin İncelenmesi: Ürün kategorileri, şirket departmanları veya müşteri segmentleri gibi kategorik verilerin analizi için kullanılabilir.\n\nSütun grafikleri, verileri görsel olarak anlamak ve veriler arasındaki farkları veya eğilimleri vurgulamak için etkili bir araçtır. Aynı zamanda verilerin daha kolay anlaşılmasına yardımcı olabilir ve karar verme süreçlerine katkı sağlayabilir.\nÖrnekler ggplot2 paketi ile birlikte gelen diamonds veri seti ile yapılacaktır. Veri hakkında bilgi sahibi olmak için dplyr paketinde yer alan glimpse fonksiyonunu kullanabiliriz. Bu fonksiyon, bir veri çerçevesi veya tibble nesnesini özetleyen ve hızlı bir bakış sunan bir fonksiyondur. glimpse fonksiyonu, veri setindeki değişkenleri, veri türlerini, ve ilk birkaç gözlemi görüntüler. Ayrıca summary fonksiyonu ile de veride yer alan değişkenlerin temel istatistikleri hakkında bilgi sahibi olabiliriz.\n\nglimpse(diamonds)\n\nRows: 53,940\nColumns: 10\n$ carat   &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.…\n$ cut     &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver…\n$ color   &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I,…\n$ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, …\n$ depth   &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64…\n$ table   &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58…\n$ price   &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 34…\n$ x       &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.…\n$ y       &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.…\n$ z       &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.…\n\nsummary(diamonds)\n\n     carat               cut        color        clarity          depth      \n Min.   :0.2000   Fair     : 1610   D: 6775   SI1    :13065   Min.   :43.00  \n 1st Qu.:0.4000   Good     : 4906   E: 9797   VS2    :12258   1st Qu.:61.00  \n Median :0.7000   Very Good:12082   F: 9542   SI2    : 9194   Median :61.80  \n Mean   :0.7979   Premium  :13791   G:11292   VS1    : 8171   Mean   :61.75  \n 3rd Qu.:1.0400   Ideal    :21551   H: 8304   VVS2   : 5066   3rd Qu.:62.50  \n Max.   :5.0100                     I: 5422   VVS1   : 3655   Max.   :79.00  \n                                    J: 2808   (Other): 2531                  \n     table           price             x                y         \n Min.   :43.00   Min.   :  326   Min.   : 0.000   Min.   : 0.000  \n 1st Qu.:56.00   1st Qu.:  950   1st Qu.: 4.710   1st Qu.: 4.720  \n Median :57.00   Median : 2401   Median : 5.700   Median : 5.710  \n Mean   :57.46   Mean   : 3933   Mean   : 5.731   Mean   : 5.735  \n 3rd Qu.:59.00   3rd Qu.: 5324   3rd Qu.: 6.540   3rd Qu.: 6.540  \n Max.   :95.00   Max.   :18823   Max.   :10.740   Max.   :58.900  \n                                                                  \n       z         \n Min.   : 0.000  \n 1st Qu.: 2.910  \n Median : 3.530  \n Mean   : 3.539  \n 3rd Qu.: 4.040  \n Max.   :31.800  \n                 \n\n\nSütun grafiği üretebilmek için kullanılan fonksiyonlardan bir tanesi geom_bar()’dır. Aşağıda verilen kod veri setindeki kesim sınıflarını ifade eden cut değişkenin frekanslarını gösteren bir sütun grafik üretir. Her bir sütun, belirli bir kesim sınıfını temsil eder ve yükseklikleri o kesim sınıfına ait elmas sayısını yansıtır.\n\n# sıklık durumunu görselleştirme\nggplot(diamonds, aes(cut)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nÖrneğin color değişkenine göre gruplandırılmış bir grafik üretelim. Aşağıda yer alan kod, “diamonds” veri setindeki kesim sınıflarının ve renklerinin kombinasyonlarına göre gruplandırılmış bir sütun grafik üretir. Her bir cut kategorisi için ayrı renkli sütunlar olacaktır.\n\nggplot(diamonds, aes(cut, fill = color)): Bu bölümde, “diamonds” veri setini temel alarak bir ggplot nesnesi oluşturulur. aes(cut, fill = color) ifadesi, x ekseninde “cut” değişkenini, sütunların renklendirilmesinde ise “color” değişkenini kullanacağımızı belirtir.\ngeom_bar(position = position_dodge()): Bu fonksiyon, gruplandırılmış sütun grafik oluşturur. position = position_dodge() ifadesi, sütunların yan yana yerleştirilmesini sağlar, yani her bir cut kategorisi içindeki color kategorilerini farklı renklerde gösterir. Bu sayede, her bir cut kategorisi için ayrı renkli sütunlar elde edilir.\n\n\nggplot(diamonds, aes(cut, fill = color)) +\n  geom_bar(position = position_dodge()) + \n  xlab(\"Pirlanta kaliteleri\") + \n  ylab(\"Gozlenme Sikliklari\")\n\n\n\n\n\n\n\n\nHer bir kesim sınıfı için, color değişkenine göre renklendirilmiş sütunları olan ve her sütunun yüksekliği, o kesim sınıfındaki elmasların toplam karat değerini temsil eden bir grafik üretelim. Bu durumda y ekseninde carat değişkenini kullanacağız.\ngeom_bar(stat = \"identity\"): Bu fonksiyon, gruplandırılmış sütun grafik oluşturur. stat = \"identity\" ifadesi, her bir sütunun yüksekliğinin, “carat” değişkeninin değerine eşit olacağını belirtir. Yani, sütunların yüksekliği doğrudan carat değişkenine bağlı olacaktır.\n\nggplot(diamonds, aes(x=cut, y=carat,fill = color)) +\n  geom_bar(stat = \"identity\") \n\n\n\n\n\n\n\n\nEğer position = \"fill\" kullanırsak, geom_bar fonksiyonu, her kategori içindeki değerlerin oranlarını gösteren yığılmış bir sütun grafik oluşturur. Bu durumda, her bir kategori toplam yüksekliğe göre doldurulacak ve her bir alt kategori, kendi kategorisi içindeki oranını ifade edecek şekilde düzenlenecektir.\n\nggplot(diamonds, aes(x=cut, y=carat,fill = color)) +\n  # fill ile oransal olarak gösterim yapılır\n  geom_bar(stat = \"identity\",position = \"fill\") \n\n\n\n\n\n\n\n\nHer bir kesim sınıfının toplam yüksekliğe göre doldurulduğu bu grafikte, her renk kategorisi içindeki sütunlar, o kesim sınıfındaki toplam elmas sayısına oranlanmış şekilde görüntülenir. Bu tür bir grafik, her bir kategorinin toplamda ne kadar paya sahip olduğunu vurgulamak ve kategorinin içindeki alt kategorilerin oranlarını göstermek için kullanışlıdır. Ancak, grafikteki renklerin yorumlanması dikkatlice yapılmalıdır, çünkü her renk, kendi kategorisi içindeki oranları temsil eder.\n\n\n\n\n\n\nDikkat\n\n\n\nİki tür çubuk grafik vardır: geom_bar() ve geom_col(). geom_bar(), çubuğun yüksekliğini her gruptaki vaka sayısıyla (veya ağırlık estetiği sağlanmışsa, ağırlıkların toplamıyla) orantılı hale getirir. Çubukların yüksekliklerinin verilerdeki değerleri temsil etmesini istiyorsanız, bunun yerine geom_col() kullanın. geom_bar() varsayılan olarak stat_count() kullanır: her x konumundaki vaka sayısını sayar. geom_col() stat_identity() kullanır. Yani verileri olduğu gibi bırakır.",
    "crumbs": [
      "ggplot2 ile Veri Görselleştirme"
    ]
  },
  {
    "objectID": "ggplot2.html#dağılım-grafikleri",
    "href": "ggplot2.html#dağılım-grafikleri",
    "title": "ggplot2 ile Veri Görselleştirme",
    "section": "",
    "text": "Dikkat\n\n\n\nposition_dodge fonksiyonunda belirtilen değer 1’den büyük olabilir. Ancak, 1’den büyük bir değer kullanmak genellikle uygunsuz sonuçlara yol açar. Bu durumda, noktalar birbirine çok yakın hale gelir ve grafik üzerinde karışıklık olabilir. Ayarlamayı denemek ve grafik üzerindeki etkilerini gözlemlemek, en iyi sonuca ulaşmak için önemlidir.",
    "crumbs": [
      "ggplot2 ile Veri Görselleştirme"
    ]
  },
  {
    "objectID": "ggplot2.html#grafiklerin-kaydedilmesi",
    "href": "ggplot2.html#grafiklerin-kaydedilmesi",
    "title": "ggplot2 ile Veri Görselleştirme",
    "section": "Grafiklerin Kaydedilmesi",
    "text": "Grafiklerin Kaydedilmesi\nGrafik oluşturulduktan sonra, grafik objesini bir değişkende saklayabilirsiniz (aşağıdaki örnekte “grafik” adını kullandık). Grafik objesini bir değişkende sakladıktan sonra, ggsave() fonksiyonunu kullanarak grafik dosyasını kaydedebilirsiniz. Grafikleri ayrıca RStudio penceresinin sağ alt kısmında yer alan Plots sekmesindeki Export ile kayıt altına alabilirsiniz.\nAşağıda kod ile, işsizlik oranlarının aylık değişimini içeren bir çubuk grafik oluşturalım ve bu değişimleri pozitif veya negatif olarak etiketleyelim. Öncesinde işsizlik değişkenini kullanarak aylık değişim hesaplayalım ve bu değerleri “pozitif” ya da “negatif” olarak etiketleyelim. Daha sonra veri setindeki eksik değerleri temizleyelim ve belirli bir tarih aralığını filtreleyerek bir çubuk grafikle görselleştirelim. En son olarak da bu grafiği kaydedelim.\n\ngrafik &lt;- economics %&gt;%\n  mutate(\n    uemploy_mom = unemploy / lag(unemploy) * 100 - 100,\n    growth = ifelse(uemploy_mom &gt; 0, \"pozitif\", \"negatif\")\n  ) %&gt;%\n  na.omit() %&gt;%\n  filter(lubridate::year(date) &gt;= 2010) %&gt;%\n  ggplot(aes(x = date, y = uemploy_mom, fill = growth)) +\n  geom_col() +\n  theme(legend.position = \"none\") +\n  labs(y = \"Aylık Değişim\",\n       title = \"Yıllara göre Aylık İstihdam Değişimi (2010-2015)\")\n\ngrafik\n\n\n\n\n\n\n\n\nggsave fonksiyonu, ggplot2 paketinde oluşturulan grafikleri bir dosyaya kaydetmek için kullanılır. Bu fonksiyon, genellikle ggplot2 ile oluşturulan grafikleri bir resim dosyası (PNG, JPEG, PDF vb.) olarak kaydetmek için tercih edilen bir yöntemdir.\n\nggsave(\n  \"grafik1.png\", # kaydedilecek dosya adı\n  grafik, # kaydedilecek grafik nesnesi\n  width = 20, # grafiğin genişliği\n  height = 8, # grafiğin yüksekliği\n  units = \"cm\" # genişlik ve yüksekliğin birimi\n)\n\n# dpi ile çözünürlük ayarlanabilir\nggsave(\n  \"grafik1.png\",\n  grafik,\n  width = 20,\n  height = 8,\n  unit = \"cm\",\n  dpi = 300 # çözünürlük\n)\n\nArgümanlar:\n\nfilename: Kaydedilecek dosyanın adı. Örneğin, “grafik.png” şeklinde bir dosya adı belirtilebilir.\nplot: Kaydedilecek ggplot nesnesi. Varsayılan olarak, en son oluşturulan grafik (last_plot()) kullanılır.\ndevice: Kaydedilecek dosya türünü belirler. Örneğin, “png”, “jpeg”, “pdf” gibi değerler alabilir.\npath: Kaydedilecek dosyanın yolu. Eğer belirtilmezse, çalışma dizini kullanılır.\nscale: Grafik ölçeğini belirler. Varsayılan değeri 1’dir.\nwidth, height: Grafik boyutunu belirler. Varsayılan olarak, ggplot nesnesinin orijinal boyutu kullanılır.\nunits: width ve height argümanlarının birimi. Örneğin, “in” (inç), “cm” (santimetre), “mm” (milimetre) gibi değerler alabilir.\ndpi: Piksel başına inç (dots per inch) çözünürlük. Özellikle raster grafik dosyaları için önemlidir.",
    "crumbs": [
      "ggplot2 ile Veri Görselleştirme"
    ]
  },
  {
    "objectID": "data_preprocess.html",
    "href": "data_preprocess.html",
    "title": "Veri Ön İşleme",
    "section": "",
    "text": "Eksik Veriler\nEksik veriler, bir veri setinde belirli gözlemlerde veya değişkenlerde eksik veya boş değerler içeren durumlardır. Eksik veriler, ölçüm hatası, veri toplama sürecindeki problemler veya rasgele olaylar nedeniyle ortaya çıkabilir. Sistematik bir kayıp gözlem durumu yoksa ortada ciddi bir sorun yoktur. Ama rastgele olmayan bir hata varsa tüm kitleye dair yanlılık olacağı için bu durum göz ardı edilemez.\nEksik Verilerin Türleri:\nEksik veriler için daha fazla örnek aşağıda yer almaktadır:\nHer bir örnek, eksik verilerin farklı nedenlere dayanabileceğini ve bu nedenlere bağlı olarak başa çıkma stratejilerinin belirlenmesi gerektiğini göstermektedir. Eksik verilerin türlerini anlamak, başa çıkma stratejilerini belirlemede önemlidir çünkü stratejiler eksik verilerin nasıl oluştuğuna bağlı olarak farklılık gösterebilir. MCAR durumu, basit bir ortalama atama stratejisinin kullanılmasını daha kabul edilebilir kılabilirken, MAR ve MNAR durumları daha sofistike yöntemleri gerektirebilir.\n# Örnek veri seti oluşturalım\n# üreteç sabitlenir\nset.seed(123)\ndata &lt;- data.frame(\n  ID = 1:10,\n  Age = c(25, 30, NA, 22, 35, 40, NA, 28, NA, 32),\n  Income = c(50000, 60000, 75000, NA, 80000, 90000, 70000, NA, 65000, 75000),\n  Score = c(80, 85, 90, 78, NA, 88, 92, 85, 80, NA)\n)\n\n# veride hiç NA var mı? \n# TRUE tabloda en az bir tane NA olduğu anlamına gelir \nanyNA(data)\n\n[1] TRUE\n\n# eksik verilerin sorgulanması\nis.na(data) \n\n         ID   Age Income Score\n [1,] FALSE FALSE  FALSE FALSE\n [2,] FALSE FALSE  FALSE FALSE\n [3,] FALSE  TRUE  FALSE FALSE\n [4,] FALSE FALSE   TRUE FALSE\n [5,] FALSE FALSE  FALSE  TRUE\n [6,] FALSE FALSE  FALSE FALSE\n [7,] FALSE  TRUE  FALSE FALSE\n [8,] FALSE FALSE   TRUE FALSE\n [9,] FALSE  TRUE  FALSE FALSE\n[10,] FALSE FALSE  FALSE  TRUE\n\n# toplam eksik veri sayısını tespit etmek\nsum(is.na(data))\n\n[1] 7\n\n# değişken düzeyinde eksik veri sayısını tespit etmek\ncolSums(is.na(data)) \n\n    ID    Age Income  Score \n     0      3      2      2",
    "crumbs": [
      "Veri Ön İşleme"
    ]
  },
  {
    "objectID": "data_preprocess.html#imputasyon",
    "href": "data_preprocess.html#imputasyon",
    "title": "Veri Ön İşleme",
    "section": "İmputasyon",
    "text": "İmputasyon\nİmputasyon terimi, eksik verilerin yerine konulması veya doldurulması işlemine atıfta bulunur. Eksik veriler, bir veri setinde belirli gözlemler veya değişkenler için eksik veya bilinmeyen değerler içeren durumlardır. İstatistiksel analiz yaparken eksik verilerle başa çıkmak önemlidir çünkü eksik veriler, sonuçları yanıltabilir veya analizleri etkileyebilir.\nİmputasyon, eksik verileri doldurmak veya tahmin etmek için kullanılan çeşitli istatistiksel yöntemleri ifade eder. İmputasyon işlemi, eksik verileri analizde kullanılabilir hale getirmek amacıyla yapılır. İmputasyon yöntemleri, veri setinin yapısına ve eksik verilerin nedenlerine bağlı olarak değişebilir. Yaygın olarak kullanılan bazı imputasyon yöntemleri ve eksik verilerle başa çıkma stratejileri aşağıda verilmiştir:\n\nSilme (Deletion):\n\nListwise Deletion (Tamamen Eksik Gözlemleri Silme): Eksik veri içeren gözlemleri veri setinden tamamen çıkarır. Ancak, bu yöntem veri kaybına neden olabilir ve analizin güvenilirliğini azaltabilir.\nPairwise Deletion (Çiftler Arası Silme): Her analizde eksik verisi olan değişkenleri dışlamadan eksik verilerle çalışmayı sağlar.\n\nBasit Değer Atama (Single Imputation):\n\nOrtalama, Medyan veya Mod Atama: Eksik değerlere ortalama, medyan veya mod değerleri atanabilir. Ancak, bu yöntem veri dağılımını etkileyebilir. Ortalama ile atama, eksik verilerin diğer gözlemlerdeki ortalama değerlere benzer olduğu varsayımına dayanır. Medyan ile atama ise, verilerdeki aşırı değerlerden etkilenmeyeceği için ortalama değere göre daha dayanıklı bir seçenek olarak tercih edilebilir.\nDoldurma (Interpolation): Zaman serisi verilerinde kullanılan bir yöntemdir. Mevcut değerlere dayanarak eksik değerleri tahmin eder.\n\nÇoklu Değer Atama (Multiple Imputation):\n\nBirden fazla kez eksik verileri doldurur ve her birini farklı bir “tamamlanmış” veri seti olarak ele alır. Bu, belirsizlikle başa çıkma avantajına sahiptir.\n\nModel Tabanlı Yöntemler:\n\nİleri düzey istatistiksel modeller veya makine öğrenimi algoritmaları kullanarak eksik değerleri tahmin edebilir. KNN (K Nearest Neighbor-En Yakın Komşu), regresyon analizi ve karar ağaçları bu tür yöntemlere örnektir.\n\n\nİmputasyon yöntemi, veri setinin özelliklerine, eksik verilerin miktarına ve verilerin doğasına bağlı olarak seçilir. Her yöntemin avantajları ve dezavantajları vardır, bu nedenle doğru yöntemi seçmek, analizin doğruluğunu ve güvenilirliğini etkileyebilir. İmputasyonun amacı, eksik verilerin doğru ve güvenilir bir şekilde doldurulmasıdır, böylece analiz sonuçları daha kesin ve anlamlı olur.\n\nEksik Verilerin Silinmesi\nEksik verilerin silinmesi, bir analizde kullanılan veri setinden eksik değerlere sahip olan gözlemlerin veya değişkenlerin tamamen çıkarılması anlamına gelir. Ancak, bu strateji her zaman uygun değildir, çünkü veri kaybına neden olabilir ve analizin güvenilirliğini azaltabilir. Bu nedenle, dikkatlice düşünülmesi gereken bir yöntemdir.\n\n# Eksik verilere sahip gözlemleri sil\ndata_no_missing &lt;- na.omit(data)\n\n# Sonucu göster\nprint(data_no_missing)\n\n  ID Age Income Score\n1  1  25  50000    80\n2  2  30  60000    85\n6  6  40  90000    88\n\n\nBu örnekte, “Age”, “Income” ve “Score” değişkenlerinde eksik verilere sahip olan bir veri seti oluşturuldu. Ardından, na.omit() fonksiyonu kullanılarak eksik verilere sahip gözlemler silindi. Ancak, bu işlemle birlikte bazı gözlemler tamamen silinmiş oldu.\n\n# complete.cases ile eksik verilere sahip gözlemleri filtrele\ncomplete_data &lt;- data[complete.cases(data), ]\n\n# Sonucu göster\nprint(complete_data)\n\n  ID Age Income Score\n1  1  25  50000    80\n2  2  30  60000    85\n6  6  40  90000    88\n\n\ncomplete.cases(data) ifadesi, veri setindeki tamamen eksiksiz olan gözlemleri belirleyerek TRUE ve FALSE değerlerinden oluşan bir mantıksal vektör oluşturur. Daha sonra, bu mantıksal vektör kullanılarak sadece tamamen eksiksiz olan gözlemleri içeren yeni bir veri seti oluşturulur.\nEksik verilerin silinmesi avantajlı olabilir çünkü veri seti daha temiz hale gelir ve analiz daha basitleşir. Ancak, bu yaklaşımın dezavantajı, silinen gözlemler nedeniyle veri setindeki genel örüntülerin ve ilişkilerin değişebileceğidir. Ayrıca, eksik veri durumunun mevcut olduğu durumlarda analiz yapılamayabilir. Bu nedenle, eksik verilerin silinmesi stratejisini kullanmadan önce eksik verilerin neden kaynaklandığını anlamak ve analizin amacını dikkate almak önemlidir.\n\n\nEksik Değerlere Basit Değer Atama\nEksik değerlere basit değer atama, eksik değerlere sabit bir değer, ortalama, medyan veya mod gibi basit bir istatistiksel ölçüt atanması anlamına gelir. Bu, eksik verilerin tahmin edilmesinde basit ancak yaygın bir yöntemdir.\nEksik değerlere basit bir değer atamak için, örneğin, Age değişkenindeki eksik değerlere ortalama değeri atayabiliriz:\n\n# Age değişkenindeki eksik değerlere ortalama değeri atama\ndata$Age[is.na(data$Age)] &lt;- mean(data$Age, na.rm = TRUE)\n\n# Değişiklikleri göster\nprint(data)\n\n   ID      Age Income Score\n1   1 25.00000  50000    80\n2   2 30.00000  60000    85\n3   3 30.28571  75000    90\n4   4 22.00000     NA    78\n5   5 35.00000  80000    NA\n6   6 40.00000  90000    88\n7   7 30.28571  70000    92\n8   8 28.00000     NA    85\n9   9 30.28571  65000    80\n10 10 32.00000  75000    NA\n\n\nBu örnekte, is.na(data$Age) ifadesi, Age değişkenindeki eksik değerlere TRUE, eksik olmayan değerlere FALSE döndüren bir mantıksal vektör oluşturur. Ardından, mean(data$Age, na.rm = TRUE) ifadesi ile Age değişkeninin ortalama değeri hesaplanır ve eksik değerlere bu ortalama değer atanır.\nAynı yöntem, diğer basit istatistiksel ölçütlerle de uygulanabilir. Örneğin, eksik değerlere medyan veya belirli bir sabit değer atanabilir.\n\n# Income değişkenindeki eksik değerlere medyan değeri atama\ndata$Income[is.na(data$Income)] &lt;- median(data$Income, na.rm = TRUE)\n\n# Score değişkenindeki eksik değerlere sabit bir değer (örneğin, 75) atama\ndata$Score[is.na(data$Score)] &lt;- 75\n\n# Değişiklikleri göster\nprint(data)\n\n   ID      Age Income Score\n1   1 25.00000  50000    80\n2   2 30.00000  60000    85\n3   3 30.28571  75000    90\n4   4 22.00000  72500    78\n5   5 35.00000  80000    75\n6   6 40.00000  90000    88\n7   7 30.28571  70000    92\n8   8 28.00000  72500    85\n9   9 30.28571  65000    80\n10 10 32.00000  75000    75\n\n\nEksik değerlere çoklu olarak basit değer atama yapmak için sapply fonksiyonu kullanılabilir. Bu fonksiyon, bir liste veya vektör üzerinde bir işlemi tekrarlamak için kullanılır.\n\n# Örnek veri seti yeniden oluşturalım\n# Çünkü önceki örneklerde farklı yöntemlerle değer atadık.\n# üreteç sabitlenir\nset.seed(123)\ndata &lt;- data.frame(\n  ID = 1:10,\n  Age = c(25, 30, NA, 22, 35, 40, NA, 28, NA, 32),\n  Income = c(50000, 60000, 75000, NA, 80000, 90000, 70000, NA, 65000, 75000),\n  Score = c(80, 85, 90, 78, NA, 88, 92, 85, 80, NA)\n)\n\n\n# Sapply ile eksik değerlere ortalama değeri atama\nsapply(data, function(x)\n  ifelse(is.na(x), mean(x, na.rm = TRUE), x))\n\n      ID      Age Income Score\n [1,]  1 25.00000  50000 80.00\n [2,]  2 30.00000  60000 85.00\n [3,]  3 30.28571  75000 90.00\n [4,]  4 22.00000  70625 78.00\n [5,]  5 35.00000  80000 84.75\n [6,]  6 40.00000  90000 88.00\n [7,]  7 30.28571  70000 92.00\n [8,]  8 28.00000  70625 85.00\n [9,]  9 30.28571  65000 80.00\n[10,] 10 32.00000  75000 84.75\n\n\nEksik değerleri doldurmak için zoo paketinde bulunan na.locf, na.approx ve na.spline fonksiyonları oldukça kullanışlıdır. Bu fonksiyonlar, sırasıyla bir önceki değeri kullanma (last observation carried forward), doğrusal interpolasyon ve spline interpolasyon yöntemlerini içerir.\nna.locf, na.approx, ve na.spline fonksiyonları, zaman serisi verilerinde eksik değerleri doldurmak için özellikle kullanışlıdır. Bu fonksiyonlar, zaman içinde belirli bir düzeni takip eden verilerdeki eksik değerleri tahmin etmek için tasarlanmıştır. İşte bu fonksiyonlar ve uygun oldukları senaryoların kısa bir açıklaması:\nna.locf (Last Observation Carried Forward): Zaman serisi verilerinde, gözlemler arasındaki sürekli düzeni korumak istediğiniz durumlar. Önceki gözlemin değeri, sonraki eksik gözlemin değeri olarak kabul edilir.\n\nlibrary(zoo)\n# carry forward\n# eksik değerler bir önceki gözlemin değeriyle doldurulur.\nsapply(data, function(x) ifelse(is.na(x), na.locf(x), x ))\n\n      ID Age Income Score\n [1,]  1  25  50000    80\n [2,]  2  30  60000    85\n [3,]  3  30  75000    90\n [4,]  4  22  75000    78\n [5,]  5  35  80000    78\n [6,]  6  40  90000    88\n [7,]  7  40  70000    92\n [8,]  8  28  70000    85\n [9,]  9  28  65000    80\n[10,] 10  32  75000    80\n\n\nna.approx (Linear Approximation): Zaman serisi verilerinde, eksik değerleri doğrusal bir eğilimle doldurmak istediğiniz durumlar. Ancak, doğrusal interpolasyon, verilerde gerçekten doğrusal bir ilişki olduğu durumları varsayar.\n\n# linear interpolation\n# eksik değerler doğrusal interpolasyon yöntemiyle doldurulur.\nsapply(data, function(x) ifelse(is.na(x), na.approx(x), x ))\n\n      ID Age Income Score\n [1,]  1  25  50000    80\n [2,]  2  30  60000    85\n [3,]  3  26  75000    90\n [4,]  4  22  77500    78\n [5,]  5  35  80000    83\n [6,]  6  40  90000    88\n [7,]  7  34  70000    92\n [8,]  8  28  67500    85\n [9,]  9  30  65000    80\n[10,] 10  32  75000    80\n\n\nna.spline (Spline Approximation): Zaman serisi verilerinde, eksik değerleri spline interpolasyon yöntemi ile doldurmak istediğiniz durumlar. Spline interpolasyon, veriler arasında daha karmaşık ve eğri bir ilişki olduğu durumları ele alabilir.\n\n# spline interpolation\n# eksik değerler spline interpolasyon yöntemiyle doldurulur.\nsapply(data, function(x) ifelse(is.na(x), na.spline(x), x ))\n\n      ID      Age   Income    Score\n [1,]  1 25.00000 50000.00 80.00000\n [2,]  2 30.00000 60000.00 85.00000\n [3,]  3 23.21344 75000.00 90.00000\n [4,]  4 22.00000 76900.97 78.00000\n [5,]  5 35.00000 80000.00 78.50000\n [6,]  6 40.00000 90000.00 88.00000\n [7,]  7 35.43173 70000.00 92.00000\n [8,]  8 28.00000 60112.53 85.00000\n [9,]  9 24.58413 65000.00 80.00000\n[10,] 10 32.00000 75000.00 90.91549\n\n\nBu fonksiyonlar, özellikle zamana bağlı değişen veri setlerinde eksik değerleri doldurmak için kullanılır. Ancak, kullanmadan önce dikkat edilmesi gereken önemli bir nokta, interpolasyonun verilerdeki gerçek ilişkileri ne kadar doğru yansıttığıdır. Doğru bir doldurma stratejisi seçilirken, eksik değerlerin neden kaynaklandığını ve veri setinin özelliklerini anlamak önemlidir.\n\n\nEn Yakın Komşu Yöntemi (KNN) ile Değer Atama\nEn yakın komşu yöntemi (K-Nearest Neighbors, KNN) eksik değerleri doldurmak için kullanılan bir yöntemdir. Temel fikir, bir gözlemin sınıfını veya değerini belirlemek için, o gözleme en yakın komşularının etkisini kullanmaktır. Bu yöntem, eksik değeri olan bir gözlemi, benzer diğer gözlemlerin değerleriyle doldurmayı amaçlar. KNN, benzerlik ya da uzaklık ölçüsüne dayalı olarak en yakın k komşuyu belirleyerek eksik değeri doldurur. Uzaklık ise bu yakınlığın ölçüsünü ifade eder. Uzaklık metrikleri, gözlemler veya özellik vektörleri arasındaki benzerlik veya farklılık düzeyini belirlemek için kullanılır.\nKNN’de yaygın olarak kullanılan uzaklık metrikleri şunlardır:\n\nEuclidean Distance (Öklidyen Uzaklık): İki nokta arasındaki doğrusal mesafeyi ölçer. 2-boyutlu uzayda, iki nokta \\((x_1,y_1)\\) ve \\((x_2,y_2)\\) arasındaki öklidyen uzaklık formülü şu şekildedir:\n\\[\nUzaklık=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\n\\]\nBu formül genelleştirilebilir ve çok boyutlu uzaylarda kullanılabilir.\nManhattan Distance (Manhattan Uzaklığı veya L1 Uzaklığı): İki nokta arasındaki “şehir blokları” tarzında mesafeyi ölçer. Özellik vektörlerindeki farklar toplanır. 2-boyutlu uzayda, iki nokta \\((x_1,y_1)\\) ve \\((x_2,y_2)\\) arasındaki Manhattan uzaklık formülü şu şekildedir:\n\\[\nUzaklık=|x_2-x_1|+|y_2-y_1|\n\\]\nChebyshev Distance (Chebyshev Uzaklığı veya L∞ Uzaklığı): İki nokta arasındaki maksimum farkı ölçer. Özellik vektörlerindeki farkların mutlak değerlerinden en büyüğünü seçer.\nMinkowski Distance: Minkowski uzaklığı, öklidyen, Manhattan ve Chebyshev uzaklıklarını içeren genel bir formülü ifade eder. Bu formül şu şekildedir:\n\\[\nUzaklık=(\\sum_{i=1}^n |x_{i2}-x_{i1}|^p)^{1/p}\n\\]\nBurada \\(p\\) parametresi, uzaklık ölçüsünün tipini belirler. \\(p=2\\) öklidyen uzaklığı, \\(p=1\\) Manhattan uzaklığı, \\(p=\\infty\\) Chebyshev uzaklığını temsil eder.\n\nUzaklık, KNN algoritmasında önemlidir çünkü bu algoritma komşuluk temeline dayalı çalışır. Bir gözlemin sınıfını veya değerini belirlerken, o gözleme en yakın komşularının etkisini alır. Bu nedenle, doğru uzaklık metrikinin seçimi, modelin performansını etkiler. Veri setinin özelliklerine, dağılımına ve problemin niteliğine bağlı olarak en uygun uzaklık metriğinin seçilmesi önemlidir.\nR ile örnek bir uygulama yapmak için DMwR2 paketini kullanabiliriz. DMwR2 paketi, “Data Mining with R: Learning with Case Studies” kitabının örnekleri üzerine dayanarak, eksik verilerle başa çıkmak için kullanılan bir pakettir. Bu paket, özellikle eksik değerleri tahmin etmek ve doldurmak amacıyla bazı yöntemleri içermektedir.\nAşağıda, DMwR2 paketi kullanılarak K-Nearest Neighbors (KNN) algoritması ile eksik değer doldurma işlemi için bir örnek bulunmaktadır. Bu örnekte, DMwR2 paketi ile knnImputation fonksiyonu kullanılarak bir veri setindeki eksik değerler doldurulmuştur.\n\nlibrary(DMwR2)\n\nWarning: package 'DMwR2' was built under R version 4.2.3\n\n# KNN ile eksik değerleri doldur\n# k parametresi, verilen bir noktaya en yakın komşuların sayısıdır. \n# Bu örnekte uzaklığa (öklit) göre en yakın 3 komşu belirlenir\n# Dah sonra mesafenin ağırlıklı ortalaması hesaplanır.\n# Ağırlıklandırma, her komşuya 1 / d ağırlığının verilmesini içerir.\n# d komşuya olan uzaklıktır.\ndata_imputed &lt;- knnImputation(data, k = 3)\n\n# Sonucu göster\nprint(data_imputed)\n\n   ID      Age   Income    Score\n1   1 25.00000 50000.00 80.00000\n2   2 30.00000 60000.00 85.00000\n3   3 33.74673 75000.00 90.00000\n4   4 22.00000 55135.54 78.00000\n5   5 35.00000 80000.00 86.50176\n6   6 40.00000 90000.00 88.00000\n7   7 34.97289 70000.00 92.00000\n8   8 28.00000 68186.84 85.00000\n9   9 31.87227 65000.00 80.00000\n10 10 32.00000 75000.00 86.13467\n\n\nBu örnekte, knnImputation fonksiyonu, K-Nearest Neighbors algoritmasını kullanarak eksik değerleri doldurur. k parametresi, her bir eksik değeri doldurmak için kullanılacak olan komşu sayısını belirler. Bu örnekte k = 3 olarak seçildi.\nBu örnekte, KNN algoritması kullanılarak eksik değerlerin doldurulduğu bir senaryoyu görmüş olduk. Ancak, KNN’nin avantajlarına rağmen, kullanılan algoritmanın ve komşuluk sayısının seçimi, problem bağlamına bağlı olarak değişebilir. Eksik değer doldurma stratejilerini seçerken, veri setinin yapısı, eksik değerlerin neden kaynaklandığı ve analizin amacı göz önüne alınmalıdır.\n\n\n\n\n\n\nTavsiye\n\n\n\nEksik verilerin analiz edilmesi ve imputasyon konusunda R içerisinde çeşitli kütühaneler bulunmaktadır. Bunlardan en çok bilinenleri mice, VIM, missForest, imputation, mi, Amelia ve Hmisc paketleridir."
  },
  {
    "objectID": "data_preprocess.html#aykırı-değer-analizi",
    "href": "data_preprocess.html#aykırı-değer-analizi",
    "title": "Veri Ön İşleme",
    "section": "Aykırı Değer Analizi",
    "text": "Aykırı Değer Analizi\nAykırı değer, diğer gözlemlerden uzak olan, yani diğer veri noktalarından önemli ölçüde farklı olan bir veri noktası olan bir değer veya gözlemdir. Bu dokümanda, tanımlayıcı istatistikler (minimum, maksimum, histogram, kutu grafiği ve yüzdelikler dahil) gibi basit teknikler ve Z-Skoru ile aykırı değer analizi anlatılacaktır.\n\nMinumum ve Maximum\n\nlibrary(ggplot2)\n\n# mpg verisindeki hwy değişkeni üzerinden inceleyelim\nsummary(mpg$hwy)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  12.00   18.00   24.00   23.44   27.00   44.00 \n\nmin(mpg$hwy)\n\n[1] 12\n\nmax(mpg$hwy)\n\n[1] 44\n\n\n\n\nHistogram\n\n# grafiğin sağ tarafında kalan gözlemler şüpheli görünüyor.\nggplot(mpg) +\n  aes(x = hwy) +\n  geom_histogram(bins = 20, fill = \"blue\") +\n  theme_minimal()\n\n\n\n\n\n\nBoxplot\nBoxplot, beş konum ölçüsü kullanarak verilerin grafiksel bir sunumunu verir: en küçük değer (min), birinci çeyreklik (\\(Q_1\\)) , medyan, üçüncü çeyreklik (\\(Q_3\\)) en büyük değer. Kutunun farklı bölümleri arasındaki boşluk, verilerdeki dağılım (yayılma) ve çarpıklık derecesini gösterir. Bir boxplot grafiği, çeyrekler arası aralık (IQR) kriteri kullanılarak şüpheli bir aykırı değer olarak sınıflandırılan herhangi bir gözlemi görüntüleyerek nicel bir değişkeni görselleştirmeye yardımcı olur.\n\\(I = [Q_1-1.5 * IQR ; Q_3 + 1.5 * IQR]\\)\n\n\n\n\n\nIQR ise üçüncü ve birinci çeyrek arasındaki farktır. R içerisindeki IQR() fonksiyonu bu amaçla kullanılabilir.\n\n# temel istatistiklere erişim\nsummary(mpg$hwy)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  12.00   18.00   24.00   23.44   27.00   44.00 \n\nfivenum(mpg$hwy)\n\n[1] 12 18 24 27 44\n\nggplot(mpg) +\n  aes(x = \"\", y = hwy) +\n  geom_boxplot(fill = \"blue\") +\n  theme_minimal()\n\n\n\n# outlier değerlerine erişim\nboxplot.stats(mpg$hwy)$out\n\n[1] 44 44 41\n\n# outier olarak görülen değerlerin konumları\nhwy_out &lt;- boxplot.stats(mpg$hwy)$out\nhwy_out_sira &lt;- which(mpg$hwy %in% c(hwy_out))\nhwy_out_sira\n\n[1] 213 222 223\n\n# outlier olarak görülen satırlar\nmpg[hwy_out_sira, ]\n\n# A tibble: 3 × 11\n  manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n  &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n1 volkswagen   jetta        1.9  1999     4 manua… f        33    44 d     comp…\n2 volkswagen   new beetle   1.9  1999     4 manua… f        35    44 d     subc…\n3 volkswagen   new beetle   1.9  1999     4 auto(… f        29    41 d     subc…\n\n\n\n\nYüzdelikler (Percentiles)\nBu aykırı değer tespiti yöntemi, yüzdelik dilimlere dayalıdır. Yüzdelikler yöntemiyle, 2,5 ve 97,5 yüzdelik dilimlerin oluşturduğu aralığın dışında kalan tüm gözlemler potansiyel aykırı değerler olarak kabul edilecektir. Aralığı oluşturmak için 1 ve 99 veya 5 ve 95 yüzdelikler gibi diğer yüzdelikler de düşünülebilir.\n\nalt_sinir &lt;- quantile(mpg$hwy, 0.025)\nalt_sinir\n\n2.5% \n  14 \n\nust_sinir &lt;- quantile(mpg$hwy, 0.975)\nust_sinir\n\n 97.5% \n35.175 \n\n# Bu yönteme göre, 14'ün altındaki ve 35.175'in üzerindeki tüm gözlemler,\n# potansiyel aykırı değerler olarak kabul edilecektir.\n\noutlier_sira &lt;- which(mpg$hwy &lt; alt_sinir | mpg$hwy &gt; ust_sinir)\noutlier_sira\n\n [1]  55  60  66  70 106 107 127 197 213 222 223\n\n# Bu yönteme göre 11 adet outlier bulunmuştur.\nmpg[outlier_sira,]\n\n# A tibble: 11 × 11\n   manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n 1 dodge        dakota pi…   4.7  2008     8 auto… 4         9    12 e     pick…\n 2 dodge        durango 4…   4.7  2008     8 auto… 4         9    12 e     suv  \n 3 dodge        ram 1500 …   4.7  2008     8 auto… 4         9    12 e     pick…\n 4 dodge        ram 1500 …   4.7  2008     8 manu… 4         9    12 e     pick…\n 5 honda        civic        1.8  2008     4 auto… f        25    36 r     subc…\n 6 honda        civic        1.8  2008     4 auto… f        24    36 c     subc…\n 7 jeep         grand che…   4.7  2008     8 auto… 4         9    12 e     suv  \n 8 toyota       corolla      1.8  2008     4 manu… f        28    37 r     comp…\n 9 volkswagen   jetta        1.9  1999     4 manu… f        33    44 d     comp…\n10 volkswagen   new beetle   1.9  1999     4 manu… f        35    44 d     subc…\n11 volkswagen   new beetle   1.9  1999     4 auto… f        29    41 d     subc…\n\n# Sınırları biraz daha küçültelim\nalt_sinir &lt;- quantile(mpg$hwy, 0.01)\nust_sinir &lt;- quantile(mpg$hwy, 0.99)\n\noutlier_sira &lt;- which(mpg$hwy &lt; alt_sinir | mpg$hwy &gt; ust_sinir)\n\nmpg[outlier_sira, ]\n\n# A tibble: 3 × 11\n  manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n  &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n1 volkswagen   jetta        1.9  1999     4 manua… f        33    44 d     comp…\n2 volkswagen   new beetle   1.9  1999     4 manua… f        35    44 d     subc…\n3 volkswagen   new beetle   1.9  1999     4 auto(… f        29    41 d     subc…\n\n# Buna göre IQR ile elde edildiği gibi 3 adet outlier bulundu.\n\n\n\nZ-Skor Yöntemi\nAykırı değerlerin tespitinde ortalama ve standart sapmanın kulllanıldığı en bilinen yöntemlerdendir ve aşağıdaki şekilde hesaplanır.\n\\[\nZ_i = \\frac{(X_1-\\mu)}{\\sigma}\n\\]\n\n\n\n\n\n\nstd_z &lt;- function(x){\n  \n  z=(x-mean(x))/sd(x)\n  return(z)\n}\n\nmpg$hwy_std &lt;- std_z(mpg$hwy)\nmpg[,c(\"hwy\",\"hwy_std\")]\n\n# A tibble: 234 × 2\n     hwy hwy_std\n   &lt;int&gt;   &lt;dbl&gt;\n 1    29   0.934\n 2    29   0.934\n 3    31   1.27 \n 4    30   1.10 \n 5    26   0.430\n 6    26   0.430\n 7    27   0.598\n 8    26   0.430\n 9    25   0.262\n10    28   0.766\n# ℹ 224 more rows\n\n# -3 ve +3 sapma dışında kalanları aykırı değer olarak kabul ediyoruz.\noutliers_zskor &lt;- which(mpg$hwy_std &lt; -3 | mpg$hwy_std &gt; +3)\noutliers_zskor\n\n[1] 213 222\n\nmpg[outliers_zskor,c() ]\n\n# A tibble: 2 × 0\n\n# bu yönteme göre 2 adet aykırı değer bulunmuştur."
  },
  {
    "objectID": "data_preprocess.html#veri-normalleştirme",
    "href": "data_preprocess.html#veri-normalleştirme",
    "title": "Veri Ön İşleme",
    "section": "Veri Normalleştirme",
    "text": "Veri Normalleştirme\nDeğişkenler farklı ölçeklerde ölçüldüğünde, genellikle analize eşit katkıda bulunmazlar. Örneğin, bir değişkenin değerleri 0 ile 100.000 arasında ve başka bir değişkenin değerleri 0 ile 100 arasında değişiyorsa, daha büyük aralığa sahip değişkene analizde daha büyük bir ağırlık verilecektir. Değişkenleri normalleştirerek, her bir değişkenin analize eşit katkı sağladığından emin olabiliriz. Değişkenleri normalleştirmek için (veya ölçeklendirmek) genellikle min-max ya da z dönüşümü yöntemleri kullanılır.\n\n# min-max dönüşümleri\n\n# 0 ile 1 arasi dönüşüm\nstd_0_1 &lt;- function(x) {\n  (x - min(x)) / (max(x) - min(x))\n}\n\n#-1 ile +1 arası dönüşüm \nstd_1_1 &lt;- function(x) {\n  ((x - mean(x)) / max(abs(x - mean(x))))\n}\n\n# a ile b arası dönüşüm \nstd_min_max &lt;- function(x,a,b) {\n  # a min değer\n  # b max değer\n  (a + ((x - min(x)) * (b - a)) / (max(x) - min(x)))\n}\n\n# dat isimli yeni bir tablo üretelim\nset.seed(12345)\ndat &lt;- data.frame(x = rnorm(20, 10, 3),\n                  y = rnorm(20, 30, 8),\n                  z = rnorm(20, 25, 5))\ndat\n\n           x        y        z\n1  11.756586 36.23698 30.64255\n2  12.128398 41.64628 13.09821\n3   9.672090 24.84537 19.69867\n4   8.639508 17.57490 29.68570\n5  11.817662 17.21832 29.27226\n6   4.546132 44.44078 32.30365\n7  11.890296 26.14682 17.93451\n8   9.171448 34.96304 27.83702\n9   9.147521 34.89699 27.91594\n10  7.242034 28.70151 18.46601\n11  9.651257 36.49499 22.29807\n12 15.451936 47.57467 34.73846\n13 11.111884 46.39352 25.26795\n14 11.560649 43.05957 26.75831\n15  7.748404 32.03417 21.64512\n16 12.450700 33.92951 26.38977\n17  7.340927 27.40731 28.45586\n18  9.005267 16.70360 29.11898\n19 13.362138 44.14187 35.72533\n20 10.896171 30.20641 13.26528\n\nsummary(dat)\n\n       x                y               z        \n Min.   : 4.546   Min.   :16.70   Min.   :13.10  \n 1st Qu.: 8.914   1st Qu.:27.09   1st Qu.:21.16  \n Median :10.284   Median :34.41   Median :27.30  \n Mean   :10.230   Mean   :33.23   Mean   :25.53  \n 3rd Qu.:11.836   3rd Qu.:42.00   3rd Qu.:29.38  \n Max.   :15.452   Max.   :47.57   Max.   :35.73  \n\napply(dat, 2, std_0_1)\n\n              x          y           z\n [1,] 0.6611575 0.63274053 0.775368144\n [2,] 0.6952505 0.80796300 0.000000000\n [3,] 0.4700211 0.26373477 0.291705877\n [4,] 0.3753393 0.02822392 0.733080320\n [5,] 0.6667578 0.01667340 0.714808256\n [6,] 0.0000000 0.89848463 0.848779748\n [7,] 0.6734179 0.30589231 0.213738973\n [8,] 0.4241150 0.59147416 0.651378062\n [9,] 0.4219211 0.58933460 0.654866001\n[10,] 0.2471988 0.38864587 0.237228478\n[11,] 0.4681108 0.64109819 0.406585628\n[12,] 1.0000000 1.00000000 0.956385878\n[13,] 0.6020419 0.96173940 0.537838847\n[14,] 0.6431912 0.85374322 0.603705080\n[15,] 0.2936301 0.49659993 0.377728555\n[16,] 0.7248037 0.55799517 0.587417289\n[17,] 0.2562668 0.34672297 0.678727553\n[18,] 0.4088772 0.00000000 0.708033996\n[19,] 0.8083774 0.88880212 1.000000000\n[20,] 0.5822623 0.43739366 0.007383637\n\nlibrary(dplyr)\n\ndat %&gt;% mutate_all(std_0_1) %&gt;% summary()\n\n       x                y                z         \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.4005   1st Qu.:0.3365   1st Qu.:0.3562  \n Median :0.5261   Median :0.5737   Median :0.6275  \n Mean   :0.5211   Mean   :0.5354   Mean   :0.5492  \n 3rd Qu.:0.6684   3rd Qu.:0.8194   3rd Qu.:0.7194  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n\ndat %&gt;% mutate_all(std_1_1) %&gt;% summary()\n\n       x                   y                  z          \n Min.   :-1.000000   Min.   :-1.00000   Min.   :-1.0000  \n 1st Qu.:-0.231502   1st Qu.:-0.37143   1st Qu.:-0.3514  \n Median : 0.009603   Median : 0.07154   Median : 0.1426  \n Mean   : 0.000000   Mean   : 0.00000   Mean   : 0.0000  \n 3rd Qu.: 0.282624   3rd Qu.: 0.53057   3rd Qu.: 0.3098  \n Max.   : 0.918881   Max.   : 0.86789   Max.   : 0.8207  \n\ndat %&gt;% mutate_all(std_min_max, a = -2, b = 2) %&gt;% summary()\n\n       x                  y                 z          \n Min.   :-2.00000   Min.   :-2.0000   Min.   :-2.0000  \n 1st Qu.:-0.39803   1st Qu.:-0.6539   1st Qu.:-0.5751  \n Median : 0.10457   Median : 0.2947   Median : 0.5102  \n Mean   : 0.08455   Mean   : 0.1415   Mean   : 0.1970  \n 3rd Qu.: 0.67369   3rd Qu.: 1.2776   3rd Qu.: 0.8775  \n Max.   : 2.00000   Max.   : 2.0000   Max.   : 2.0000  \n\ndat %&gt;% mutate_all(std_z) %&gt;% summary()\n\n       x                  y                 z          \n Min.   :-2.27173   Min.   :-1.7088   Min.   :-1.9165  \n 1st Qu.:-0.52591   1st Qu.:-0.6347   1st Qu.:-0.6735  \n Median : 0.02182   Median : 0.1223   Median : 0.2732  \n Mean   : 0.00000   Mean   : 0.0000   Mean   : 0.0000  \n 3rd Qu.: 0.64204   3rd Qu.: 0.9067   3rd Qu.: 0.5937  \n Max.   : 2.08745   Max.   : 1.4831   Max.   : 1.5729  \n\n# Yapılan dönüşümler verinin dağılımını değiştirmemektedir.\npar(mfrow=c(2,1))\nhist(dat$x,main=\"original data\",col=\"blue\")\nhist(std_0_1(dat$x),main=\"normalize data\",col=\"red\")"
  },
  {
    "objectID": "statistics.html",
    "href": "statistics.html",
    "title": "R ile Temel İstatistik",
    "section": "",
    "text": "Merkezi Eğilim Ölçüleri\nDağılımın konumu hakkında bilgi veren ölçümlerdir. Aritmetik ortalama, geometrik ortalama, harmonik ortalama, düzeltilmiş ortalama, ortanca, çeyrekler, yüzdelikler konum ölçülerine örnek olarak verilebilir.",
    "crumbs": [
      "R ile Temel İstatistik"
    ]
  },
  {
    "objectID": "statistics.html#merkezi-eğilim-ölçüleri",
    "href": "statistics.html#merkezi-eğilim-ölçüleri",
    "title": "R ile Temel İstatistik",
    "section": "",
    "text": "Aritmetik Ortalama\n\nGünlük hayatta en sık kullanılan merkezi eğilim ölçüsüdür.\nÜzerinde inceleme yapılan veri setindeki elemanların toplanıp incelenen eleman sayısına bölünmesiyle elde edilir.\nKonum olarak verilerin en çok hangi değer etrafında toplandığının ya da yoğunlaştığının sayısal bir ölçüsüdür.\nHem kitle hem de örneklem için hesaplanır.\nDağılışların yerinin belirlenmesinde en çok kullanılan yer ölçüsü aritmetik ortalamadır; ve tek başına ortalama sözcüğünden aritmetik ortalama anlaşılır.\nAritmetik ortalama bütün değerlerin ağırlığını eşit kabul ettiğinden dağılımı her zaman en iyi şekilde temsil etmeyebilir. Ayrıca aritmetik ortalama, veri kümesindeki aşırı değerlerden çok kolay etkilenir.\n\n\\[ \\mu = \\frac{1}{N}\\sum_{i=1}^NX_i \\]\n\nmean(airquality$Wind)\n\n[1] 9.957516\n\nmean(airquality$Ozone, na.rm = TRUE) # NA'ler kaldırılarak ortalama hesaplanır\n\n[1] 42.12931\n\n\n\n\nGeometrik Ortalama\n\nPeriyodik artışlar veya azalmalar (değişim oranları) içeren enflasyon veya nüfus değişiklikleri gibi konuları incelerken, geometrik ortalama, incelenen tüm dönem boyunca ortalama değişikliği bulmak için daha uygundur.\nEğer veriler sıfır ya da negatif değerler içeriyorsa geometrik ortalama hesaplanamaz.\nGeometrik ortalama, uç değerlerden aritmetik ortalamaya göre daha az etkilenmektedir.\nGeometrik Ortalama &lt;= Aritmetik Ortalama\n\n\\[ G.O. = ^n\\sqrt{\\prod_{i=1}^{n}X_i} \\]\n\n# R programında hazır geometrik ortalama fonksiyonu yoktur.\n# 1. yol\ngeo_mean &lt;- function(x){\n  x &lt;- na.omit(x)\n  (prod(x))^(1/length(x))\n}\n\nround(geo_mean(airquality$Wind),3)\n\n[1] 9.273\n\nround(geo_mean(airquality$Ozone),3)\n\n[1] 30.524\n\n# 2. yol\nlibrary(psych)\nround(geometric.mean(airquality$Wind),3)\n\n[1] 9.273\n\nround(geometric.mean(airquality$Ozone),3)\n\n[1] 30.524\n\n\n\n\nMedyan (Ortanca)\n\nGözlem değerleri küçükten büyüğe sıralandığında ortada kalan gözlem değeridir.\nBir seride yer alan gözlemlerin tümünün hesaba katılmadığı ortalamalardan biridir.\nBasit serilerde seri tek sayıda gözlemden oluşuyorsa serinin gözlem değerleri küçükten büyüğe sıralandığında tam ortada yer alan gözlem değeridir.\nSeri çift sayıda gözlemden oluşuyorsa ortada kalan iki gözlem değerinin aritmetik ortalaması medyandır.\nMedyan, ölçümlerin %50’sinin üzerinde, %50’sinin aşağısında yer aldığı merkezi değerdir.\nDağılımdaki aşırı değerlerden etkilenmez.\nAritmetik ortalamaya kıyasla daha tutarlı bir sonuç elde edilir.\nHer bir veri seti için bir tek medyan söz konusudur.\nMedyanın zayıf tarafı serideki bütün değerleri dikkate almaması sebebi ile matematik işlemlere elverişli değildir.\nGözlem sayısı (n) tek ise , \\(\\widetilde{X} = X_{\\frac{n+1}{2}}\\)\nGözlem sayısı (n) çift ise , \\(\\widetilde{X} = \\frac{X_\\frac{n}{2}+X_{\\frac{n+1}{2}}}{2}\\)\n\n\nmedian(airquality$Wind)\n\n[1] 9.7\n\nmedian(airquality$Ozone,na.rm = TRUE)\n\n[1] 31.5\n\n\n\n\nMod (Tepe değeri)\n\nEn sık ortaya çıkan (en yüksek frekanslı) ölçümdür.\nDağılımdaki aşırı değerlerden etkilenmez\nHer dağılımda tepe değeri bulunmayabilir.\nBazı dağılımlarda birden fazla tepe değeri bulunabilir.\nTepe değeri aritmetik işlemler için elverişli değildir.\nTüm veri değerlerini göz önünde bulundurmadığı için tutarlı olmayan bir merkezi eğilim ölçüsüdür.\nGözlem sayısı az olduğunda tepe değer güvenilir bir ölçü değildir.\n\n\n\n\n\n\n\n# R programında hazır mod fonksiyonu yoktur.\n\nlibrary(DescTools)\nMode(airquality$Wind)\n\n[1] 11.5\nattr(,\"freq\")\n[1] 15\n\nMode(airquality$Solar.R,na.rm = TRUE)\n\n[1] 238 259\nattr(,\"freq\")\n[1] 4\n\n\n\n\nÇeyreklikler\n\nBirinci Bölen ilk yüzde 25 nci noktadır ve verinin ¼ kadarı birinci bölen içerisinde kalır.\nİkinci Bölen ilk yüzde 50 nci noktadır ve verinin yarısı bu noktanın altında kalır( ½) aynı zamanda ikinci bölen medyan olarak ta bilinir.\nÜçüncü Bölen ilk yüzde 75 nci veri kümesidir ve bütün verinin ¾ kadarı bu noktanın altında kalır.\nGözlem sayısı (n) tek ise , \\(Q_1 = X_{\\frac{n+1}{4}}\\)\nGözlem sayısı (n) çift ise , \\(Q_1 = \\frac{X_\\frac{n}{4}+X_{\\frac{n}{4}+1}}{2}\\)\nGözlem sayısı (n) tek ise , \\(Q_3 = X_{\\frac{3(n+1)}{4}}\\)\nGözlem sayısı (n) çift ise , \\(Q_3 = \\frac{X_\\frac{3n}{4}+X_{\\frac{3n}{4}+1}}{2}\\)\n\n\n\n\n\n\n\nquantile(airquality$Wind,na.rm = TRUE)\n\n  0%  25%  50%  75% 100% \n 1.7  7.4  9.7 11.5 20.7 \n\nmedian(airquality$Wind,na.rm = TRUE)\n\n[1] 9.7\n\nquantile(airquality$Wind,na.rm = TRUE,probs = 0.75) #Q3\n\n 75% \n11.5 \n\nquantile(airquality$Wind,na.rm = TRUE,probs = 0.25) #Q1\n\n25% \n7.4 \n\nquantile(airquality$Wind,na.rm = TRUE,probs = c(0.20,0.50,0.80)) # %20,%50,%80\n\n  20%   50%   80% \n 6.90  9.70 12.96 \n\nquantile(airquality$Solar.R,na.rm = TRUE)\n\n    0%    25%    50%    75%   100% \n  7.00 115.75 205.00 258.75 334.00 \n\nmedian(airquality$Solar.R,na.rm = TRUE)\n\n[1] 205",
    "crumbs": [
      "R ile Temel İstatistik"
    ]
  },
  {
    "objectID": "statistics.html#dağılım-ölçüleri",
    "href": "statistics.html#dağılım-ölçüleri",
    "title": "R ile Temel İstatistik",
    "section": "Dağılım Ölçüleri",
    "text": "Dağılım Ölçüleri\nOrtalama, medyan ve mod gibi merkezi eğilim ölçüleri, bir veri setinin dağılımının bütün resmini ortaya koymaz. Aynı ortalamaya sahip iki veri seti tamamen farklı yayılımlara sahip olabilir. Bir veri seti için gözlem değerleri arasındaki farklılık, diğer veri seti için olduğundan çok daha büyük veya daha küçük olabilir. Bu nedenle, ortalama, medyan veya mod tek başına genellikle bir veri kümesinin dağılımının şeklini ortaya çıkarmak için yeterli bir ölçü değildir. Bu yüzden veri değerleri arasındaki varyasyon hakkında bazı bilgiler sağlayabilecek bir ölçülere de ihtiyaç vardır. Bu ölçülere dağılım (yayılım) ölçüleri denir. Birlikte ele alınan merkezi eğilim ve dağılım ölçüleri, tek başına merkezi eğilim ölçülerinden ziyade bir veri setinin daha iyi bir resmini verir. Değişim aralığı, çeyrekler arası genişlik, varyans, standart sapma, basıklık, çarpıklık, min, max başlıca dağılım ölçüleri arasındadır.\n\nDeğişim Aralığı (Açıklık)\n\nVeri setindeki en büyük değer ile en küçük değer arasındaki farktır.\nEn basit dağılım ölçüsü olmakla birlikte uç ve aykırı değerlerden etkilenmesi olumsuz yönüdür.\nSerinin sadece 2 gözlemine bağlı olarak hesaplanan bu ölçü değişkenliğin şekli hakkında çok fazla bilgi vermediğinden diğer değişkenlik ölçüleri kadar sık kullanılmaz.\n\n\\[D.A = max(X)-min(X)\\]\n\n# 1. yol\nmax(airquality$Ozone,na.rm = TRUE)-min(airquality$Ozone,na.rm = TRUE)\n\n[1] 167\n\n# 2. yol\nrange(airquality$Ozone,na.rm = TRUE)\n\n[1]   1 168\n\nrange(airquality$Ozone,na.rm = TRUE)[2]-range(airquality$Ozone,na.rm = TRUE)[1]\n\n[1] 167\n\n\n\n\nÇeyrekler Arası Genişlik\n\nDağılımdaki verilerin ortadaki % 50’sinin yer aldığı aralığı belirlemek için kullanılır.\nAşırı uç değerlerden etkilenmez. Çünkü çeyreklikler arası genişlik dağılımdaki değerlerin merkezdeki %50’si ile ilgilenir.\nÇeyrekler arası bir genişlik, değerlerin büyük kısmının nerede olduğunu gösteren bir ölçüdür.\nÇeyrek Sapma 3. çeyrek ile 1. çeyrek arasındaki farktır.\nIQR (Interquartile Range) olarak ifade edilir.\n\n\\[IQR=Q_3-Q1\\]\n\n# 1.yol\nq3 &lt;- quantile(airquality$Wind,na.rm = TRUE,probs = 0.75) #Q3\nq1 &lt;- quantile(airquality$Wind,na.rm = TRUE,probs = 0.25) #Q1\nq3-q1\n\n75% \n4.1 \n\n# 2. yol\nIQR(airquality$Wind,na.rm = TRUE)\n\n[1] 4.1\n\n\n\n\nVaryans ve Standart Sapma\nGözlem değerlerinin aritmetik ortalamadan sapmaları dikkate alınarak farklı değişkenlik ölçüleri geliştirilebilir. Ancak gözlemlerin aritmetik ortalamadan sapmalarının her zaman sıfıra eşittir. Bu sorunu ortadan kaldırmak için gözlemlerin aritmetik ortalamadan olan sapmalarının karelerinin toplamının gözlem sayısına oranı değişkenlik ölçüsü olarak yorumlanabilir. Bu ölçü varyans olarak adlandırılır.\n\nBir dağılımda değerler aritmetik ortalamadan uzaklaştıkça dağılımın yaygınlığı artar.\nVaryansın karekökü standart sapmadır. Genel olarak, bir veri kümesi için standart sapmanın daha düşük bir değeri, o veri kümesinin değerlerinin ortalama etrafında nispeten daha küçük bir aralığa yayıldığını gösterir. Buna karşılık, bir veri kümesi için standart sapmanın daha büyük bir değeri, o veri kümesinin değerlerinin, ortalama etrafında nispeten daha geniş bir aralığa yayıldığını gösterir.\nKitle varyansı \\(\\sigma^2\\) ile standart sapma ise \\(\\sigma\\) ile gösterilmektedir. Örneklem standart sapması ise \\(s\\) ile ifade edilir.\n\n\\[s= \\sqrt{\\sum_{i=1}^N\\frac{(x_i-\\bar{x})^2}{n-1}}\\]\n\nvar(airquality$Wind,na.rm=TRUE)\n\n[1] 12.41154\n\nsd(airquality$Wind,na.rm=TRUE)\n\n[1] 3.523001\n\nvar(airquality$Solar.R,na.rm=TRUE)\n\n[1] 8110.519\n\nsd(airquality$Solar.R,na.rm=TRUE)\n\n[1] 90.05842\n\n\n\n\nDeğişim Katsayısı\n\nFarklı serilerin değişkenliklerinin karşılaştırılmasında, farklı birimlerle ölçülmüş veri setleri söz konusu olduğundan standart sapma kullanışlı değildir.\nBunun yerine ilgili serilerin standart sapmaları serilerin ortalama değerinin yüzdesi olarak ifade edilir ve gözlem değerlerinin büyüklüklerinden kaynaklanan farklılık ortadan kalkmış olur.\nElde edilen bu yeni değişkenlik ölçüsü kullanılarak serilerin birbirlerine göre daha değişken ya da daha homojen oldukları konusunda yorum yapılabilir.\nBu değer ne kadar küçükse dağılım o kadar homojendir, değişkenlik azdır. Yüzdesel olarak ifade edilir.\nDeğişim Katsayısı standart sapmanın aritmetik ortalamaya bölünüp 100 ile çarpılmasıyla elde edilir.\n\n\\[D.K. = \\frac{S}{\\bar{X}}\\times{100}\\]\n\ndk_wind &lt;- sd(airquality$Wind,na.rm=TRUE)/mean(airquality$Wind,na.rm=TRUE)\ndk_wind\n\n[1] 0.3538032\n\ndk_solar &lt;- sd(airquality$Solar.R,na.rm=TRUE)/mean(airquality$Solar.R,na.rm=TRUE)\ndk_solar\n\n[1] 0.4843634\n\n\n\n\nÇarpıklık ve Basıklık\n\nBir dağılımın normal dağılıma göre çarpık olup olmadığını belirlemede kullanılır. Simetrik dağılımlarda ortalama, ortanca ve tepe değeri birbirine eşittir.\nÇarpıklık katsayısı 0 ise dağılım simetriktir, 0’dan küçük ise sola çarpıktır (negatif çarpıklık), 0’dan büyük ise sağa çarpıktır (pozitif çarpıklık).\nPozitif çarpıklıkta sağ kuyruk daha uzun iken negatif çarpıklıkta sol kuyruk daha uzundur.\nAritmetik Ortalama, Medyan ve Mod arasındaki ilişkilere göre de çarpıklık belirlenebilir.\n\nMod &lt; Medyan &lt; Ortalama ise, dağılım sağa-çarpık yani (+) yöne eğilimli dağılımdır.\nOrtalama &lt; Medyan &lt; Mod ise, dağılım sola-çarpık yani (-) yöne eğilimli dağılımdır.\nOrtalama = Mod = Medyan ise, dağılım simetrik dağılımdır.\n\n\n\n\n\n\n\n\nBir dağılımın normal dağılıma göre basık olup olmadığını belirlemede kullanılır.\nBasıklık katsayısı sıfırdan büyükse normal dağılıma göre daha sivri, küçük ise daha basıktır.\nBasıklık katsayısı 3’e eşit ise seri normal dağılıma (mesokurtic) sahiptir. Eğer3’ten küçük ise, bir platykurtik dağılımı gösterir (daha kısa kuyruklu normal dağılımdan daha düz). Eğer 3’ten büyük ise, bir leptokurtik dağılımı gösterir (daha uzun kuyruklu normal dağılımdan daha doruğa).\nİki veya daha fazla simetrik dağılım karşılaştırıldığında aralarındaki fark basıklık ile incelenir.\n\n\n\n\n\n\n\nlibrary(moments)\nskewness(airquality$Ozone,na.rm = TRUE) # sağa çarpık\n\n[1] 1.225681\n\nkurtosis(airquality$Ozone,na.rm = TRUE) # sivri\n\n[1] 4.184071\n\nhist(airquality$Ozone,freq = FALSE)\nlines(density(airquality$Ozone,na.rm = TRUE),col = 2, lwd = 2)\n\n\n\n\n\n\n\nskewness(airquality$Solar.R,na.rm = TRUE) # sola çarpık\n\n[1] -0.4236342\n\nkurtosis(airquality$Solar.R,na.rm = TRUE) # sivri\n\n[1] 2.023567\n\nhist(airquality$Solar.R,freq = FALSE)\nlines(density(airquality$Solar.R,na.rm = TRUE),col = 2, lwd = 2)\n\n\n\n\n\n\n\n# normal dağılımdan veri üretelim\nnorm_vec &lt;- rnorm(1000,10,5)\nskewness(norm_vec) # sola çarpık\n\n[1] -0.106176\n\nkurtosis(norm_vec) # sivri\n\n[1] 3.094882\n\nhist(norm_vec,freq = FALSE,col=\"#116AF3\") # renk kodları da kullanılabilir.\nlines(density(norm_vec),col = \"#F33011\", lwd = 2)",
    "crumbs": [
      "R ile Temel İstatistik"
    ]
  },
  {
    "objectID": "statistics.html#ilişki-ölçüleri",
    "href": "statistics.html#ilişki-ölçüleri",
    "title": "R ile Temel İstatistik",
    "section": "İlişki Ölçüleri",
    "text": "İlişki Ölçüleri\nÖnceki bölümlerde, bir dağılımı tanımlayan ve özet istatistikleri hesaplayan tek bir değişkene odaklanmıştık. Tek bir değişkeni tanımlayan istatistiklere tek değişkenli istatistikler denir. İki değişken arasındaki ilişkiyi incelersek, iki değişkenli istatistiklere atıfta bulunuruz. Birkaç değişken arasındaki ilişkiler aynı anda incelenirse, çok değişkenli istatistiklere atıfta bulunuruz. İlişki ölçüleri, iki değişken arasındaki ilişkinin boyutunu özetlemek için araçlar sağlar.\nİlişkiyi ölçmek için birçok araç türü olmasına rağmen, kovaryans ve Pearson korelasyon katsayıları “sayısal” veri türü için en bilinen ve yaygın araçlardır. Kovaryans ve korelasyon arasındaki temel fark, kovaryans, değerin işaretine (+’ve veya -’ve) bağlı olarak ilişkinin yönünü gösterir. Ancak korelasyon, değişkenler arasındaki “doğrusal” ilişkinin gücünü gösterir.\nKategorik veriler için ki-kare testi kullanılmkatadır. Spearman rho ve Kendall Tau korelasyon katsayıları da vardır ancak bunlar parametrik olmayan testlerdir ve yaygın olarak kullanılmazlar.\nDeğişkenler arasındaki ilişkiyi çizgi veya saçılım grafiği çizerek de incelenebilir. Ancak, bu grafiklere bakarak ilişkiden emin olmak her zaman mümkün olmayabilir. İstatistikte testler her zaman görsel araçlardan daha güçlüdür. Görsel araçlar fikir verir, testler ise fikirleri doğrular.\n\nKovaryans\nKovaryans, iki değişkenin ortak değişkenliğinin bir ölçüsüdür. Kovaryans (−∞,∞) aralığında herhangi bir değer alabilir. Bir değişkenin büyük/küçük değerleri esas olarak diğer değişkenin daha büyük/küçük değerlerine karşılık geliyorsa kovaryans pozitiftir. Değişkenler zıt davranış gösterme eğilimindeyse kovaryans negatiftir. Kovaryans \\(s_{xy}\\) ile gösterilir ve aşağıdaki şekilde hesaplanır.\n\\[{s}_{xy} = \\frac{\\sum_{i=1}^n(x_i - \\bar{x})(y_i - \\bar{y})}{n-1}\\]\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\ncov(iris$Sepal.Length,iris$Petal.Length) # pozitif ilişki var\n\n[1] 1.274315\n\ncov(iris$Sepal.Length,iris$Sepal.Length)\n\n[1] 0.6856935\n\n\n\n\nKorelasyon\nKorelasyon, nicel değişkenler arasındaki ilişkiyi incelemek için yaygın olarak kullanılan bir yöntemdir. Karl Pearson’ın Pearson moment korelasyon katsayısı olarak da bilinen doğrusal korelasyon katsayısı r’dir. Doğrusal korelasyon katsayısı, iki değişken arasındaki doğrusal ilişkinin gücünü ölçer.\n\n\n\n\n\n\nKorelasyon, kovaryansın standartlaştırılmış halidir.\nStandartlaştırmadan kaynaklanan bilgi kaybı vardır.\nStandartlaştırılmış olduğu için korelasyonun birimi yoktur, birimsizdir.\nKorelasyon -1 ve +1 arasında değer alır.\nKorelasyon , ±1’e yakınsa, iki değişken yüksek oranda ilişkilidir ve bir saçılım grafiği üzerinde çizilirse, veri noktaları bir çizgi etrafında kümelenir.\nKorelasyon , ±1’den uzaksa, veri noktaları daha geniş bir alana dağılır.\nKorelasyon 0’a yakınsa, veri noktaları esasen yatay bir çizgi etrafında dağılır ve bu, değişkenler arasında neredeyse hiçbir doğrusal ilişki olmadığını gösterir.\nr=1 ise değişkenler arasında pozitif yönlü tam bir doğrusal ilişki vardır.\nr=-1 ise değişkenler arasında negatif (ters) yönlü tam bir doğrusal ilişki vardır.\nr=0 ise değişkenler arasında doğrusal ilişki yoktur.\nKorelasyon nedensel ilişki değildir.\nKorelasyon değişkenler arasındaki sebep sonuç ilişkilerini açıklamaz.\nKorelasyon matematiksel ilişkidir.\n\n\\[ r=\\frac{\\sum_{i=1}^n(x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^n(x_i-\\bar{x})^2}\\sqrt{\\sum_{i=1}^n(y_i-\\bar{y})^2}} = \\frac{s_{xy}}{s_xs_y} \\]\nİki değişken arasındaki doğrusal ilişkinin miktarı için açık bir sınıflandırma kuralı yoktur. Bununla birlikte, aşağıdaki tablo, Pearson çarpım momenti korelasyon katsayısının sayısal değerlerinin nasıl ele alınacağı konusunda temel bir fikir verebilir.\n\n\n\nKorelasyon Katsayısı (r)\nİlişkinin Derecesi\n\n\n\n\n\\(r &gt; 0.90\\)\nÇok kuvvetli\n\n\n\\(0.70 &lt; r\\le 0.90\\)\nKuvvetli\n\n\n\\(0.50 &lt; r\\le 0.70\\)\nOrta\n\n\n\\(0.30 &lt; r\\le 0.50\\)\nDüşük\n\n\n\\(r &lt; 0.30\\)\nZayıf\n\n\n\n\ncor(iris$Sepal.Length,iris$Petal.Length) # kuvvetli ilişki vardır.\n\n[1] 0.8717538\n\nplot(iris$Sepal.Length,iris$Petal.Length,\n     col=\"blue\",\n     xlab = \"Sepal\",\n     ylab = \"Petal\",\n     main = \"Sepal vs Petal Saçılım Grafiği\")\n\n\n\n\n\n\n\n\n\n\nKontenjans Katsayısı\nKontenjans katsayısı C, kategorik veriler için \\(\\chi 2\\) tabanlı bir ilişki ölçüsüdür. Bağımsızlık için \\(\\chi 2\\) testine dayanır. \\(\\chi 2\\) istatistiği, kontenjans durum tablolarındaki (iki yönlü tablo, çapraz tablo tablosu veya çapraz tablolar olarak da bilinir) değişkenler arasında istatistiksel bir ilişki olup olmadığını değerlendirmeyi sağlar. Bu tür tablolarda değişkenlerin dağılımı matris formatında gösterilir. İki nominal (kategorik) değişken arasında anlamlı bir ilişki olup olmadığını belirlemek için kullanılır.\n\\[ \\chi 2=\\sum\\frac{(G-B)^2}{B} \\]\nBurada G gözlemlenen frekansı ve B ise beklenen frekansı temsil eder . Ki-kare test istatistiği ile iki kategorik değişken arasında ilişki olup olmadığı araştırılır. Hipotez aşağıdaki gibi kurulur:\n\\(H_0:\\) Değişkenler arasında ilişki yoktur.\n\\(H_1:\\) Değişkenler arasında ilişki vardır.\nKontenjans katsayısı ise şu şekilde elde edilir:\n\\[ C=\\sqrt{\\frac{\\chi2}{n+\\chi2}} \\]\nBurada n satır ve sütun toplamlarını ifade eder. C katsayısı 0 ile 1 arasında bir değer alır. C=0 olması iki değişken arasında ilişki olmadığına, C=1 olması ile tam ilişkili olduğu anlamına gelir.\n\n# öğrencilerin sigara içme alışkanlığının egzersiz düzeyi ile ilişkili\n# olup olmadığını inceleyelim.\n\nlibrary(MASS)\nhead(survey)\n\n     Sex Wr.Hnd NW.Hnd W.Hnd    Fold Pulse    Clap Exer Smoke Height      M.I\n1 Female   18.5   18.0 Right  R on L    92    Left Some Never 173.00   Metric\n2   Male   19.5   20.5  Left  R on L   104    Left None Regul 177.80 Imperial\n3   Male   18.0   13.3 Right  L on R    87 Neither None Occas     NA     &lt;NA&gt;\n4   Male   18.8   18.9 Right  R on L    NA Neither None Never 160.00   Metric\n5   Male   20.0   20.0 Right Neither    35   Right Some Never 165.00   Metric\n6 Female   18.0   17.7 Right  L on R    64   Right Some Never 172.72 Imperial\n     Age\n1 18.250\n2 17.583\n3 16.917\n4 20.333\n5 23.667\n6 21.000\n\nnrow(survey)\n\n[1] 237\n\ntbl &lt;-  table(survey$Smoke, survey$Exer) \ntbl\n\n       \n        Freq None Some\n  Heavy    7    1    3\n  Never   87   18   84\n  Occas   12    3    4\n  Regul    9    1    7\n\n# 1.yol\nchisq.test(tbl) \n\nWarning in chisq.test(tbl): Chi-squared approximation may be incorrect\n\n\n\n    Pearson's Chi-squared test\n\ndata:  tbl\nX-squared = 5.4885, df = 6, p-value = 0.4828\n\n# 0.4828 p değeri .05 anlamlılık düzeyinden büyük olduğu için sigara \n# içme alışkanlığının öğrencilerin egzersiz düzeyinden bağımsız olduğu \n# sıfır hipotezini reddedemeyiz.\n\n# 2.yol\nsummary(tbl)\n\nNumber of cases in table: 236 \nNumber of factors: 2 \nTest for independence of all factors:\n    Chisq = 5.489, df = 6, p-value = 0.4828\n    Chi-squared approximation may be incorrect",
    "crumbs": [
      "R ile Temel İstatistik"
    ]
  },
  {
    "objectID": "regresyon.html",
    "href": "regresyon.html",
    "title": "Doğrusal Regresyon",
    "section": "",
    "text": "Basit doğrusal regresyon, iki nicel değişken arasındaki doğrusal ilişkiyi değerlendirmeye izin veren istatistiksel bir yaklaşımdır. Daha doğrusu, ilişkinin nicelleştirilmesini ve öneminin değerlendirilmesini sağlar. Çoklu doğrusal regresyon, bu yaklaşımın bir yanıt değişkeni (nicel) ile birkaç açıklayıcı değişken (nicel veya nitel) arasındaki doğrusal ilişkileri değerlendirmeyi mümkün kılması anlamında, basit doğrusal regresyonun bir genellemesidir.\nGerçek dünyada, çoklu doğrusal regresyon, basit doğrusal regresyondan daha sık kullanılır. Bu çoğunlukla böyledir çünkü, Çoklu doğrusal regresyon, diğer değişkenlerin etkisini kontrol ederken (yani etkiyi ortadan kaldırırken) iki değişken arasındaki ilişkiyi değerlendirmeye izin verir. Veri toplamanın da kolaylaşmasıyla, veriler analiz edilirken daha fazla değişken dahil edilebilir ve dikkate alınabilir.\nBasit doğrusal regresyon, iki değişken arasında doğrusal bir ilişkinin varlığını değerlendirmeye ve bu bağlantıyı nicelleştirmeye izin verir. Doğrusallığın, iki değişkenin doğrusal olarak bağımlı olup olmadığını test etmesi ve ölçmesi anlamında doğrusal regresyonda güçlü bir varsayım olduğuna dikkat etmek gerekmektedir.\nDoğrusal regresyonu güçlü bir istatistiksel araç yapan şey, açıklayıcı/bağımsız değişken bir birim arttığında yanıtın/bağımlı değişkenin hangi nicelikle değiştiğini ölçmeye izin vermesidir. Bu kavram doğrusal regresyonda anahtardır ve aşağıda verilen türde soruları yanıtlamaya yardımcı olur:\n\nReklama harcanan miktar ile belirli bir dönemdeki satışlar arasında bir bağlantı var mı?\nTütün vergilerindeki artış tüketimini azaltır mı?\nBölgeye bağlı olarak bir konutun en olası fiyatı nedir?\nBir kişinin bir uyarana tepki verme süresi cinsiyete bağlı mıdır?\n\nBasit doğrusal regresyon analizinde, bağımlı değişken y ile bağımsız değişken x arasındaki ilişki doğrusal bir denklem şeklinde verilir.\n\\[ y=\\beta_0+\\beta_1x \\]\nBurada, \\(\\beta_0\\) sayısına kesme noktası denir ve regresyon doğrusu ile y ekseninin (x=0) kesişme noktasını tanımlar. \\(\\beta_1\\) sayısına regresyon katsayısı denir. Regresyon doğrusu eğiminin bir ölçüsüdür. Böylece \\(\\beta_1\\), x değeri 1 birim arttığında y değerinin ne kadar değiştiğini gösterir. Model, x ve y arasında kesin bir ilişki verdiği için deterministik bir model olarak kabul edilir.\nAncak birçok durumda, iki değişken x ve y arasındaki ilişki kesin değildir. Bunun nedeni, bağımlı değişken y’nin, tahmin değişkeni x tarafından tam olarak yakalanmayan diğer bilinmeyen ve/veya rastgele süreçlerden etkilenmesidir. Böyle bir durumda veri noktaları düz bir çizgi üzerinde sıralanmaz. Bununla birlikte, veriler hala temeldeki doğrusal bir ilişkiyi takip edebilir. Bu bilinmeyenleri dikkate almak için lineer model denklemine \\(\\varepsilon\\) ile gösterilen rastgele bir hata terimi eklenir, böylece yukarıdaki deterministik modelin aksine olasılıklı bir model elde edilir.\n\\[ y=\\beta_0+\\beta_1x+\\varepsilon \\]\nBurada hata terimi \\(\\varepsilon_i\\)’nin bağımsız normal dağılımlı değerlerden oluştuğu varsayılır, \\(e_i\\)~\\(N(0,\\sigma^2)\\).\nDoğrusal regresyon modeli hakkında aşağıdaki varsayımlar yapılır:\n\nBağımlı değişken tesadüfi bir değişkendir ve normal dağılım göstermektedir.\nTahmin hataları tesadüfidir ve normal dağılım gösterirler.\nHatalar birbirinden bağımsızdır (otokorelasyon yoktur).\nHata varyansı sabittir ve veriler arasında hiç değişmediği varsayılır (eşit varyanslılık-homoscedasticity).\nEğer çoklu regresyon analizi yapılıyorsa, bağımsız değişkenlerin birbirleri ile bağlantısının olmaması gereklidir. Buna çoklu bağlantı (multicollinearity) olmaması varsayımı adı verilir.\nBağımlı değişken ile bağımsız değişkenler arasında doğrusal bir ilişki olmalıdır.\nGözlem sayısı parametre sayısından büyük olmalıdır.\n\n\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# gapminder veri setine bakalım\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   &lt;fct&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\n# kişi başına milli gelir ile yaşam beklentisi değişkenlerini görselleştirelim.\n\nggplot(gapminder, aes(gdpPercap, lifeExp)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(gapminder, aes(gdpPercap, lifeExp)) +\n  geom_point() + \n  geom_smooth(method = \"lm\",se=TRUE)\n\n\n\n\n\n\n\n# regresyon modeli kuralım\n\nmodel1 &lt;- lm(lifeExp ~ gdpPercap, data = gapminder)\nmodel1\n\n\nCall:\nlm(formula = lifeExp ~ gdpPercap, data = gapminder)\n\nCoefficients:\n(Intercept)    gdpPercap  \n  5.396e+01    7.649e-04  \n\n\n\n\n\n\n\n\nYorum\n\n\n\nYani burada söyleyebileceğimiz şey, GSYH’daki her 1 artış için, yaşam beklentisinde 0.0007649 yıllık bir artış görmeyi bekleyebiliriz. Modelimizi daha iyi anlayabilmek için model üzerinde summary() fonksiyonunu kullanabiliriz. Ayrıca artıkların normalliğini de bakmak da fayda var.\n\n\nsummary fonksiyonu ile modelimizin verilere ne kadar iyi uyduğu hakkında biraz daha bilgi alıyoruz. Genel modelimiz ve her değişken için p-değerlerini görebiliriz. \\(R^2\\) değeri, veri kümenizdeki varyansın ne kadarının modeliniz tarafından açıklanabileceğini temel olarak, modelinizin verilere ne kadar iyi uyduğunu gösterir. Bu değer 0 ile 1 arasında değişir ve büyük olması beklenir. Genel olarak, modelinizde kaç değişken kullandığınızı telafi eden düzeltilmiş \\(R^2\\)’yi kullanırız. Aksi halde başka bir değişken eklemek her zaman \\(R^2\\)’yi artırır.\n\nsummary(model1)\n\n\nCall:\nlm(formula = lifeExp ~ gdpPercap, data = gapminder)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-82.754  -7.758   2.176   8.225  18.426 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 5.396e+01  3.150e-01  171.29   &lt;2e-16 ***\ngdpPercap   7.649e-04  2.579e-05   29.66   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 10.49 on 1702 degrees of freedom\nMultiple R-squared:  0.3407,    Adjusted R-squared:  0.3403 \nF-statistic: 879.6 on 1 and 1702 DF,  p-value: &lt; 2.2e-16\n\n\nModele gdp değişkenin logaritmasını alarak ve continent (kıta) ve year (yıl) değişkenlerini de ekleyerek çoklu regresyon analizi sonuçlarına bakalım.\n\nmodel2 &lt;- lm(lifeExp ~ log(gdpPercap) + continent + year, data = gapminder)\nsummary(model2)\n\n\nCall:\nlm(formula = lifeExp ~ log(gdpPercap) + continent + year, data = gapminder)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-25.0433  -3.2175   0.3482   3.6657  15.1321 \n\nCoefficients:\n                    Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       -4.659e+02  1.667e+01  -27.94   &lt;2e-16 ***\nlog(gdpPercap)     5.024e+00  1.595e-01   31.50   &lt;2e-16 ***\ncontinentAmericas  8.926e+00  4.630e-01   19.28   &lt;2e-16 ***\ncontinentAsia      7.063e+00  3.959e-01   17.84   &lt;2e-16 ***\ncontinentEurope    1.251e+01  5.097e-01   24.54   &lt;2e-16 ***\ncontinentOceania   1.275e+01  1.275e+00   10.00   &lt;2e-16 ***\nyear               2.416e-01  8.586e-03   28.14   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.813 on 1697 degrees of freedom\nMultiple R-squared:  0.7982,    Adjusted R-squared:  0.7975 \nF-statistic:  1119 on 6 and 1697 DF,  p-value: &lt; 2.2e-16\n\n\n\n\n\n\n\n\nYorum\n\n\n\nBu sonuçlara göre \\(R^2\\) değeri 0.79’a yükselmiştir. Değişken sayısını artırmak model başarısını artırmış görünüyor. Ayrıca katsayıların hepsinin de anlamlı çıktığı göz ardı edilmemelidir.\nAfrika kıtası haricinde, veri kümemizdeki kıtaların her biri için bir satır var. Bunun sebebi Afrika kıtası referans kıta olarak burada belirlenmesinden kaynaklanmaktadır. Yani kıtalara göre verileri yorumlarken Afirika kıtasına göre değerlendirme yapılacaktır. Örneğin Avrupa’da olmak ortalama olarak, Afrika’da olmaktan 12.51 yıl daha fazla yaşam beklentisine sahip olmak anlamına gelmektedir.\n\n\n\n\n\n\n\n\nTavsiye\n\n\n\nModel sonuçlarının daha güzel ve temiz (tidy) bir formatta görünmesi için broom paketi kullanılabilir.\n\n\n\nlibrary(broom)\n\n# gözlem düzeyinde sonuçlar\naugment(model2)\n\n# A tibble: 1,704 × 10\n   lifeExp `log(gdpPercap)` continent  year .fitted .resid    .hat .sigma\n     &lt;dbl&gt;            &lt;dbl&gt; &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1    28.8             6.66 Asia       1952    46.3  -17.5 0.00470   5.80\n 2    30.3             6.71 Asia       1957    47.8  -17.5 0.00425   5.80\n 3    32.0             6.75 Asia       1962    49.2  -17.2 0.00393   5.80\n 4    34.0             6.73 Asia       1967    50.3  -16.3 0.00380   5.80\n 5    36.1             6.61 Asia       1972    50.9  -14.8 0.00399   5.80\n 6    38.4             6.67 Asia       1977    52.4  -14.0 0.00393   5.81\n 7    39.9             6.89 Asia       1982    54.7  -14.9 0.00367   5.80\n 8    40.8             6.75 Asia       1987    55.2  -14.4 0.00422   5.80\n 9    41.7             6.48 Asia       1992    55.1  -13.4 0.00529   5.81\n10    41.8             6.45 Asia       1997    56.2  -14.4 0.00588   5.80\n# ℹ 1,694 more rows\n# ℹ 2 more variables: .cooksd &lt;dbl&gt;, .std.resid &lt;dbl&gt;\n\n#model düzeyinde sonuçlar\nglance(model2)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic p.value    df logLik    AIC    BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1     0.798         0.797  5.81     1119.       0     6 -5414. 10843. 10887.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;",
    "crumbs": [
      "Doğrusal Regresyon"
    ]
  },
  {
    "objectID": "data_preprocess.html#eksik-veriler",
    "href": "data_preprocess.html#eksik-veriler",
    "title": "Veri Ön İşleme",
    "section": "Eksik Veriler",
    "text": "Eksik Veriler\nEksik veriler, bir veri setinde belirli gözlemlerde veya değişkenlerde eksik veya boş değerler içeren durumlardır. Eksik veriler, ölçüm hatası, veri toplama sürecindeki problemler veya rasgele olaylar nedeniyle ortaya çıkabilir. Sistematik bir kayıp gözlem durumu yoksa ortada ciddi bir sorun yoktur. Ama rastgele olmayan bir hata varsa tüm kitleye dair yanlılık olacağı için bu durum göz ardı edilemez.\nEksik Verilerin Türleri:\n\nRasgele Eksiklik (MCAR - Missing Completely At Random): Eksiklik, gözlemler arasında tamamen rastgele ve bağımsız bir şekilde meydana gelir. Örneğin, bir anket çalışması yapıyorsunuz ve bazı katılımcılar, bilgisayar hatası nedeniyle rastgele seçilmiş sorulara cevap verememişlerdir. Bu durumda, eksiklik rastgele olarak oluştu ve diğer değişkenlerle ilişkili değildir.\nRastgele Eksiklik (MAR - Missing At Random): Eksiklik, diğer değişkenlerin değerlerine bağlı olarak meydana gelir, ancak eksik veri değeri eksik olduğu değişkenle ilgili değildir. Örneğin, bir sağlık çalışması yapılıyor ve bazı katılımcılar, yaşlarına bağlı olarak belirli testlere katılamıyorlar. Bu durumda, eksiklik yaşa bağlıdır, ancak test sonuçlarından bağımsız olarak rastgele olarak meydana gelmiştir.\nSistematik Eksiklik (MNAR - Missing Not At Random): Eksiklik, eksik olan değerlerin değerlere bağlı olarak ortaya çıktığı bir modeli takip eder. Bu durum, eksik verilerin diğer değişkenlerle ilişkili olduğu anlamına gelir. Örneğin, bir maaş anketi yapılıyor ve yüksek maaş alan katılımcılar, maaşlarını ifşa etme konusundaki isteksizlikleri nedeniyle maaş sorularına cevap vermiyorlar. Bu durumda, eksiklik maaş seviyesi ile ilişkilidir ve bu durum MNAR olarak kabul edilir.\n\nEksik veriler için daha fazla örnek aşağıda yer almaktadır:\n\nMevcut Olmayan Bilgi (Not Stated - NS): Bir anketin bir bölümünde “Cinsiyet” sorusu vardır ve bazı katılımcılar bu soruya cevap vermez veya “Belirtmek İstemiyorum” seçeneğini işaretler. Bu durum, cinsiyet bilgisinin eksik olduğu ve bu eksikliğin katılımcıların cinsiyetiyle ilgili olup olmadığını anlamak zordur. Bu durum MCAR veya MAR olarak değerlendirilebilir.\nZamanla Değişen Eksiklik (Time-Dependent Missingness): Bir panel veri setinde her yıl yapılan bir ankette, bazı katılımcılar belirli bir yıl için bazı sorulara cevap vermemiş olabilir. Bu durumda eksiklik, zamanla değişen bir yapıya sahiptir ve belirli bir yıla özgüdür. Bu tür eksiklik zaman serileri analizinde önemli olabilir.\nSeçimli Eksiklik (Selective Missingness): Bir çalışma, belirli bir tedavi grubuna katılan katılımcıların tedaviye yanıtını ölçen bir değişkenle ilgili eksik verilere sahiptir. Tedavi grubuna dahil olan katılımcılar bu değişkeni ölçmeyi reddetmiş olabilir veya ölçüm yapılmamış olabilir. Bu durum, eksiklik belirli bir grupla sınırlıdır ve bu grupla ilgili özelliklere bağlıdır, bu da durumu MNAR yapar.\nSosyal İsteksizlik (Social Desirability Bias): Bir anket, katılımcılara kişisel gelirlerini belirtmelerini istemektedir. Ancak, bazı katılımcılar gelirlerini abartma eğilimindedir çünkü yüksek gelir bildirmek sosyal olarak daha kabul edilebilir bir durum olarak görülmektedir. Bu durumda, eksiklik sosyal etkileşim ve katılımcıların isteğine bağlıdır, bu da durumu MAR veya MNAR yapabilir.\n\nHer bir örnek, eksik verilerin farklı nedenlere dayanabileceğini ve bu nedenlere bağlı olarak başa çıkma stratejilerinin belirlenmesi gerektiğini göstermektedir. Eksik verilerin türlerini anlamak, başa çıkma stratejilerini belirlemede önemlidir çünkü stratejiler eksik verilerin nasıl oluştuğuna bağlı olarak farklılık gösterebilir. MCAR durumu, basit bir ortalama atama stratejisinin kullanılmasını daha kabul edilebilir kılabilirken, MAR ve MNAR durumları daha sofistike yöntemleri gerektirebilir.\n\n# Örnek veri seti oluşturalım\n# üreteç sabitlenir\nset.seed(123)\ndata &lt;- data.frame(\n  ID = 1:10,\n  Age = c(25, 30, NA, 22, 35, 40, NA, 28, NA, 32),\n  Income = c(50000, 60000, 75000, NA, 80000, 90000, 70000, NA, 65000, 75000),\n  Score = c(80, 85, 90, 78, NA, 88, 92, 85, 80, NA)\n)\n\n# veride hiç NA var mı? \n# TRUE tabloda en az bir tane NA olduğu anlamına gelir \nanyNA(data)\n\n[1] TRUE\n\n# eksik verilerin sorgulanması\nis.na(data) \n\n         ID   Age Income Score\n [1,] FALSE FALSE  FALSE FALSE\n [2,] FALSE FALSE  FALSE FALSE\n [3,] FALSE  TRUE  FALSE FALSE\n [4,] FALSE FALSE   TRUE FALSE\n [5,] FALSE FALSE  FALSE  TRUE\n [6,] FALSE FALSE  FALSE FALSE\n [7,] FALSE  TRUE  FALSE FALSE\n [8,] FALSE FALSE   TRUE FALSE\n [9,] FALSE  TRUE  FALSE FALSE\n[10,] FALSE FALSE  FALSE  TRUE\n\n# toplam eksik veri sayısını tespit etmek\nsum(is.na(data))\n\n[1] 7\n\n# değişken düzeyinde eksik veri sayısını tespit etmek\ncolSums(is.na(data)) \n\n    ID    Age Income  Score \n     0      3      2      2"
  },
  {
    "objectID": "ggplot2.html#saçılım-grafikleri",
    "href": "ggplot2.html#saçılım-grafikleri",
    "title": "ggplot2 ile Veri Görselleştirme",
    "section": "Saçılım Grafikleri",
    "text": "Saçılım Grafikleri\nSaçılım (scatter) grafiği, genellikle fizik ve istatistik gibi bilimlerde kullanılan bir grafik türüdür. Saçılım grafiği, iki değişken arasındaki ilişkiyi görsel olarak göstermek için kullanılır. Bir eksende bir değişkenin değerleri, diğer eksende ise diğer değişkenin değerleri yer alır. Her bir nokta, veri setindeki bir gözlem birimini temsil eder. İki değişken arasındaki ilişki, noktaların dağılımı üzerinden anlaşılabilir.\nSaçılım grafiklerinin temel amaçları şunlar:\n\nİki Değişken Arasındaki İlişkiyi Görselleştirme: Saçılım grafikleri, iki değişken arasındaki ilişkiyi anlamak için etkili bir araçtır. Pozitif, negatif, ya da hiçbir ilişki olup olmadığını hızlıca gösterir.\nAykırı Değerleri ve Dağılımı Kontrol Etme: Saçılım grafikleri, aykırı değerleri ve değişkenlerin dağılımını görsel olarak kontrol etmek için kullanılır.\nKorelasyon Analizi: İki değişken arasındaki korelasyonu değerlendirmek için saçılım grafikleri kullanılabilir. İki değişken arasındaki doğrusal ilişkiyi belirlemek için korelasyon katsayısı kullanılabilir.\n\nSaçılım grafiği kullanarak, iki değişken arasındaki ilişkinin doğası hakkında bilgi edinebilirsiniz. Örneğin, pozitif bir korelasyon varsa, veri noktaları genellikle yukarı doğru bir eğilim gösterirken, negatif bir korelasyon varsa, veri noktaları genellikle aşağı doğru bir eğilim gösterir. Korelasyon olmaması durumunda ise veri noktaları dağınık bir şekilde yayılmış olur. Saçılım grafiği, istatistiksel analizlerde veri keşfi yapmak ve ilişkileri anlamak için önemli bir araçtır.\nŞimdi, bir örnek üzerinden saçılım grafiklerini R ile nasıl oluşturabileceğinize bakalım. Aşağıda, R’de mtcars veri seti üzerinden bir örnek bulunmaktadır.\n\n# Saçılım grafiği oluşturma\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  labs(title = \"Saçılım Grafiği\",\n       x = \"Ağırlık (wt)\",\n       y = \"Miles Per Gallon (mpg)\")\n\n\n\n\n\n\n\n\nBu örnekte, mtcars veri setindeki ağırlık (wt) ve yakıt verimliliği (mpg) değişkenleri arasındaki ilişkiyi gösteren bir saçılım grafiği oluşturduk. ggplot2 paketini kullanarak ggplot fonksiyonu ile grafiği oluşturduk, ardından geom_point() fonksiyonu ile noktaları ekledik ve labs() fonksiyonu ile ekseni etiketledik.\nAşağıdaki örnek, çeşitli argümanların nasıl kullanılabileceğini göstermektedir. Saçılım grafiklerinde kullanılabilen birçok farklı argüman vardır ve ihtiyacınıza göre bunları özelleştirebilirsiniz. Bu argümanlar, grafikteki renkler, şekiller, boyutlar, saydamlıklar ve diğer estetik özellikleri kontrol etmenize olanak tanır.\n\n# Saçılım grafiği oluşturma ve özellikleri belirleme\nggplot(mtcars, aes(x = wt, y = mpg, color = factor(cyl), size = hp)) +\n  geom_point(shape = 16, alpha = 0.7) +  # Nokta şekli ve saydamlık\n  labs(title = \"Saçılım Grafiği\",\n       x = \"Ağırlık (wt)\",\n       y = \"Miles Per Gallon (mpg)\",\n       color = \"Silindir Sayısı\",\n       size = \"Güç (hp)\") +\n  theme_minimal() +  # Tema seçimi\n  scale_color_manual(values = c(\"red\", \"green\", \"blue\"))  # Renk paleti\n\n\n\n\n\n\n\n\n\ncolor: factor(cyl) ile silindir sayısına göre renklendirme.\nsize: hp ile güç değerine göre nokta boyutu.\nshape: 16 ile nokta şekli belirleme.\nalpha: 0.7 ile nokta saydamlığı.\nlabs(): Grafik başlığı ve ekseni etiketleri.\ntheme_minimal(): Minimal bir tema seçimi.\nscale_color_manual(): Renk paletinin manuel olarak belirlenmesi.\n\ngeom_smooth(), ggplot2 paketinde bulunan bir geometrik fonksiyondur ve saçılım grafiklerine regresyon çizgisi veya düzeltme çizgisi eklemek için kullanılır. Bu fonksiyon, veri üzerinde düzenli bir eğilimi görselleştirmek veya iki değişken arasındaki ilişkiyi özetlemek amacıyla kullanılır.\ngeom_smooth() fonksiyonu, özellikle saçılım grafiklerindeki noktalar arasındaki eğilimi ifade etmek ve bu eğilimi göstermek için kullanılır. Bu çizgi, genellikle loess düzeltme çizgisi veya lineer regresyon çizgisi gibi yöntemlere dayanabilir.\n\n\n\n\n\n\nLoess Hakkında\n\n\n\nLOESS (LOcally WEighted Scatterplot Smoother), bir veri setindeki noktalar arasındaki düzenliği ifade etmek için kullanılan bir regresyon yöntemidir. LOESS, birçok noktadan oluşan bir saçılım grafiğine uygulandığında, bu grafiği daha yumuşak bir eğriyle düzeltir ve genel bir eğilimi ifade eder.\nLOESS yöntemi, her bir noktanın çevresindeki komşu noktalara daha fazla ağırlık verir ve bu ağırlıkları kullanarak her bir noktanın regresyonunu hesaplar. Böylece, LOESS yöntemi, veri setindeki lokal düzenlemeleri daha iyi yakalayabilir ve genel eğilimi daha esnek bir şekilde ifade edebilir.\n\n\nAşağıda, geom_smooth() fonksiyonu ile mtcars veri seti üzerinde bir örnek bulunmaktadır:\n\n# Saçılım grafiği oluşturma ve düzeltme çizgisi ekleme\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"blue\") +\n  labs(title = \"Saçılım Grafiği with Düzeltme Çizgisi\",\n       x = \"Ağırlık (wt)\",\n       y = \"Miles Per Gallon (mpg)\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nBu örnekte:\n\ngeom_smooth() fonksiyonu, düzeltme çizgisini eklemek için kullanılmıştır.\nmethod = \"lm\" parametresi, lineer regresyon modelini kullanmasını belirtir.\nse = FALSE parametresi, güven aralığını göstermemesini sağlar.\ncolor = \"blue\" parametresi, düzeltme çizgisinin rengini belirler.\n\nBu örnek, ağırlık (wt) ile yakıt verimliliği (mpg) arasındaki ilişkiyi gösteren bir saçılım grafiği oluşturur ve bu grafiğe bir lineer regresyon düzeltme çizgisi ekler. Bu düzeltme çizgisi, iki değişken arasındaki genel eğilimi görsel olarak özetler.\nse=TRUE parametresi, geom_smooth() fonksiyonu kullanılarak eklenen düzeltme çizgisi veya eğilim çizgisi etrafında güven aralığı (confidence interval) göstermek için kullanılır. Güven aralığı, regresyon çizgisinin tahmini değeri etrafında belirli bir güven düzeyindeki belirsizliği ifade eder.\nAşağıda, se=TRUE parametresi ile geom_smooth() kullanarak bir örnek bulunmaktadır:\n\n# Saçılım grafiği oluşturma ve düzeltme çizgisi ile güven aralığı ekleme\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  geom_smooth(method = \"loess\", se = TRUE, color = \"blue\") +\n  labs(title = \"Saçılım Grafiği-LOESS Düzeltme Çizgisi ve Güven Aralığı\",\n       x = \"Ağırlık (wt)\",\n       y = \"Miles Per Gallon (mpg)\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\ngeom_smooth(method = \"loess\", se = TRUE, color = \"blue\") satırı, LOESS düzeltme çizgisini eklerken aynı zamanda güven aralığını da gösterir.\nse = TRUE parametresi, güven aralığını etkinleştirir.\ncolor = \"blue\" parametresi, çizginin rengini belirler.\n\nBu örnek grafiğin sağ tarafında çizilen mavi bant, LOESS düzeltme çizgisinin etrafında %95 güven aralığını temsil eder. Yani, her x değeri için bu bant içinde düzeltilmiş tahmini değerlerin olasılığı %95’tir. Güven aralığı, regresyon çizgisinin ne kadar güvenilir olduğunu ve tahminlerin belirli bir güven düzeyinde ne kadar kesin olduğunu anlamak için kullanılır.",
    "crumbs": [
      "ggplot2 ile Veri Görselleştirme"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "3  Fonksiyonlar",
    "section": "",
    "text": "3.1 Varsayılan Argümanlar Nedir?\nVarsayılan argümanlar, bir fonksiyonun çağrılması sırasında belirtilmediği takdirde kullanılacak olan önceden belirlenmiş değerlerdir. Bu, fonksiyonun kullanılmasını esnek hale getirir ve bazı parametrelerin belirtilmemesi durumunda fonksiyonun çalışmasını sağlar. Bir fonksiyon tanımlarken, parametrelerin yanına = değer şeklinde varsayılan değerler atanabilir. Örneğin, aşağıdaki fonksiyon, x parametresine herhangi bir değer belirtilmediğinde varsayılan olarak 2’yi alır.\nkare_al &lt;- function(x = 2) {\n  return(x^2)\n}\n\n# Varsayılan Argümanlar Kullanılmayan Durum:\nkare_al(3)\n\n[1] 9\nBu durumda, x parametresine 3 değeri geçirilmiştir. Dolayısıyla fonksiyon 3’ün karesi olan 9’u döndürür.\n# Varsayılan Argümanlar Kullanılan Durum:\nkare_al()\n\n[1] 4\nBu durumda ise, x parametresine herhangi bir değer belirtilmemiştir. Fonksiyon, varsayılan olarak 2’yi alarak 2’nin karesi olan 4’ü döndürür.\nVarsayılan Argümanların Faydaları:",
    "crumbs": [
      "R Programlamaya Giriş",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "functions.html#varsayılan-argümanlar-nedir",
    "href": "functions.html#varsayılan-argümanlar-nedir",
    "title": "3  Fonksiyonlar",
    "section": "3.1 Varsayılan Argümanlar Nedir?",
    "text": "3.1 Varsayılan Argümanlar Nedir?\nVarsayılan argümanlar, bir fonksiyonun çağrılması sırasında belirtilmediği takdirde kullanılacak olan önceden belirlenmiş değerlerdir. Bu, fonksiyonun kullanılmasını esnek hale getirir ve bazı parametrelerin belirtilmemesi durumunda fonksiyonun çalışmasını sağlar. Bir fonksiyon tanımlarken, parametrelerin yanına = değer şeklinde varsayılan değerler atanabilir. Örneğin, aşağıdaki fonksiyon, x parametresine herhangi bir değer belirtilmediğinde varsayılan olarak 2’yi alır.\n\nkare_al &lt;- function(x = 2) {\n  return(x^2)\n}\n\n# Varsayılan Argümanlar Kullanılmayan Durum:\nkare_al(3)\n\n[1] 9\n\n\nBu durumda, x parametresine 3 değeri geçirilmiştir. Dolayısıyla fonksiyon 3’ün karesi olan 9’u döndürür.\n\n# Varsayılan Argümanlar Kullanılan Durum:\nkare_al()\n\n[1] 4\n\n\nBu durumda ise, x parametresine herhangi bir değer belirtilmemiştir. Fonksiyon, varsayılan olarak 2’yi alarak 2’nin karesi olan 4’ü döndürür.\nVarsayılan Argümanların Faydaları:\n\nKullanıcıya esneklik sağlar ve belirli parametrelerin belirtilmemesi durumunda fonksiyonun hala çalışmasını sağlar.\nFonksiyonun daha kullanıcı dostu olmasını sağlar, çünkü tüm parametrelerin her zaman belirtilmesi gerekmez.\nKodun daha okunabilir olmasını sağlar, çünkü fonksiyonun ne yaptığını anlamak için varsayılan değerlerin dökümantasyonu gibi ek bilgilere ihtiyaç yoktur."
  },
  {
    "objectID": "functions.html#değişken-argümanlar-nedir",
    "href": "functions.html#değişken-argümanlar-nedir",
    "title": "3  Fonksiyonlar",
    "section": "3.2 Değişken Argümanlar Nedir?",
    "text": "3.2 Değişken Argümanlar Nedir?\nDeğişken argümanlar kavramı, bir fonksiyonun istediğiniz sayıda argümanı kabul etmesini sağlar. ... (ellipsis olarak ifade edilmektedir) işareti, R programlamada değişken argümanları temsil eder. Bu özellik, fonksiyonların daha esnek ve çok amaçlı olmasını sağlar. ... işareti, bir fonksiyonun değişken sayıda argüman almasına izin verir. Fonksiyon tanımında belirli olmayan argümanlar için kullanılır. Bu şekilde, fonksiyonunuzu daha esnek hale getirebilir ve çeşitli durumlara uyum sağlayabilirsiniz.\n\ntopla &lt;- function(...) {\n  toplam &lt;- sum(...)\n  return(toplam)\n}\n\n# Kullanım\ntopla(1, 2, 3)\n\n[1] 6\n\ntopla(1, 2, 3, 4, 5)\n\n[1] 15\n\n\nBu örnekte, topla fonksiyonu değişken sayıda argüman alır. ... ifadesi, fonksiyona geçirilen tüm argümanları toplar ve sonucu döndürür.\n\nbirlestir &lt;- function(..., ayrac = \", \") {\n  metin &lt;- paste(..., sep = ayrac)\n  return(metin)\n}\n\n# Kullanım\nbirlestir(\"merhaba\", \"dünya\", \"nasılsınız?\")  \n\n[1] \"merhaba, dünya, nasılsınız?\"\n\nbirlestir(\"elma\", \"armut\", \"muz\", ayrac = \" - \")\n\n[1] \"elma - armut - muz\"\n\n\nBu örnekte, birlestir fonksiyonu değişken sayıda metin argüman alır. ... ifadesi, fonksiyona geçirilen her bir metni belirtilen ayıracı kullanarak birleştirir.\nBu örneklerde görüldüğü gibi, ... işareti R’de fonksiyonlara esneklik kazandırır ve hem değişken hem çoklu sayıda argüman alabilmelerini sağlar. Bu özellik, fonksiyonlarınızı daha genel ve çok amaçlı hale getirmenize olanak tanır."
  },
  {
    "objectID": "if_else_for.html#if-else",
    "href": "if_else_for.html#if-else",
    "title": "4  Kontrol İfadeleri",
    "section": "4.1 if-else",
    "text": "4.1 if-else\nif-else ifadesi, programların belirli koşullar altında farklı işlemler yapmasını sağlar. Eğer bir koşul doğruysa belirli bir blok çalıştırılır, aksi takdirde başka bir blok çalıştırılır. Bu kombinasyon R’de en sık kullanılan kontrol yapılarındandır. Bu yapıda, bir koşulu test edebilir ve doğru veya yanlış olmasına bağlı olarak ona göre hareket edebilirsiniz. if-else kombinasyonlarında aşağıdaki yapılar kullanılmaktadır:\n\nif (koşul) {\n  # Koşul doğruysa yapılacak işlemler\n} else {\n  # Koşul yanlışsa yapılacak işlemler\n}\n\n\nif (koşul1) {\n  # Koşul 1 doğruysa yapılacak işlemler\n} else if (koşul2) {\n  # Koşul 2 doğruysa yapılacak işlemler\n} else {\n  # Hiçbir koşul doğru değilse yapılacak işlemler\n}\n\nÖrnek olarak, bir kullanıcının yaşına bağlı olarak belli bir mesaj gösterelim.\n\nyas &lt;- 18\n\nif (yas &gt;= 18) {\n  print(\"Oy kullanabilirsiniz!\")\n} else {\n  print(\"Üzgünüz, oy kullanmak için henüz yaşınız tutmuyor.\")\n}\n\n[1] \"Oy kullanabilirsiniz!\"\n\n\nBurada, if ifadesi yas &gt;= 18 koşulunu kontrol eder. Eğer bu koşul doğruysa, “Oy kullanabilirsiniz!” mesajı ekrana yazdırılır; aksi halde, “Üzgünüz, oy kullanmak için henüz yaşınız tutmuyor.” mesajı yazdırılır.\nBirden fazla koşulu kontrol etmek için else if ifadesini kullanabiliriz. Örneğin, bir öğrencinin not durumunu kontrol edelim.\n\nnot &lt;- 75\n\nif (not &gt;= 90) {\n  print(\"Notunuz AA\")\n} else if (not &gt;= 80) {\n  print(\"Notunuz BA\")\n} else if (not &gt;= 70) {\n  print(\"Notunuz BB\")\n} else if (not &gt;= 60) {\n  print(\"Notunuz CB\")\n} else {\n  print(\"Dersten başarısız oldunuz.\")\n}\n\n[1] \"Notunuz BB\"\n\n\nBu örnekte, else if ifadeleri sırayla öğrencinin notunu kontrol eder ve koşullara uygun olarak farklı mesajları yazdırır. Eğer hiçbir koşul sağlanmazsa, “Dersten başarısız oldunuz.” mesajı yazdırılır.\nAyrıca ifelse() fonksiyonu R programlama dilinde bulunan başka bir fonksiyondur ve if-else ifadesine benzer bir işlevi vardır. Bu fonksiyon, vektörler üzerinde koşullu işlemler yapmak için kullanılır.\nifelse() fonksiyonu şu şekilde kullanılır.\n\nifelse(test, yes, no)\n\n\ntest: Koşul veya koşulları içeren ifade veya vektör.\nyes: Koşul doğruysa uygulanacak değer veya işlem.\nno: Koşul yanlışsa uygulanacak değer veya işlem.\n\nÖrnek olarak, bir vektördeki değerlerin pozitif veya negatif olmasını kontrol edelim:\n\nvec &lt;- c(-2, 3, -5, 8, -1)\nsonuc &lt;- ifelse(vec &gt;= 0, \"Pozitif\", \"Negatif\")\nprint(sonuc)\n\n[1] \"Negatif\" \"Pozitif\" \"Negatif\" \"Pozitif\" \"Negatif\"\n\n\nBu örnekte, ifelse() fonksiyonu vec vektöründeki her bir değeri kontrol eder. Eğer değer 0’dan büyük veya eşitse, o değerin karşılığı “Pozitif” olur; aksi takdirde “Negatif” olur.\nAşağıdaki örnekte ise ifelse() fonksiyonun birden fazla şekilde bir dataframe içerisinde nasıl kullanıldığını gösterelim.\n\ndf &lt;- data.frame(value = 1:9)\ndf$group &lt;- ifelse(df$value &lt;= 3,1,ifelse(df$value &gt; 3 & df$value &lt; 6,2,3))\ndf\n\n  value group\n1     1     1\n2     2     1\n3     3     1\n4     4     2\n5     5     2\n6     6     3\n7     7     3\n8     8     3\n9     9     3\n\n\nBu örnekte, yeni oluşturulacak group değişkeni için değerler atanacaktır. Buna göre,\n\nEğer value kolonu 3 ve altında değere sahipse group değişkenine 1,\nvalue kolonu 3’den büyük ve 6’dan küçük ise group değişkenine 2,\nDiğer durumlarda ise group değişkenine 3 değeri atanacaktır."
  },
  {
    "objectID": "if_else_for.html#döngüler",
    "href": "if_else_for.html#döngüler",
    "title": "4  Kontrol İfadeleri",
    "section": "4.2 Döngüler",
    "text": "4.2 Döngüler\n\n4.2.1 for\nfor döngüsü R programlama dilinde tekrarlı işlemler yapmak için kullanılır. Bu döngü, bir dizi veya vektör üzerinde iterasyon yaparak her bir elemana erişmenizi sağlar. Genellikle listedeki her elemanı veya belirli bir aralıktaki sayıları işlemek için kullanılır. for döngüsü şu yapıya sahiptir:\n\nfor (degisken in dizi veya dizin) {\n  # Her iterasyonda yapılacak işlemler\n}\n\n\ndegisken: Her iterasyonda dizin veya dizi elemanlarını temsil eden değişken.\ndizi veya dizin: Döngünün üzerinde dolaşacağı vektör, liste veya sayı dizisi.\n\nÖrnek olarak, 1’den 5’e kadar olan sayıları ekrana yazdıran bir for döngüsü kullanalım:\n\nsehirler &lt;- c(\"İstanbul\", \"Ankara\", \"İzmir\", \"Bursa\")\n\nfor (sehir in sehirler) {\n  print(paste(\"Şehir:\", sehir))\n}\n\n[1] \"Şehir: İstanbul\"\n[1] \"Şehir: Ankara\"\n[1] \"Şehir: İzmir\"\n[1] \"Şehir: Bursa\"\n\n\nBu örnekte, sehirler listesindeki her bir elemanı sehir değişkenine atar ve bu elemanları döngü içinde kullanarak her bir şehri ekrana yazdırır.\n\nfor (i in 1:5) {\n  print(paste(\"Karesi:\", i^2))\n}\n\n[1] \"Karesi: 1\"\n[1] \"Karesi: 4\"\n[1] \"Karesi: 9\"\n[1] \"Karesi: 16\"\n[1] \"Karesi: 25\"\n\n\nBu örnek, 1’den 5’e kadar olan sayıları i değişkenine atar ve her bir sayının karesini ekrana yazdırır.\n\nfor (i in 1:5) {\n  for (j in 1:5) {\n    cat(i, \"*\", j, \"=\", i*j, \"\\t\")\n  }\n  cat(\"\\n\")\n}\n\n1 * 1 = 1   1 * 2 = 2   1 * 3 = 3   1 * 4 = 4   1 * 5 = 5   \n2 * 1 = 2   2 * 2 = 4   2 * 3 = 6   2 * 4 = 8   2 * 5 = 10  \n3 * 1 = 3   3 * 2 = 6   3 * 3 = 9   3 * 4 = 12  3 * 5 = 15  \n4 * 1 = 4   4 * 2 = 8   4 * 3 = 12  4 * 4 = 16  4 * 5 = 20  \n5 * 1 = 5   5 * 2 = 10  5 * 3 = 15  5 * 4 = 20  5 * 5 = 25  \n\n\nBu örnekte, iç içe for döngüleri kullanılarak 1’den 5’e kadar olan sayıların çarpım tablosu oluşturuluyor. cat fonksiyonu kullanılarak değerler ekrana yazdırılıyor ve \\t ifadesi her bir değer arasında bir sekme boşluğu eklenmesini sağlıyor. Bu sayede çarpım tablosu satır içinde düzenli bir şekilde görüntülenmiş oluyor. \\t kullanımı, metin tabanlı çıktıları düzenlemek ve okunabilirliği artırmak için yaygın olarak kullanılan bir yöntemdir.\n\nn &lt;- 10\nfib &lt;- numeric(n)\nfib[1] &lt;- 0\nfib[2] &lt;- 1\n\nfor (i in 3:n) {\n  fib[i] &lt;- fib[i-1] + fib[i-2]\n}\nprint(fib)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\nBu örnekte, for döngüsü kullanılarak Fibonacci serisi hesaplanıyor ve n değerine göre seriyi ekrana yazdırıyor. Fibonacci serisi, her sayının kendisinden önceki iki sayının toplamıyla elde edildiği bir sayı dizisidir. Seri, herhangi bir rakam ile başlayabilir. Genellikle 0 ile başlar ve ilk iki terim 0 ve 1’dir.\nSeri şu şekilde ilerler:\n0, 1, 1, 2, 3, 5, 8, 13, 21, …\nHer sayı, kendisinden önce gelen iki sayının toplamıdır. Örneğin, 2 sayısı 1 ve 1’in toplamıdır, 3 sayısı ise 1 ve 2’nin toplamıdır ve bu şekilde devam eder.\nFibonacci Dizisinde yer alan sayıların diğer bir özelliği kendilerinden bir öncekiyle oranlandığında oluşan serinin altın orana yaklaşarak ilerlemesidir. Fibonacci serisi, doğada birçok yerde gözlemlenen yapılarla ilişkilendirilir. Bitki yapısı, deniz kabukları, sanat eserleri ve matematiksel modellemelerde sıkça karşımıza çıkar. Ayrıca, algoritmaların ve programların verimliliğini test etmek için kullanılabilir.\nfor döngüsünde i, j gibi harfler yerine başka ifadeler de kullanılabilir. Aşağıdaki örnekte oluşturulan 3 değişkenli bir veri setindeki ortalama değerler var değişkeni kulanılarak döngü yardımıyla ekrana yazdırılmıştır.\n\n(x &lt;- data.frame(yas = c(28, 35, 13, 13),\n                boy = c(1.62, 1.53, 1.83, 1.71),\n                kilo = c(65, 59, 72, 83)))\n\n  yas  boy kilo\n1  28 1.62   65\n2  35 1.53   59\n3  13 1.83   72\n4  13 1.71   83\n\nfor (var in colnames(x)) {\n    m &lt;- mean(x[, var])\n    print(paste0(\"Ortalama \", var,\" \", m, \"'tir\"))\n}\n\n[1] \"Ortalama yas 22.25'tir\"\n[1] \"Ortalama boy 1.6725'tir\"\n[1] \"Ortalama kilo 69.75'tir\"\n\n\nKullanım Alanları\n\nVeri İşleme: Veri setlerindeki her bir öğeyi işlemek için for döngüsü kullanılabilir. Örneğin, liste, vektör veya matrislerdeki her bir öğeyi ele almak için kullanılabilir.\nTekrarlı İşlemler: Belirli bir işlemi veya kod bloğunu belirli bir sayıda veya belirli bir koşula kadar tekrar etmek için for döngüsü kullanılabilir.\nİterasyonlar ve Simülasyonlar: İterasyonlar, özellikle simülasyonlarda, çeşitli durumları veya senaryoları değerlendirmek için sıklıkla kullanılır. Her bir iterasyon, farklı bir durumu temsil edebilir.\n\n\n\n\n\n\n\nUyarı\n\n\n\nfor döngüsü, belirli bir veri yapısındaki elemanları işlemek veya belirli bir işlemi tekrarlamak için oldukça kullanışlıdır. Ancak büyük veri setleri veya karmaşık işlemler için vektör işlemleri veya fonksiyonel programlama teknikleri genellikle tercih edilir, çünkü bu teknikler genellikle daha hızlı çalışabilir.\n\n\n\n\n4.2.2 while\nwhile döngüsü, belirli bir koşul doğru olduğu sürece belirli bir işlemi tekrar etmek için kullanılır. Genellikle döngünün kaç kere çalışacağı önceden belirlenmiş değilse veya bir koşul karşılanana kadar çalışmaya devam etmesi gerektiğinde tercih edilir. while döngüsü şu şekilde çalışır:\n\nwhile (koşul) {\n  # Koşul doğru olduğu sürece yapılacak işlemler\n}\n\nkoşul: Bir mantıksal ifade veya değer. Bu koşul doğru olduğu sürece döngü çalışmaya devam eder.\n\ntoplam &lt;- 0\ni &lt;- 1\n\nwhile (i &lt;= 10) {\n  toplam &lt;- toplam + i\n  i &lt;- i + 1\n}\n\nprint(toplam)\n\n[1] 55\n\n\nBu örnekte, while döngüsü kullanılarak 1’den 10’a kadar olan sayıların toplamı hesaplanıyor.\nKullanım Alanları\n\nKullanıcı Girişi: Kullanıcıdan bir değer alınana veya belirli bir koşul karşılanana kadar kullanıcıdan giriş almak için kullanılabilir.\nDosya Okuma ve Yazma İşlemleri: Dosya içeriği işlenirken belirli bir koşula kadar dosya okuma veya yazma işlemleri için kullanılabilir.\nDoğrusal Arama: Bir koşul karşılanana kadar bir listede veya veri yapısında doğrusal arama yapmak için kullanılabilir.\n\n\n\n\n\n\n\nUyarı\n\n\n\nwhile döngüsü, belirli bir koşul doğru olduğu sürece çalışır ve bu koşulun sonlanması veya değişmesiyle birlikte döngü sona erer. Ancak dikkatli kullanılmadığında sonsuz döngülere neden olabilir, bu yüzden döngüdeki koşulun belirli bir zamanda sonlanmasını sağlamak önemlidir.\n\n\n\n\n4.2.3 repeat\nrepeat döngüsü, belirli bir koşul sağlanana kadar tekrarlı işlemler yapmak için kullanılır. while döngüsünden farklı olarak, repeat döngüsü bir koşulun doğru veya yanlış olmasına bakmadan işlem yapmaya devam eder. Döngü, içerideki kod çalıştırıldıktan sonra, elle kesilmediği sürece sonsuza kadar devam eder.\nrepeat döngüsünün yapısı şu şekildedir:\n\nrepeat {\n  # Koşul kontrolü yapılmaksızın sürekli çalışacak işlemler\n  # Eğer bir şart sağlanırsa döngüyü kırarak çıkılır (break)\n}\n\nGenellikle repeat döngüsü, koşulun döngü içinde daha sonra kontrol edilmesi gereken durumlarda veya kullanıcıdan belirli bir işaret alınana kadar çalışması gereken durumlarda kullanılır.\n\nrepeat {\n  rastgele_sayi &lt;- runif(1)  # 0 ile 1 arasında rastgele bir sayı üretir\n  print(rastgele_sayi)\n  if (rastgele_sayi &gt; 0.9) {\n    break\n  }\n}\n\n[1] 0.2731675\n[1] 0.1216154\n[1] 0.9881675\n\n\nBu örnekte, repeat döngüsü 0 ile 1 arasında rastgele sayılar üretir ve bu sayılar 0.9’dan büyük olduğunda döngüyü sonlandırır.\n\nx &lt;- 0\n\nrepeat {\n    if (x^2 &gt; 20) break     # bu koşul sağlandığında döngüyü bitir\n    print(x)               \n    x &lt;- x + 1              # x'i bir artır\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n\n\nBu örnekte ise, repeat döngüsü 0 ile başlayan bir x sayısının karesinin 20’den büyük olması durumuna kadar x sayısını print eder. Eğer x’in karesi 20’den büyük ise döngüyü sonlandırır.\nKullanım Alanları\n\nBelirli Bir Durum Gerçekleşene Kadar İşlem Yapma: Kullanıcıdan belirli bir girdi alınana veya belirli bir durum gerçekleşene kadar işlem yapmak için kullanılabilir.\nKontrolsüz İşlemler: Belirli bir durum gerçekleşene kadar döngünün devam etmesi gerektiği durumlarda kullanılabilir. Örneğin, rastgele sayılar üretilmesi gibi.\n\n\n\n\n\n\n\nUyarı\n\n\n\nrepeat döngüsü, belirli bir koşul doğru veya yanlış olmasına bakmadan işlem yapmaya devam eder. Ancak, döngü sonsuz olabilir, bu nedenle döngüyü belirli bir şart sağlandığında kırmak (break ifadesiyle) önemlidir.\n\n\n\n\n4.2.4 next\nnext ifadesi, döngülerde bir iterasyonu atlamak ve döngüyü devam ettirmek için kullanılır. Genellikle belirli bir koşul karşılandığında o iterasyonun işlenmesini atlamak için kullanılır.\nnext ifadesinin kullanımı döngü içinde şu şekildedir:\n\nfor (i in 1:10) {\n  if (i %% 2 == 0) {\n    next  # Çift sayıları atla\n  }\n  print(i)\n}\n\n[1] 1\n[1] 3\n[1] 5\n[1] 7\n[1] 9\n\n\nBu örnekte, %% operatörü bir sayının diğerine bölümünden kalanı verir. Eğer bir sayı 2’ye bölündüğünde kalan 0 ise, o sayı çifttir. Yukarıdaki döngü, i çift sayı olduğunda next ifadesiyle o iterasyonu atlar ve döngüyü devam ettirir.\nKullanım Alanları\n\nBelirli Koşullarda İşlemleri Atlamak: Döngü içinde belirli bir koşul sağlandığında o iterasyonu atlamak için kullanılabilir.\nVeri Filtreleme: Veri içinde belirli koşullara uymayan öğeleri atlamak için kullanılabilir. Örneğin, bir liste içinde belirli tipte öğeleri filtrelemek için.\nDöngü Performansını İyileştirme: Bazı durumlarda belirli koşulların sağlanması durumunda işlemleri atlayarak döngü performansını artırabilir.\n\n\n\n\n\n\n\nNot\n\n\n\nnext ifadesi, döngüler içinde belirli koşullarda iterasyonları atlamak ve döngüyü devam ettirmek için kullanılır. Bu sayede istenmeyen durumları veya öğeleri döngü içinde işlem yapmadan geçebilirsiniz."
  },
  {
    "objectID": "strings.html",
    "href": "strings.html",
    "title": "6  Metin İşlemleri",
    "section": "",
    "text": "R’de bir çift tek tırnak veya çift tırnak içine yazılan herhangi bir değer, bir karakter olarak kabul edilir. Karakter yapısına sahip olan verilerin analizi özellikle metin madenciliği konusunda kullanışlıdır. Karakter nesneleri üzerinde çalışmak için kullanılabilecek birçok fonksiyon vardır.\n\n# as.character\nas.character(3.14)\n\n[1] \"3.14\"\n\nclass(as.character(3.14))\n\n[1] \"character\"\n\n# paste and paste0 karakter verilerini birleştirir\n\nfirst &lt;- \"Fatih\"\nlast &lt;- \"Tüzen\"\npaste(first,last) # default olarak arada boşluk bırakır\n\n[1] \"Fatih Tüzen\"\n\npaste0(first,last) # default olarak arada boşluk yoktur\n\n[1] \"FatihTüzen\"\n\npaste(\"R\",\"Python\",\"SPSS\",sep = \"-\")\n\n[1] \"R-Python-SPSS\"\n\n# grep fonksiyonu metin vektörünün içinde belirli bir deseni arar\n\nx &lt;- c(\"R programı\",\"program\",\"istatistik\",\"programlama dili\",\"bilgisayar\",\"matematik\")\ngrep(\"program\",x)\n\n[1] 1 2 4\n\ngrep(\"^ist\",x) # ist ile başlayan ifdelerin olduğu yerler\n\n[1] 3\n\ngrep(\"tik$\",x) # tik ile biten ifdelerin olduğu yerler\n\n[1] 3 6\n\n# grepl TRUE-FALSE olarak sonuç döndürür\ngrepl(\"tik$\",x) # tik ile biten ifdelerin olduğu yerler\n\n[1] FALSE FALSE  TRUE FALSE FALSE  TRUE\n\nx[grep(\"tik$\",x)] # tik ile biten ifdelerin olduğu yerler\n\n[1] \"istatistik\" \"matematik\" \n\nx[grepl(\"tik$\",x)] # tik ile biten ifdelerin olduğu yerler\n\n[1] \"istatistik\" \"matematik\" \n\n# nchar karakter uzunluğunu verir\nnchar(x)\n\n[1] 10  7 10 16 10  9\n\nnchar(\"R Programlama\") # boşluklar da sayılır!\n\n[1] 13\n\n# tolower ve toupper \ntoupper(\"program\") # karakteri büyük harf yapar\n\n[1] \"PROGRAM\"\n\ntolower(c(\"SPSS\",\"R\",\"PYTHON\")) # karakteri küçük harf yapar\n\n[1] \"spss\"   \"r\"      \"python\"\n\n# substr ve substring ile karakter parçalama yapılır\nsubstr(\"123456789\",start = 3, stop = 6)\n\n[1] \"3456\"\n\nsubstring(\"123456789\", first =3, last = 6)\n\n[1] \"3456\"\n\nx &lt;- \"R Programlama\"\nsubstr(x,nchar(x)-3,nchar(x)) # son 4 karakteri getir\n\n[1] \"lama\"\n\n# strsplit karakteri bölme işini yapar\nstrsplit(\"Ankara;İstanbul;İzmir\",split = \";\")\n\n[[1]]\n[1] \"Ankara\"   \"İstanbul\" \"İzmir\""
  },
  {
    "objectID": "import_export.html",
    "href": "import_export.html",
    "title": "8  Verilerin İçe ve Dışa Aktarılması",
    "section": "",
    "text": "Temel anlamda R içerisinde excel ortamından (virgül ya da noktalı virgül ile ayrılmış) veri aktarımı (import) için read.table, read.csv, read.csv2 fonksiyonları kullanılmaktadır. Excel’den veri aktarımı için readxl veya openxlsxpaketi kullanılabilir. Verilerin dışa aktarılması için ise write.csv, write.table fonksiyonları kullanılabilir.\n\n# delimiter/separator , ise\nmtcars_csv &lt;- read.csv(\"datasets/mtcars_csv.csv\")\nstr(mtcars_csv)\n\n'data.frame':   32 obs. of  12 variables:\n $ car : chr  \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" \"Hornet 4 Drive\" ...\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : int  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : int  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : int  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : int  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: int  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: int  4 4 1 1 2 1 4 2 2 4 ...\n\n# stringsAsFactors karakter kolonları faktöre çevirir\nmtcars_csv &lt;- read.csv(\"datasets/mtcars_csv.csv\",\n                       stringsAsFactors = TRUE)\nstr(mtcars_csv)\n\n'data.frame':   32 obs. of  12 variables:\n $ car : Factor w/ 32 levels \"AMC Javelin\",..: 18 19 5 13 14 31 7 21 20 22 ...\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : int  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : int  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : int  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : int  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: int  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: int  4 4 1 1 2 1 4 2 2 4 ...\n\n# delimiter/separator ; ise\n\nmtcars_csv2 &lt;- read.csv2(\"datasets/mtcars_csv2.csv\")\nstr(mtcars_csv2)\n\n'data.frame':   32 obs. of  12 variables:\n $ car : chr  \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" \"Hornet 4 Drive\" ...\n $ mpg : chr  \"21\" \"21\" \"22.8\" \"21.4\" ...\n $ cyl : int  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: chr  \"160\" \"160\" \"108\" \"258\" ...\n $ hp  : int  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: chr  \"3.9\" \"3.9\" \"3.85\" \"3.08\" ...\n $ wt  : chr  \"2.62\" \"2.875\" \"2.32\" \"3.215\" ...\n $ qsec: chr  \"16.46\" \"17.02\" \"18.61\" \"19.44\" ...\n $ vs  : int  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : int  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: int  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: int  4 4 1 1 2 1 4 2 2 4 ...\n\n# read.table\n\nmtcars_csv &lt;- read.table(\"datasets/mtcars_csv.csv\",\n                         sep = \",\",\n                         header = TRUE)\n\nmtcars_csv2 &lt;- read.table(\"datasets/mtcars_csv2.csv\",\n                          sep = \";\",\n                          header = TRUE)\n\n# txt uzantılı dosyalar\n\nmtcars_txt &lt;- read.table(\"datasets/mtcars_txt.txt\",\n                          sep = \";\",\n                          header = TRUE)\n\n# excel dosyaları için\nlibrary(readxl)\nmtcars_excel &lt;- read_excel(\"datasets/mtcars_excel.xlsx\",\n                           sheet = \"mtcars\")\nstr(mtcars_excel)\n\ntibble [32 × 12] (S3: tbl_df/tbl/data.frame)\n $ car : chr [1:32] \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" \"Hornet 4 Drive\" ...\n $ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num [1:32] 160 160 108 258 360 ...\n $ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...\n $ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...\n\nmtcars_excel2 &lt;- read_excel(\"datasets/mtcars_excel.xlsx\",\n                            sheet = \"mtcars2\")\n\nNew names:\n• `` -&gt; `...2`\n• `` -&gt; `...3`\n• `` -&gt; `...4`\n• `` -&gt; `...5`\n\nstr(mtcars_excel2) # tablo 2. satırdan başlıyor o yüzden tablo başlıkları hatalı\n\ntibble [33 × 5] (S3: tbl_df/tbl/data.frame)\n $ mtcars verisi: chr [1:33] \"car\" \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" ...\n $ ...2         : chr [1:33] \"mpg\" \"21\" \"21\" \"22.8\" ...\n $ ...3         : chr [1:33] \"cyl\" \"6\" \"6\" \"4\" ...\n $ ...4         : chr [1:33] \"disp\" \"160\" \"160\" \"108\" ...\n $ ...5         : chr [1:33] \"hp\" \"110\" \"110\" \"93\" ...\n\n# istenilen satırı atlayarak istenilen sheet adı için,\nmtcars_excel2 &lt;- read_excel(\"datasets/mtcars_excel.xlsx\",\n                            sheet = \"mtcars2\",\n                            skip = 1)\nstr(mtcars_excel2)\n\ntibble [32 × 5] (S3: tbl_df/tbl/data.frame)\n $ car : chr [1:32] \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" \"Hornet 4 Drive\" ...\n $ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num [1:32] 160 160 108 258 360 ...\n $ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...\n\n\n\n# export\n\nwrite.csv(mtcars_csv,\"write_mtcars.csv\",\n          row.names = FALSE)\n\nwrite.table(mtcars_csv,\"write_mtcars.csv\",\n            row.names = FALSE,\n            sep = \";\")\n\nopenxlsx::write.xlsx(mtcars_csv,\"write_mtcars.xlsx\")"
  },
  {
    "objectID": "apply.html",
    "href": "apply.html",
    "title": "7  Apply Ailesi",
    "section": "",
    "text": "Apply() ailesi, matrislerden, dizilerden, listelerden ve veri çerçevelerinden tekrarlayan bir şekilde veri dilimlerini işlemek için fonksiyonlarla doldurulur. Bu fonksiyonlar sayesinde döngü yapılarının kullanılmasından kaçınır. Bir girdi listesi, matris veya dizi üzerinde hareket ederler ve bir veya birkaç isteğe bağlı argümanla adlandırılmış bir fonksiyon uygularlar.\n\napply(): bir dizinin ya da matrisin satır ya da sütunlarına fonksiyon uygular.\nlapply(): liste üzerindeki her elemana fonksiyon uygular.\nsapply(): lapply fonksiyonu ile aynıdır ancak çıktısı matris ya da veri çerçevesidir.\nmapply(): lapply fonksiyonunun çoklu versiyonudur.\ntapply(): faktör ya da grup düzeyinde fonksiyon uygular.\n\n\n# apply\nx &lt;-matrix(rnorm(30), nrow=5, ncol=6)\nx\n\n           [,1]       [,2]        [,3]       [,4]       [,5]       [,6]\n[1,]  0.9020711 -0.9743133  0.71455808 -0.2117407  0.1082054  0.1289471\n[2,]  0.4140138 -0.1558882  1.25117243  1.5309651  1.1360420 -0.7798979\n[3,]  0.3440592  0.2972569 -0.22752411  0.2023553 -0.2982793  1.2872323\n[4,] -0.8107969 -0.5786316  0.03354414  0.8373771  0.1273192 -0.1629164\n[5,]  0.6504766 -0.9588761  0.09458421 -0.7920373  0.4896539 -0.1502976\n\napply(x, 2 ,sum) # sütunlar üzerinde işlem yapar\n\n[1]  1.4998239 -2.3704522  1.8663348  1.5669196  1.5629412  0.3230674\n\napply(x, 1 ,sum) # satırlar üzerinde işlem yapar\n\n[1]  0.6677276  3.3964072  1.6051004 -0.5541044 -0.6664962\n\napply(x, 2 ,sd)\n\n[1] 0.6584325 0.5459850 0.6002548 0.9037577 0.5382110 0.7599493\n\napply(x, 1 ,mean)\n\n[1]  0.11128794  0.56606787  0.26751673 -0.09235074 -0.11108270\n\nmat &lt;- matrix(c(1:12),nrow=4)\nmat\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\napply(mat,2,function(x) x^2) # gözlemlerin karesi alınır\n\n     [,1] [,2] [,3]\n[1,]    1   25   81\n[2,]    4   36  100\n[3,]    9   49  121\n[4,]   16   64  144\n\napply(mat,2, quantile,probs=c(0.25,0.5,0.75)) # extra argüman eklenebilir\n\n    [,1] [,2]  [,3]\n25% 1.75 5.75  9.75\n50% 2.50 6.50 10.50\n75% 3.25 7.25 11.25\n\n# lapply\n\na &lt;-matrix(1:9, 3,3)\nb &lt;-matrix(4:15, 4,3)\nc &lt;-matrix(8:10, 3,2)\nmylist&lt;-list(a,b,c)\nmylist\n\n[[1]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n[[2]]\n     [,1] [,2] [,3]\n[1,]    4    8   12\n[2,]    5    9   13\n[3,]    6   10   14\n[4,]    7   11   15\n\n[[3]]\n     [,1] [,2]\n[1,]    8    8\n[2,]    9    9\n[3,]   10   10\n\nlapply(mylist,mean)\n\n[[1]]\n[1] 5\n\n[[2]]\n[1] 9.5\n\n[[3]]\n[1] 9\n\nlapply(mylist,sum)\n\n[[1]]\n[1] 45\n\n[[2]]\n[1] 114\n\n[[3]]\n[1] 54\n\nlapply(mylist, function(x) x[,1]) # listedeki her matrisin ilk kolonunu çıkar\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6 7\n\n[[3]]\n[1]  8  9 10\n\nmylist2 &lt;- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))\nmylist2\n\n$a\n[1] 1 2 3 4\n\n$b\n [1] -0.5504369 -1.6640736  0.7727154 -1.0666501 -1.3781105  0.8876009\n [7] -0.3315536 -0.3770785  1.4004727 -0.0592696\n\n$c\n [1]  1.0753393  1.6603727  0.1290322  1.5515524  1.0674361 -0.4168885\n [7]  2.1146135 -0.9701858  2.3308020  0.7467587  1.2485754 -0.8320536\n[13]  1.4764899  2.7657592  0.9012983  0.6902795  2.4601078  0.7765996\n[19]  2.3999826  1.2063161\n\n$d\n  [1] 4.923875 3.505870 7.977689 4.145552 4.816565 5.463704 3.860662 4.308112\n  [9] 6.097590 2.743556 5.157814 4.332008 5.034070 3.397582 3.625931 4.925225\n [17] 7.225507 5.191297 5.327618 4.231334 3.674779 5.118195 5.167582 5.860302\n [25] 3.635627 5.196269 3.879465 6.362633 4.594024 6.164376 4.339326 3.887329\n [33] 5.304975 4.898573 5.037072 4.777218 5.433471 4.400116 6.441610 6.149883\n [41] 6.193061 5.299056 5.572199 5.603714 4.971396 3.822298 2.516910 3.121095\n [49] 5.269533 4.022569 4.514345 5.294461 5.365378 5.826627 6.317595 4.608278\n [57] 5.939040 4.026546 5.506301 4.002288 6.321949 5.458016 5.868183 5.145735\n [65] 5.517341 4.884013 6.093699 3.415229 5.480595 4.478778 7.862515 7.599002\n [73] 5.279442 4.989754 5.912336 6.071078 5.367425 5.239182 5.861437 3.487344\n [81] 5.684696 6.168333 3.831385 4.655357 4.899596 5.172725 3.932720 1.974871\n [89] 5.356333 3.961980 5.945502 3.214031 4.090243 3.059958 4.910874 4.322218\n [97] 3.180224 5.143543 4.925933 4.528337\n\nlapply(mylist2, mean)\n\n$a\n[1] 2.5\n\n$b\n[1] -0.2366384\n\n$c\n[1] 1.119109\n\n$d\n[1] 4.93699\n\n# sapply\n\nhead(cars)\n\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n\nlapply(cars,sum)\n\n$speed\n[1] 770\n\n$dist\n[1] 2149\n\nsapply(cars,sum)\n\nspeed  dist \n  770  2149 \n\nsapply(cars,median)\n\nspeed  dist \n   15    36 \n\nsapply(cars,mean)\n\nspeed  dist \n15.40 42.98 \n\n# mapply\n\nl1 &lt;- list(a=c(1:5),b=c(6:10))\nl2 &lt;- list(c=c(11:15),d=c(16:20))\n\nmapply(sum,l1$a,l1$b,l2$c,l2$d) # gözlemlerin toplamı\n\n[1] 34 38 42 46 50\n\nmapply(prod,l1$a,l1$b,l2$c,l2$d) # gözlemlerin çarpımı\n\n[1]  1056  2856  5616  9576 15000\n\n# tapply\n\ndf &lt;- data.frame(x =round(runif(15,min=1,max=10)),\n                 group=sample(c(1:3),15,replace = TRUE))\ndf\n\n    x group\n1   1     3\n2   3     3\n3   3     3\n4  10     3\n5   6     3\n6   5     3\n7   7     1\n8   7     2\n9  10     3\n10 10     1\n11  5     1\n12  2     3\n13  6     3\n14  9     2\n15  9     2\n\ntapply(df$x,df$group, FUN = mean)\n\n       1        2        3 \n7.333333 8.333333 5.111111 \n\ntapply(df$x,df$group, FUN = sum)\n\n 1  2  3 \n22 25 46 \n\ntapply(df$x,df$group, FUN = length)\n\n1 2 3 \n3 3 9 \n\ntapply(df$x,df$group, FUN = range)\n\n$`1`\n[1]  5 10\n\n$`2`\n[1] 7 9\n\n$`3`\n[1]  1 10"
  }
]