[
  {
    "objectID": "data_manipulation.html",
    "href": "data_manipulation.html",
    "title": "Veri Manipulasyonu",
    "section": "",
    "text": "Değişken Seçme - select\nVeri manipülasyonu, veri çerçeveleri üzerinde verileri dönüştürmek, filtrelemek, birleştirmek veya yeniden düzenlemek gibi işlemleri içeren önemli bir veri bilimi becerisidir. R programlama dili, veri manipülasyonu için oldukça güçlü ve esnek bir araç sunar. Bu yazıda, R kullanarak veri manipülasyonunu nasıl yapabileceğinizi öğreneceğiz.\nVeri manipülasyonu için R’da yaygın olarak kullanılan iki ana kavram, “veri çerçeveleri” ve “paketler”dir. Veri çerçeveleri, verileri tablo şeklinde düzenleyen ve işleyen veri yapılarıdır. R’da veri çerçeveleri, data.frame türünden nesnelerdir. Veri manipülasyonu için kullanabileceğiniz birçok paket vardır, ancak en yaygın kullanılanlar arasında dplyr ve tidyr bulunur. Bu paketler, veri manipülasyonunu kolaylaştırmak için bir dizi işlev içerir.\ndplyr, RStudio’dan Hadley Wickham tarafından geliştirilmiş ve en yaygın veri işleme zorluklarını çözmenize yardımcı olan bir veri işleme dilbilgisidir. dplyr paketi, devtools paketi ve install_github() fonksiyonu kullanılarak CRAN’dan veya GitHub’dan kurulabilir. GitHub deposu genellikle paketteki en son güncellemeleri ve geliştirme sürümünü içerir.\nCRAN sayfasından yüklemek için;\nGitHub sayfasından yüklemek için;\ndplyr paketinde sıklıkla kullanılan fonksiyonlar şunlardır:\nVeri manipülasyonu ile örnekler için bazen küçük veri setleri oluşturulacaktır bazen de 2015 yılı ABD nüfus sayımına ilişkin counties veri seti kullanılacaktır. Bu veri setinde eyalet ve şehir detayında nüfus, gelir, ırk, coğrafi yapı, işgücü gibi değişkenler yer almaktadır.\nTabloyu (veri çerçevesi) seçmek ve dönüştürmek için R’da dplyr paketinde bulunan select() fonksiyonu oldukça kullanışlıdır. Bu fonksiyon, belirli sütunları seçmek veya sütun adlarını değiştirmek için kullanılır. select() fonksiyonunu kullanarak veri çerçevesinde sütunları seçme ve dönüştürme işlemlerinin nasıl yapıldığına dair aşağıda örnekler mevcuttur.\n# belirli sütunları seçmek\ncounties %&gt;%\nselect(state, county, population, unemployment)\n\n# A tibble: 3,138 × 4\n   state   county   population unemployment\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama Autauga       55221          7.6\n 2 Alabama Baldwin      195121          7.5\n 3 Alabama Barbour       26932         17.6\n 4 Alabama Bibb          22604          8.3\n 5 Alabama Blount        57710          7.7\n 6 Alabama Bullock       10678         18  \n 7 Alabama Butler        20354         10.9\n 8 Alabama Calhoun      116648         12.3\n 9 Alabama Chambers      34079          8.9\n10 Alabama Cherokee      26008          7.9\n# ℹ 3,128 more rows\n\n# belli aralıkta bütün sütunların seçilmesi\ncounties %&gt;%\nselect(state, county, drive:work_at_home)\n\n# A tibble: 3,138 × 8\n   state   county   drive carpool transit  walk other_transp work_at_home\n   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama Autauga   87.5     8.8     0.1   0.5          1.3          1.8\n 2 Alabama Baldwin   84.7     8.8     0.1   1            1.4          3.9\n 3 Alabama Barbour   83.8    10.9     0.4   1.8          1.5          1.6\n 4 Alabama Bibb      83.2    13.5     0.5   0.6          1.5          0.7\n 5 Alabama Blount    84.9    11.2     0.4   0.9          0.4          2.3\n 6 Alabama Bullock   74.9    14.9     0.7   5            1.7          2.8\n 7 Alabama Butler    84.5    12.4     0     0.8          0.6          1.7\n 8 Alabama Calhoun   85.3     9.4     0.2   1.2          1.2          2.7\n 9 Alabama Chambers  85.1    11.9     0.2   0.3          0.4          2.1\n10 Alabama Cherokee  83.9    12.1     0.2   0.6          0.7          2.5\n# ℹ 3,128 more rows\n\n# belirli bir ifadeyi içeren sütunları seçmek\ncounties %&gt;%\nselect(state, county, contains(\"employed\"))\n\n# A tibble: 3,138 × 4\n   state   county   employed self_employed\n   &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Alabama Autauga     23986           5.5\n 2 Alabama Baldwin     85953           5.8\n 3 Alabama Barbour      8597           7.3\n 4 Alabama Bibb         8294           6.7\n 5 Alabama Blount      22189           4.2\n 6 Alabama Bullock      3865           5.4\n 7 Alabama Butler       7813           6.2\n 8 Alabama Calhoun     47401           5  \n 9 Alabama Chambers    13689           2.8\n10 Alabama Cherokee    10155           7.9\n# ℹ 3,128 more rows\n\n# belirli bir ifade ile başyalan sütunları seçmek\ncounties %&gt;%\nselect(state, county, starts_with(\"income\"))\n\n# A tibble: 3,138 × 6\n   state   county   income income_err income_per_cap income_per_cap_err\n   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;          &lt;dbl&gt;              &lt;dbl&gt;\n 1 Alabama Autauga   51281       2391          24974               1080\n 2 Alabama Baldwin   50254       1263          27317                711\n 3 Alabama Barbour   32964       2973          16824                798\n 4 Alabama Bibb      38678       3995          18431               1618\n 5 Alabama Blount    45813       3141          20532                708\n 6 Alabama Bullock   31938       5884          17580               2055\n 7 Alabama Butler    32229       1793          18390                714\n 8 Alabama Calhoun   41703        925          21374                489\n 9 Alabama Chambers  34177       2949          21071               1366\n10 Alabama Cherokee  36296       1710          21811               1556\n# ℹ 3,128 more rows\n\n# belirli bir ifade ile biten sütunları seçmek\ncounties %&gt;%\nselect(state, county, ends_with(\"work\"))\n\n# A tibble: 3,138 × 5\n   state   county   private_work public_work family_work\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Alabama Autauga          73.6        20.9         0  \n 2 Alabama Baldwin          81.5        12.3         0.4\n 3 Alabama Barbour          71.8        20.8         0.1\n 4 Alabama Bibb             76.8        16.1         0.4\n 5 Alabama Blount           82          13.5         0.4\n 6 Alabama Bullock          79.5        15.1         0  \n 7 Alabama Butler           77.4        16.2         0.2\n 8 Alabama Calhoun          74.1        20.8         0.1\n 9 Alabama Chambers         85.1        12.1         0  \n10 Alabama Cherokee         73.1        18.5         0.5\n# ℹ 3,128 more rows\n\n# belirli sütunları hariç tutarak seçmek\ncounties %&gt;%\nselect(census_id:population,-c(men:land_area))\n\n# A tibble: 3,138 × 6\n   census_id state   county   region metro    population\n   &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;         &lt;dbl&gt;\n 1 1001      Alabama Autauga  South  Metro         55221\n 2 1003      Alabama Baldwin  South  Metro        195121\n 3 1005      Alabama Barbour  South  Nonmetro      26932\n 4 1007      Alabama Bibb     South  Metro         22604\n 5 1009      Alabama Blount   South  Metro         57710\n 6 1011      Alabama Bullock  South  Nonmetro      10678\n 7 1013      Alabama Butler   South  Nonmetro      20354\n 8 1015      Alabama Calhoun  South  Metro        116648\n 9 1017      Alabama Chambers South  Nonmetro      34079\n10 1019      Alabama Cherokee South  Nonmetro      26008\n# ℹ 3,128 more rows\n\n# belirli veri tipindeki sütunları seçmek\ncounties %&gt;%\nselect(where(is.character))\n\n# A tibble: 3,138 × 5\n   census_id state   county   region metro   \n   &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;   \n 1 1001      Alabama Autauga  South  Metro   \n 2 1003      Alabama Baldwin  South  Metro   \n 3 1005      Alabama Barbour  South  Nonmetro\n 4 1007      Alabama Bibb     South  Metro   \n 5 1009      Alabama Blount   South  Metro   \n 6 1011      Alabama Bullock  South  Nonmetro\n 7 1013      Alabama Butler   South  Nonmetro\n 8 1015      Alabama Calhoun  South  Metro   \n 9 1017      Alabama Chambers South  Nonmetro\n10 1019      Alabama Cherokee South  Nonmetro\n# ℹ 3,128 more rows\n\n# select ile kolon adı değiştirmek\ncounties %&gt;%\nselect(census_id,pop = population)\n\n# A tibble: 3,138 × 2\n   census_id    pop\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 1001       55221\n 2 1003      195121\n 3 1005       26932\n 4 1007       22604\n 5 1009       57710\n 6 1011       10678\n 7 1013       20354\n 8 1015      116648\n 9 1017       34079\n10 1019       26008\n# ℹ 3,128 more rows",
    "crumbs": [
      "Veri Manipulasyonu"
    ]
  },
  {
    "objectID": "data_manipulation.html#değişken-seçme---select",
    "href": "data_manipulation.html#değişken-seçme---select",
    "title": "Veri Manipulasyonu",
    "section": "",
    "text": "Not\n\n\n\nselect() fonksiyonu ayrıca sütunları seçerken veya döndürürken bazı özel işlevler de kullanmanıza olanak tanır. Örneğin, starts_with(), ends_with(), contains() gibi işlevleri kullanarak sütun adlarının belirli bir örüntüyü karşılayanları seçebilirsiniz. Bu fonksiyon, veri manipülasyonu işlemlerinde oldukça kullanışlıdır ve veri çerçevelerini istediğiniz şekilde özelleştirmenize yardımcı olur.",
    "crumbs": [
      "Veri Manipulasyonu"
    ]
  },
  {
    "objectID": "data_manipulation.html#veri-sıralama---arrange",
    "href": "data_manipulation.html#veri-sıralama---arrange",
    "title": "Veri Manipulasyonu",
    "section": "Veri Sıralama - arrange",
    "text": "Veri Sıralama - arrange\ndplyr paketinde bulunan arrange() fonksiyonu, veri çerçevesindeki satırları belirli bir sıraya göre düzenlemek için kullanılır. Bu sıralama işlemi, bir veya daha fazla sütunun değerlerine göre yapılabilir. arrange() fonksiyonu, veri analizi ve veri keşfi sırasında verilerinizi anlamak ve analiz etmek için önemli bir araçtır.\n\ncounties_selected &lt;- counties %&gt;%\nselect(state, county, population, unemployment)\n\n# artan sıralama (ascending)\ncounties_selected %&gt;%\narrange(population)\n\n# A tibble: 3,138 × 4\n   state      county    population unemployment\n   &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hawaii     Kalawao           85          0  \n 2 Texas      King             267          5.1\n 3 Nebraska   McPherson        433          0.9\n 4 Montana    Petroleum        443          6.6\n 5 Nebraska   Arthur           448          4  \n 6 Nebraska   Loup             548          0.7\n 7 Nebraska   Blaine           551          0.7\n 8 New Mexico Harding          565          6  \n 9 Texas      Kenedy           565          0  \n10 Colorado   San Juan         606         13.8\n# ℹ 3,128 more rows\n\n# azalan sıralama (descending)\ncounties_selected %&gt;%\narrange(desc(population))\n\n# A tibble: 3,138 × 4\n   state      county      population unemployment\n   &lt;chr&gt;      &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;\n 1 California Los Angeles   10038388         10  \n 2 Illinois   Cook           5236393         10.7\n 3 Texas      Harris         4356362          7.5\n 4 Arizona    Maricopa       4018143          7.7\n 5 California San Diego      3223096          8.7\n 6 California Orange         3116069          7.6\n 7 Florida    Miami-Dade     2639042         10  \n 8 New York   Kings          2595259         10  \n 9 Texas      Dallas         2485003          7.6\n10 New York   Queens         2301139          8.6\n# ℹ 3,128 more rows\n\n# birden fazla sütun seçerek sıralama\ncounties_selected %&gt;%\narrange(state,desc(population))\n\n# A tibble: 3,138 × 4\n   state   county     population unemployment\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama Jefferson      659026          9.1\n 2 Alabama Mobile         414251          9.8\n 3 Alabama Madison        346438          8.5\n 4 Alabama Montgomery     228138          8.8\n 5 Alabama Shelby         203530          5.5\n 6 Alabama Tuscaloosa     200458          7.6\n 7 Alabama Baldwin        195121          7.5\n 8 Alabama Lee            150982          7.3\n 9 Alabama Morgan         119786          9.9\n10 Alabama Calhoun        116648         12.3\n# ℹ 3,128 more rows",
    "crumbs": [
      "Veri Manipulasyonu"
    ]
  },
  {
    "objectID": "data_manipulation.html#veri-filtreleme---filter",
    "href": "data_manipulation.html#veri-filtreleme---filter",
    "title": "Veri Manipulasyonu",
    "section": "Veri Filtreleme - filter",
    "text": "Veri Filtreleme - filter\ndplyr paketindeki filter() fonksiyonu, veri çerçevesinde belirli bir koşulu karşılayan satırları seçmek için kullanılır. Bu fonksiyon, veri analizi sırasında verilerinizi filtrelemek ve istediğiniz verileri elde etmek için oldukça kullanışlıdır. filter() fonksiyonu, veri çerçevesindeki satırları seçerken belirli sütunlardaki değerlere dayalı koşulları uygulamanıza olanak tanır.\n\n# sadece New York'u filtrele\ncounties_selected %&gt;%\narrange(desc(population)) %&gt;%\nfilter(state == \"New York\")\n\n# A tibble: 62 × 4\n   state    county      population unemployment\n   &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;\n 1 New York Kings          2595259         10  \n 2 New York Queens         2301139          8.6\n 3 New York New York       1629507          7.5\n 4 New York Suffolk        1501373          6.4\n 5 New York Bronx          1428357         14  \n 6 New York Nassau         1354612          6.4\n 7 New York Westchester     967315          7.6\n 8 New York Erie            921584          7  \n 9 New York Monroe          749356          7.7\n10 New York Richmond        472481          6.9\n# ℹ 52 more rows\n\n# işsizlik oranı 6'dan küçük olanları filtrele\ncounties_selected %&gt;%\narrange(desc(population)) %&gt;%\nfilter(unemployment &lt; 6)\n\n# A tibble: 949 × 4\n   state    county       population unemployment\n   &lt;chr&gt;    &lt;chr&gt;             &lt;dbl&gt;        &lt;dbl&gt;\n 1 Virginia Fairfax         1128722          4.9\n 2 Utah     Salt Lake       1078958          5.8\n 3 Hawaii   Honolulu         984178          5.6\n 4 Texas    Collin           862215          4.9\n 5 Texas    Denton           731851          5.7\n 6 Texas    Fort Bend        658331          5.1\n 7 Kansas   Johnson          566814          4.5\n 8 Maryland Anne Arundel     555280          5.9\n 9 Colorado Jefferson        552344          5.9\n10 Utah     Utah             551957          5.5\n# ℹ 939 more rows\n\n# birden fazla koşul\ncounties_selected %&gt;%\narrange(desc(population)) %&gt;%\nfilter(state == \"New York\",unemployment &lt; 6)\n\n# A tibble: 5 × 4\n  state    county     population unemployment\n  &lt;chr&gt;    &lt;chr&gt;           &lt;dbl&gt;        &lt;dbl&gt;\n1 New York Tompkins       103855          5.9\n2 New York Chemung         88267          5.4\n3 New York Madison         72427          5.1\n4 New York Livingston      64801          5.4\n5 New York Seneca          35144          5.5\n\n# veya kullanımı\ncounties_selected %&gt;%\narrange(desc(population)) %&gt;%\nfilter(state == \"New York\"| unemployment &lt; 6)\n\n# A tibble: 1,006 × 4\n   state    county      population unemployment\n   &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;\n 1 New York Kings          2595259         10  \n 2 New York Queens         2301139          8.6\n 3 New York New York       1629507          7.5\n 4 New York Suffolk        1501373          6.4\n 5 New York Bronx          1428357         14  \n 6 New York Nassau         1354612          6.4\n 7 Virginia Fairfax        1128722          4.9\n 8 Utah     Salt Lake      1078958          5.8\n 9 Hawaii   Honolulu        984178          5.6\n10 New York Westchester     967315          7.6\n# ℹ 996 more rows",
    "crumbs": [
      "Veri Manipulasyonu"
    ]
  },
  {
    "objectID": "data_manipulation.html#değişken-güncelleme-ve-oluşturma--mutate",
    "href": "data_manipulation.html#değişken-güncelleme-ve-oluşturma--mutate",
    "title": "Veri Manipulasyonu",
    "section": "Değişken Güncelleme ve Oluşturma- mutate",
    "text": "Değişken Güncelleme ve Oluşturma- mutate\ndplyr paketindeki mutate() fonksiyonu, bir veri çerçevesinde yeni sütunlar oluşturmak veya mevcut sütunları dönüştürmek için kullanılır. Bu fonksiyon, veri çerçevesindeki herhangi bir sütunu işleyerek yeni bilgiler eklemenize veya mevcut sütunları değiştirmenize olanak tanır. mutate() fonksiyonu, veri analizi sırasında verilerinizi özelleştirmek için oldukça kullanışlıdır.\n\n# işsiz nüfus sayısına ilişkin değişken üretme\ncounties_selected %&gt;%\nmutate(unemployed_population = population * unemployment / 100)\n\n# A tibble: 3,138 × 5\n   state   county   population unemployment unemployed_population\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;                 &lt;dbl&gt;\n 1 Alabama Autauga       55221          7.6                 4197.\n 2 Alabama Baldwin      195121          7.5                14634.\n 3 Alabama Barbour       26932         17.6                 4740.\n 4 Alabama Bibb          22604          8.3                 1876.\n 5 Alabama Blount        57710          7.7                 4444.\n 6 Alabama Bullock       10678         18                   1922.\n 7 Alabama Butler        20354         10.9                 2219.\n 8 Alabama Calhoun      116648         12.3                14348.\n 9 Alabama Chambers      34079          8.9                 3033.\n10 Alabama Cherokee      26008          7.9                 2055.\n# ℹ 3,128 more rows\n\n# yeni sütun ekle\ncounties_selected %&gt;%\nmutate(unemployed_population = population * unemployment / 100) %&gt;%\narrange(desc(unemployed_population))\n\n# A tibble: 3,138 × 5\n   state      county         population unemployment unemployed_population\n   &lt;chr&gt;      &lt;chr&gt;               &lt;dbl&gt;        &lt;dbl&gt;                 &lt;dbl&gt;\n 1 California Los Angeles      10038388         10                1003839.\n 2 Illinois   Cook              5236393         10.7               560294.\n 3 Texas      Harris            4356362          7.5               326727.\n 4 Arizona    Maricopa          4018143          7.7               309397.\n 5 California Riverside         2298032         12.9               296446.\n 6 California San Diego         3223096          8.7               280409.\n 7 Michigan   Wayne             1778969         14.9               265066.\n 8 California San Bernardino    2094769         12.6               263941.\n 9 Florida    Miami-Dade        2639042         10                 263904.\n10 New York   Kings             2595259         10                 259526.\n# ℹ 3,128 more rows\n\n# var olan sütunu güncelle\ncounties %&gt;%\n  select(state, county, population, men,women) %&gt;% \nmutate(population = men + women)\n\n# A tibble: 3,138 × 5\n   state   county   population   men women\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Alabama Autauga       55221 26745 28476\n 2 Alabama Baldwin      195121 95314 99807\n 3 Alabama Barbour       26932 14497 12435\n 4 Alabama Bibb          22604 12073 10531\n 5 Alabama Blount        57710 28512 29198\n 6 Alabama Bullock       10678  5660  5018\n 7 Alabama Butler        20354  9502 10852\n 8 Alabama Calhoun      116648 56274 60374\n 9 Alabama Chambers      34079 16258 17821\n10 Alabama Cherokee      26008 12975 13033\n# ℹ 3,128 more rows\n\n# birden fazla yeni değişken üretme\ncounties %&gt;%\n  select(state, county, population, men,women) %&gt;% \nmutate(men_ratio = men/population*100,\n       women_ratio = women/population*100)\n\n# A tibble: 3,138 × 7\n   state   county   population   men women men_ratio women_ratio\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Alabama Autauga       55221 26745 28476      48.4        51.6\n 2 Alabama Baldwin      195121 95314 99807      48.8        51.2\n 3 Alabama Barbour       26932 14497 12435      53.8        46.2\n 4 Alabama Bibb          22604 12073 10531      53.4        46.6\n 5 Alabama Blount        57710 28512 29198      49.4        50.6\n 6 Alabama Bullock       10678  5660  5018      53.0        47.0\n 7 Alabama Butler        20354  9502 10852      46.7        53.3\n 8 Alabama Calhoun      116648 56274 60374      48.2        51.8\n 9 Alabama Chambers      34079 16258 17821      47.7        52.3\n10 Alabama Cherokee      26008 12975 13033      49.9        50.1\n# ℹ 3,128 more rows\n\n# transmute sadece yeni eklenen değişkenleri gösterir\n\ncounties %&gt;%\n  select(state, county, population, men,women) %&gt;% \ntransmute(men_ratio = men/population*100,\n       women_ratio = women/population*100)\n\n# A tibble: 3,138 × 2\n   men_ratio women_ratio\n       &lt;dbl&gt;       &lt;dbl&gt;\n 1      48.4        51.6\n 2      48.8        51.2\n 3      53.8        46.2\n 4      53.4        46.6\n 5      49.4        50.6\n 6      53.0        47.0\n 7      46.7        53.3\n 8      48.2        51.8\n 9      47.7        52.3\n10      49.9        50.1\n# ℹ 3,128 more rows\n\n# mutate_at ile koşula göre birden fazla değişkene aynı fonksiyon uygulanabilir.\nscale2 &lt;- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)\n\ncounties_selected %&gt;% \n  mutate_at(c(\"population\",\"unemployment\"),scale2)\n\n# A tibble: 3,138 × 4\n   state   county   population unemployment\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama Autauga     -0.141       -0.0563\n 2 Alabama Baldwin      0.292       -0.0846\n 3 Alabama Barbour     -0.228        2.78  \n 4 Alabama Bibb        -0.242        0.142 \n 5 Alabama Blount      -0.133       -0.0279\n 6 Alabama Bullock     -0.278        2.89  \n 7 Alabama Butler      -0.249        0.880 \n 8 Alabama Calhoun      0.0495       1.28  \n 9 Alabama Chambers    -0.206        0.313 \n10 Alabama Cherokee    -0.231        0.0288\n# ℹ 3,128 more rows\n\ncounties_selected %&gt;% # birden fazla argüman kullanımı\n  mutate_at(c(\"population\",\"unemployment\"),scale2,na.rm = TRUE)\n\n# A tibble: 3,138 × 4\n   state   county   population unemployment\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama Autauga     -0.141       -0.0563\n 2 Alabama Baldwin      0.292       -0.0846\n 3 Alabama Barbour     -0.228        2.78  \n 4 Alabama Bibb        -0.242        0.142 \n 5 Alabama Blount      -0.133       -0.0279\n 6 Alabama Bullock     -0.278        2.89  \n 7 Alabama Butler      -0.249        0.880 \n 8 Alabama Calhoun      0.0495       1.28  \n 9 Alabama Chambers    -0.206        0.313 \n10 Alabama Cherokee    -0.231        0.0288\n# ℹ 3,128 more rows\n\n# mutate_if ile koşula göre birden fazla değişkende değişiklik yapılabilir.\nstr(counties_selected)\n\nspc_tbl_ [3,138 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ state       : chr [1:3138] \"Alabama\" \"Alabama\" \"Alabama\" \"Alabama\" ...\n $ county      : chr [1:3138] \"Autauga\" \"Baldwin\" \"Barbour\" \"Bibb\" ...\n $ population  : num [1:3138] 55221 195121 26932 22604 57710 ...\n $ unemployment: num [1:3138] 7.6 7.5 17.6 8.3 7.7 18 10.9 12.3 8.9 7.9 ...\n\ncounties_selected &lt;- counties_selected %&gt;% \n  mutate_if(is.character,as.factor)\n\nstr(counties_selected)\n\nspc_tbl_ [3,138 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ state       : Factor w/ 50 levels \"Alabama\",\"Alaska\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ county      : Factor w/ 1847 levels \"Abbeville\",\"Acadia\",..: 82 89 100 149 164 225 235 246 293 315 ...\n $ population  : num [1:3138] 55221 195121 26932 22604 57710 ...\n $ unemployment: num [1:3138] 7.6 7.5 17.6 8.3 7.7 18 10.9 12.3 8.9 7.9 ...\n\ncounties_selected %&gt;% \n  mutate_if(is.numeric, scale2, na.rm = TRUE)\n\n# A tibble: 3,138 × 4\n   state   county   population unemployment\n   &lt;fct&gt;   &lt;fct&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama Autauga     -0.141       -0.0563\n 2 Alabama Baldwin      0.292       -0.0846\n 3 Alabama Barbour     -0.228        2.78  \n 4 Alabama Bibb        -0.242        0.142 \n 5 Alabama Blount      -0.133       -0.0279\n 6 Alabama Bullock     -0.278        2.89  \n 7 Alabama Butler      -0.249        0.880 \n 8 Alabama Calhoun      0.0495       1.28  \n 9 Alabama Chambers    -0.206        0.313 \n10 Alabama Cherokee    -0.231        0.0288\n# ℹ 3,128 more rows\n\n\n\n\n\n\n\n\nDikkat\n\n\n\nmutate() ve transmute() fonksiyonları, dplyr paketinde veri çerçevelerini işlerken kullanılan iki farklı fonksiyondur. Her ikisi de yeni sütunlar oluşturmanıza veya mevcut sütunları dönüştürmenize olanak tanır, ancak aralarındaki temel fark işlevlerinin dönüş değerleridir. Ancak kullanırken aşağıda belirtilen hususlara dikkat etmek gerekir:\n\nmutate(), veri çerçevesine yeni sütunlar eklerken, orijinal veri çerçevesini değiştirmez. Yani, yeni sütunlar eklerken orijinal veri çerçevesinin boyutu artar. mutate() fonksiyonu, orijinal veri çerçevesini döndürürken eklenen sütunlarla birlikte veriyi içeren yeni bir veri çerçevesi döndürür.\ntransmute(), yeni sütunlar oluştururken orijinal veri çerçevesini değiştirmez. Ancak, transmute() fonksiyonu yalnızca belirtilen sütunları ve yeni sütunları içeren bir veri çerçevesi döndürür. Diğer orijinal sütunlar bu yeni veri çerçevesinde yer almaz. Bu, veri çerçevesini daha küçük ve özgünleştirilmiş bir hale getirir.\n\n\n\n\nKoşullu Değişken Oluşturma - case_when\ncase_when() fonksiyonu, R programlama dilinde dplyr paketi içinde bulunan ve çoklu koşullara dayalı olarak yeni bir sütun oluşturmak veya mevcut bir sütunu dönüştürmek için kullanılan bir fonksiyondur. Bu fonksiyon, özellikle veri çerçevelerinde veya veri tablolarında, belirli koşullara dayalı olarak işlem yapmanız gerektiğinde oldukça kullanışlıdır. case_when() fonksiyonu, birden fazla koşulu kontrol ederek her bir koşula uygun bir değer veya işlem döndürmenizi sağlar. case_when() fonksiyonu, bir veya daha fazla koşul ifadesi ve bu koşullara karşılık gelecek değerler içeren çiftlerin bir listesini alır. Bu çiftler, ~ operatörü ile ayrılır.\n\n# Örnek bir veri çerçevesi oluşturalım\nveri &lt;- data.frame(\n  Ogrenci_Ad = c(\"Ali\", \"Esra\", \"Erkan\", \"Derya\"),\n  Puan = c(90, 75, 60, 80)\n)\n\n# Yeni bir sütun oluşturma: Puan kategorisi\nveri &lt;- veri %&gt;%\n  mutate(Puan_Kategorisi = case_when(\n    Puan &gt;= 90 ~ \"AA\",\n    Puan &gt;= 80 ~ \"BA\",\n    Puan &gt;= 70 ~ \"BB\",\n    Puan &gt;= 60 ~ \"CB\",\n    TRUE ~ \"FF\"  # Tüm diğer durumlar için\n  ))\n\nprint(veri)\n\n  Ogrenci_Ad Puan Puan_Kategorisi\n1        Ali   90              AA\n2       Esra   75              BB\n3      Erkan   60              CB\n4      Derya   80              BA\n\n\ncase_when() fonksiyonunu birden fazla koşul ile kullanabilirsiniz. Koşullar yukarıdan aşağıya sırayla kontrol edilir ve ilk koşulu sağlayan değer kullanılır.\n\nveri &lt;- veri %&gt;%\n  mutate(Not_Durumu = case_when(\n    Puan &gt;= 90 ~ \"Geçti\",\n    Puan &gt;= 60 & Puan &lt; 70 ~ \"Şartlı Geçti\",\n    Puan &lt; 60 ~ \"Kaldı\",\n    TRUE ~ \"Bilinmiyor\"  # Tüm diğer durumlar için\n  ))\n\nveri\n\n  Ogrenci_Ad Puan Puan_Kategorisi   Not_Durumu\n1        Ali   90              AA        Geçti\n2       Esra   75              BB   Bilinmiyor\n3      Erkan   60              CB Şartlı Geçti\n4      Derya   80              BA   Bilinmiyor",
    "crumbs": [
      "Veri Manipulasyonu"
    ]
  },
  {
    "objectID": "data_manipulation.html#değişken-isimlendirme---rename",
    "href": "data_manipulation.html#değişken-isimlendirme---rename",
    "title": "Veri Manipulasyonu",
    "section": "Değişken İsimlendirme - rename",
    "text": "Değişken İsimlendirme - rename\nrename() fonksiyonu, R programlama dilinde veri çerçevesi içindeki sütunların adlarını değiştirmek için kullanılır. Veri çerçevesi sütunlarının daha açıklayıcı veya kullanıcı dostu adlara sahip olmasını sağlar. Bu, veri analizi ve raporlama süreçlerini daha anlaşılır ve düzenli hale getirmenize yardımcı olabilir.\n\n# yeniden isimlendirmede eşitliği sol tarafı yeni isim olmalı\ncounties_selected %&gt;%\nrename(unemployment_rate = unemployment)\n\n# A tibble: 3,138 × 4\n   state   county   population unemployment_rate\n   &lt;fct&gt;   &lt;fct&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Alabama Autauga       55221               7.6\n 2 Alabama Baldwin      195121               7.5\n 3 Alabama Barbour       26932              17.6\n 4 Alabama Bibb          22604               8.3\n 5 Alabama Blount        57710               7.7\n 6 Alabama Bullock       10678              18  \n 7 Alabama Butler        20354              10.9\n 8 Alabama Calhoun      116648              12.3\n 9 Alabama Chambers      34079               8.9\n10 Alabama Cherokee      26008               7.9\n# ℹ 3,128 more rows\n\n# select ile beraber de yeniden isimlendirme yapılabilir\ncounties_selected %&gt;%\nselect(state, county, population, unemployment_rate = unemployment)\n\n# A tibble: 3,138 × 4\n   state   county   population unemployment_rate\n   &lt;fct&gt;   &lt;fct&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Alabama Autauga       55221               7.6\n 2 Alabama Baldwin      195121               7.5\n 3 Alabama Barbour       26932              17.6\n 4 Alabama Bibb          22604               8.3\n 5 Alabama Blount        57710               7.7\n 6 Alabama Bullock       10678              18  \n 7 Alabama Butler        20354              10.9\n 8 Alabama Calhoun      116648              12.3\n 9 Alabama Chambers      34079               8.9\n10 Alabama Cherokee      26008               7.9\n# ℹ 3,128 more rows\n\n\n\n\n\n\n\n\nDikkat\n\n\n\nrename fonksiyonunda eşitliğin sol tarafına yeni isim, sağ tarafına ise önceki isim yazılır.",
    "crumbs": [
      "Veri Manipulasyonu"
    ]
  },
  {
    "objectID": "data_manipulation.html#verileri-sayma---count",
    "href": "data_manipulation.html#verileri-sayma---count",
    "title": "Veri Manipulasyonu",
    "section": "Verileri Sayma - count",
    "text": "Verileri Sayma - count\ncount() fonksiyonu, R programlama dilindeki dplyr paketinde bulunan ve belirli bir sütuna göre veri çerçevesindeki gözlemlerin sayısını hesaplamak için kullanılan bir fonksiyondur. Bu fonksiyon, veri çerçevesindeki belirli bir kategorik değişkenin benzersiz değerlerini ve her bir değer için kaç gözlemin olduğunu hesaplamak için oldukça kullanışlıdır.\ncount() fonksiyonu, veri analizi sürecinde veri özeti oluşturmak ve belirli bir değişkenin frekansını görmek için sıkça kullanılır. Ayrıca, veri çerçevesindeki her bir kategorik değeri ve bu değerlere ait gözlem sayılarını içeren yeni bir veri çerçevesi döndürür.\n\n# count ile veri setinde sayma işlemleri yapılır\ncounties %&gt;%\ncount()\n\n# A tibble: 1 × 1\n      n\n  &lt;int&gt;\n1  3138\n\n# state dağılımını elde etmek\ncounties %&gt;%\ncount(state)\n\n# A tibble: 50 × 2\n   state           n\n   &lt;chr&gt;       &lt;int&gt;\n 1 Alabama        67\n 2 Alaska         28\n 3 Arizona        15\n 4 Arkansas       75\n 5 California     58\n 6 Colorado       64\n 7 Connecticut     8\n 8 Delaware        3\n 9 Florida        67\n10 Georgia       159\n# ℹ 40 more rows\n\n# sort = TRUE ile büyükten küçüge sıralama yapılabilir\ncounties %&gt;%\ncount(state, sort = TRUE)\n\n# A tibble: 50 × 2\n   state              n\n   &lt;chr&gt;          &lt;int&gt;\n 1 Texas            253\n 2 Georgia          159\n 3 Virginia         133\n 4 Kentucky         120\n 5 Missouri         115\n 6 Kansas           105\n 7 Illinois         102\n 8 North Carolina   100\n 9 Iowa              99\n10 Tennessee         95\n# ℹ 40 more rows\n\n# wt argümanı ile değişken toplamları hesaplanabilir\ncounties %&gt;%\ncount(state, wt = population, sort = TRUE)\n\n# A tibble: 50 × 2\n   state                 n\n   &lt;chr&gt;             &lt;dbl&gt;\n 1 California     38421464\n 2 Texas          26538497\n 3 New York       19673174\n 4 Florida        19645772\n 5 Illinois       12873761\n 6 Pennsylvania   12779559\n 7 Ohio           11575977\n 8 Georgia        10006693\n 9 Michigan        9900571\n10 North Carolina  9845333\n# ℹ 40 more rows",
    "crumbs": [
      "Veri Manipulasyonu"
    ]
  },
  {
    "objectID": "data_manipulation.html#veri-özetleme---summarize",
    "href": "data_manipulation.html#veri-özetleme---summarize",
    "title": "Veri Manipulasyonu",
    "section": "Veri Özetleme - summarize",
    "text": "Veri Özetleme - summarize\ngroup_by() ve summarize() fonksiyonları, R programlama dilinde veri çerçevesi üzerinde gruplama ve özetleme işlemleri yapmak için kullanılan önemli dplyr fonksiyonlarıdır. Bu fonksiyonlar, veri analizi sürecinde verilerinizi daha iyi anlamak ve özetlemek için oldukça güçlü araçlardır.\ngroup_by() fonksiyonu, veri çerçevesindeki verileri belirli bir sütuna veya birden fazla sütuna göre gruplamak için kullanılır. Bu gruplandırma işlemi, veriyi belirli bir kategoriye veya sınıfa göre ayırmak için kullanılır.\nsummarize() fonksiyonu, gruplanmış veri üzerinde istatistiksel veya özetleyici işlemler yapmak için kullanılır. Bu fonksiyon, belirli bir grup için özet bilgileri hesaplamak için kullanılır.\n\ncounties %&gt;%\nsummarize(total_population = sum(population))\n\n# A tibble: 1 × 1\n  total_population\n             &lt;dbl&gt;\n1        315845353\n\ncounties %&gt;%\nsummarize(total_population = sum(population),\naverage_unemployment = mean(unemployment))\n\n# A tibble: 1 × 2\n  total_population average_unemployment\n             &lt;dbl&gt;                &lt;dbl&gt;\n1        315845353                 7.80\n\n# istenilen düzeye göre hesaplamalar group_by ile yapılır\ncounties %&gt;%\ngroup_by(state) %&gt;%\nsummarize(total_pop = sum(population),\naverage_unemployment = sum(unemployment))\n\n# A tibble: 50 × 3\n   state       total_pop average_unemployment\n   &lt;chr&gt;           &lt;dbl&gt;                &lt;dbl&gt;\n 1 Alabama       4830620                758. \n 2 Alaska         725461                257. \n 3 Arizona       6641928                180. \n 4 Arkansas      2958208                674. \n 5 California   38421464                626. \n 6 Colorado      5278906                477. \n 7 Connecticut   3593222                 65.3\n 8 Delaware       926454                 23.8\n 9 Florida      19645772                696. \n10 Georgia      10006693               1586. \n# ℹ 40 more rows\n\ncounties %&gt;%\ngroup_by(state) %&gt;%\nsummarize(total_pop = sum(population),\naverage_unemployment = mean(unemployment)) %&gt;%\narrange(desc(average_unemployment))\n\n# A tibble: 50 × 3\n   state          total_pop average_unemployment\n   &lt;chr&gt;              &lt;dbl&gt;                &lt;dbl&gt;\n 1 Mississippi      2988081                12.0 \n 2 Arizona          6641928                12.0 \n 3 South Carolina   4777576                11.3 \n 4 Alabama          4830620                11.3 \n 5 California      38421464                10.8 \n 6 Nevada           2798636                10.5 \n 7 North Carolina   9845333                10.5 \n 8 Florida         19645772                10.4 \n 9 Georgia         10006693                 9.97\n10 Michigan         9900571                 9.96\n# ℹ 40 more rows\n\n# birden fazla değişken düzeyinde gruplama\ncounties %&gt;%\ngroup_by(state, metro) %&gt;%\nsummarize(total_pop = sum(population))\n\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 97 × 3\n# Groups:   state [50]\n   state      metro    total_pop\n   &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;\n 1 Alabama    Metro      3671377\n 2 Alabama    Nonmetro   1159243\n 3 Alaska     Metro       494990\n 4 Alaska     Nonmetro    230471\n 5 Arizona    Metro      6295145\n 6 Arizona    Nonmetro    346783\n 7 Arkansas   Metro      1806867\n 8 Arkansas   Nonmetro   1151341\n 9 California Metro     37587429\n10 California Nonmetro    834035\n# ℹ 87 more rows\n\n# elde edilen veri üzerinden devam edilecekse ungroup kullanılmalı.\n# ungroup kullanılmazsa sonradan yapılan işlemler group_by değişkenleri düzeyinde\n# devam eder\n\ncounties %&gt;%\ngroup_by(state, metro) %&gt;%\nsummarize(total_pop = sum(population)) %&gt;%\nungroup()\n\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 97 × 3\n   state      metro    total_pop\n   &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;\n 1 Alabama    Metro      3671377\n 2 Alabama    Nonmetro   1159243\n 3 Alaska     Metro       494990\n 4 Alaska     Nonmetro    230471\n 5 Arizona    Metro      6295145\n 6 Arizona    Nonmetro    346783\n 7 Arkansas   Metro      1806867\n 8 Arkansas   Nonmetro   1151341\n 9 California Metro     37587429\n10 California Nonmetro    834035\n# ℹ 87 more rows\n\n# top_n en yüksek ya da en düşük sonuçları listeleme\ncounties_selected %&gt;%\ngroup_by(state) %&gt;%\ntop_n(1, population) # her eyaletteki en yüksek nüfuslu yer\n\n# A tibble: 50 × 4\n# Groups:   state [50]\n   state       county                 population unemployment\n   &lt;fct&gt;       &lt;fct&gt;                       &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama     Jefferson                  659026          9.1\n 2 Alaska      Anchorage Municipality     299107          6.7\n 3 Arizona     Maricopa                  4018143          7.7\n 4 Arkansas    Pulaski                    390463          7.5\n 5 California  Los Angeles              10038388         10  \n 6 Colorado    El Paso                    655024          8.4\n 7 Connecticut Fairfield                  939983          9  \n 8 Delaware    New Castle                 549643          7.4\n 9 Florida     Miami-Dade                2639042         10  \n10 Georgia     Fulton                     983903          9.9\n# ℹ 40 more rows\n\ncounties_selected %&gt;%\ngroup_by(state) %&gt;%\ntop_n(-1, population) # her eyaletteki en düşük nüfuslu yer\n\n# A tibble: 50 × 4\n# Groups:   state [50]\n   state       county                   population unemployment\n   &lt;fct&gt;       &lt;fct&gt;                         &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama     Greene                         8697         20.4\n 2 Alaska      Yakutat City and Borough        643          7.9\n 3 Arizona     Greenlee                       9023         10  \n 4 Arkansas    Calhoun                        5245          7.2\n 5 California  Alpine                         1131         10.7\n 6 Colorado    San Juan                        606         13.8\n 7 Connecticut Windham                      117470          9.3\n 8 Delaware    Kent                         169509          8.4\n 9 Florida     Liberty                        8295         10.2\n10 Georgia     Taliaferro                     1721         12.1\n# ℹ 40 more rows\n\ncounties_selected %&gt;%\ngroup_by(state) %&gt;%\ntop_n(2, population) # her eyaletteki en yüksek nüfuslu 2 yer\n\n# A tibble: 100 × 4\n# Groups:   state [50]\n   state      county                       population unemployment\n   &lt;fct&gt;      &lt;fct&gt;                             &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama    Jefferson                        659026          9.1\n 2 Alabama    Mobile                           414251          9.8\n 3 Alaska     Anchorage Municipality           299107          6.7\n 4 Alaska     Fairbanks North Star Borough      99705          7.9\n 5 Arizona    Maricopa                        4018143          7.7\n 6 Arizona    Pima                             998537         10  \n 7 Arkansas   Benton                           238198          4.2\n 8 Arkansas   Pulaski                          390463          7.5\n 9 California Los Angeles                    10038388         10  \n10 California San Diego                       3223096          8.7\n# ℹ 90 more rows\n\n# summarise_all bütün değişkenler için özetleme yapar\ncounties_selected %&gt;% summarise_all(nlevels)\n\n# A tibble: 1 × 4\n  state county population unemployment\n  &lt;int&gt;  &lt;int&gt;      &lt;int&gt;        &lt;int&gt;\n1    50   1847          0            0\n\ncounties_selected %&gt;% \n  select(-county) %&gt;% \n  group_by(state) %&gt;% \n  summarise_all(mean)\n\n# A tibble: 50 × 3\n   state       population unemployment\n   &lt;fct&gt;            &lt;dbl&gt;        &lt;dbl&gt;\n 1 Alabama         72099.        11.3 \n 2 Alaska          25909.         9.19\n 3 Arizona        442795.        12.0 \n 4 Arkansas        39443.         8.98\n 5 California     662439.        10.8 \n 6 Colorado        82483.         7.46\n 7 Connecticut    449153.         8.16\n 8 Delaware       308818          7.93\n 9 Florida        293220.        10.4 \n10 Georgia         62935.         9.97\n# ℹ 40 more rows\n\n# summarise_at belli değişkenler için özetleme yapar\ncounties_selected %&gt;% \n  select(-county) %&gt;% \n  group_by(state) %&gt;% \n  summarise_at(\"population\",mean)\n\n# A tibble: 50 × 2\n   state       population\n   &lt;fct&gt;            &lt;dbl&gt;\n 1 Alabama         72099.\n 2 Alaska          25909.\n 3 Arizona        442795.\n 4 Arkansas        39443.\n 5 California     662439.\n 6 Colorado        82483.\n 7 Connecticut    449153.\n 8 Delaware       308818 \n 9 Florida        293220.\n10 Georgia         62935.\n# ℹ 40 more rows\n\n# summarise_if ile koşula göre özetleme yapar\ncounties_selected %&gt;% \n  summarize_if(is.numeric, mean, na.rm = TRUE)\n\n# A tibble: 1 × 2\n  population unemployment\n       &lt;dbl&gt;        &lt;dbl&gt;\n1    100652.         7.80\n\n\n\n\n\n\n\n\nDikkat\n\n\n\nungroup() fonksiyonu, dplyr paketinde kullanılan bir işlevdir ve bir veri çerçevesini veya gruplanmış bir veri çerçevesini gruplardan çıkarmak için kullanılır. group_by() fonksiyonu ile gruplanmış bir veri çerçevesini oluşturduğunuzda, veri çerçevesi belirli sütunlar üzerinde gruplama yapar ve her grup için ayrı işlemler yapmanıza olanak tanır. Ancak bazen gruplamadan çıkmak ve orijinal veri çerçevesini elde etmek isteyebilirsiniz.\n\n\n\n# Örnek bir veri çerçevesi oluşturalım\nveri &lt;- data.frame(\n  Sehir = c(\"İstanbul\", \"Ankara\", \"İstanbul\", \"Ankara\", \"İzmir\"),\n  Cinsiyet = c(\"Erkek\", \"Kadın\", \"Erkek\", \"Kadın\", \"Erkek\"),\n  Yas = c(28, 32, 22, 24, 30),\n  Puan = c(90, 85, 78, 92, 88)\n)\n\n# Şehir sütununa göre veriyi grupla\ngruplu_veri &lt;- group_by(veri, Sehir)\ngruplu_veri |&gt; summarise(mean(Puan))\n\n# A tibble: 3 × 2\n  Sehir    `mean(Puan)`\n  &lt;chr&gt;           &lt;dbl&gt;\n1 Ankara           88.5\n2 İstanbul         84  \n3 İzmir            88  \n\n# Grubu çıkarma\ngruplu_veri &lt;- ungroup(gruplu_veri)\ngruplu_veri |&gt; summarise(mean(Puan))\n\n# A tibble: 1 × 1\n  `mean(Puan)`\n         &lt;dbl&gt;\n1         86.6\n\n\nAynı veri setinde farklı sonuçlar elde edildiğine dikkat edelim. Eğer group_by ile oluşturulan veri setinde başka işlemler yapacaksanız öncesinde ungroup() yapmayı ihmal etmeyin.\n\n\n\n\n\n\nNot\n\n\n\ngroup_by sadece summarize fonksiyonu ile değil mutate, transmute gibi diğer fonksiyonlar ile birlikte de kullanılabilir.",
    "crumbs": [
      "Veri Manipulasyonu"
    ]
  },
  {
    "objectID": "data_join.html",
    "href": "data_join.html",
    "title": "Veri Birleştirme",
    "section": "",
    "text": "Kullanacağımız Veri Setleri\nVeri analizi sürecinde, çoğu zaman birden fazla tabloyu ortak bir anahtar üzerinden birleştirmemiz gerekir.\nBu işlem, farklı kaynaklardaki bilgileri tek bir veri yapısında bütünleştirmemizi sağlar.\nÖrneğin, bir tabloda müşteri bilgileri, diğerinde sipariş bilgileri olabilir; analiz yapmak için bu tabloları birleştirmemiz gerekir.\nR’da veri birleştirme işlemleri hem base R fonksiyonları (merge()) hem de dplyr paketindeki join fonksiyonları (left_join(), inner_join(), vb.) ile yapılabilir. Bu bölümde iki yaklaşımı da aynı veri seti üzerinden adım adım göstereceğiz.\nBu bölümde nycflights13 paketindeki veri setlerini kullanacağız. Bu paket, 2013 yılı New York uçuş verilerini içerir ve ilişkisel yapıdadır. Yani birkaç tablo, ortak anahtarlar aracılığıyla birbirine bağlanabilir.\nlibrary(dplyr)\nlibrary(nycflights13)\nglimpse(flights)\n\nRows: 336,776\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\nglimpse(airlines)\n\nRows: 16\nColumns: 2\n$ carrier &lt;chr&gt; \"9E\", \"AA\", \"AS\", \"B6\", \"DL\", \"EV\", \"F9\", \"FL\", \"HA\", \"MQ\", \"O…\n$ name    &lt;chr&gt; \"Endeavor Air Inc.\", \"American Airlines Inc.\", \"Alaska Airline…\n\nglimpse(airports)\n\nRows: 1,458\nColumns: 8\n$ faa   &lt;chr&gt; \"04G\", \"06A\", \"06C\", \"06N\", \"09J\", \"0A9\", \"0G6\", \"0G7\", \"0P2\", \"…\n$ name  &lt;chr&gt; \"Lansdowne Airport\", \"Moton Field Municipal Airport\", \"Schaumbur…\n$ lat   &lt;dbl&gt; 41.13047, 32.46057, 41.98934, 41.43191, 31.07447, 36.37122, 41.4…\n$ lon   &lt;dbl&gt; -80.61958, -85.68003, -88.10124, -74.39156, -81.42778, -82.17342…\n$ alt   &lt;dbl&gt; 1044, 264, 801, 523, 11, 1593, 730, 492, 1000, 108, 409, 875, 10…\n$ tz    &lt;dbl&gt; -5, -6, -6, -5, -5, -5, -5, -5, -5, -8, -5, -6, -5, -5, -5, -5, …\n$ dst   &lt;chr&gt; \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"U\", \"A\", \"A\", \"U\", \"A\",…\n$ tzone &lt;chr&gt; \"America/New_York\", \"America/Chicago\", \"America/Chicago\", \"Ameri…",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#kullanacağımız-veri-setleri",
    "href": "data_join.html#kullanacağımız-veri-setleri",
    "title": "Veri Birleştirme",
    "section": "",
    "text": "Tablo\nİçerik\nAnahtar Değişken\nKayıt Sayısı\nSütun Sayısı\n\n\n\n\nflights\nUçuş detayları\ncarrier, dest\n336776\n19\n\n\nairlines\nHavayolu adları\ncarrier\n16\n2\n\n\nairports\nHavaalanı bilgileri\nfaa\n1458\n8",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#anahtar-değişken-nedir",
    "href": "data_join.html#anahtar-değişken-nedir",
    "title": "Veri Birleştirme",
    "section": "Anahtar Değişken Nedir?",
    "text": "Anahtar Değişken Nedir?\nBirleştirme işlemlerinde kullanılan sütunlara anahtar değişken denir. Bu değişkenler, iki tablo arasında eşleştirmeyi sağlar. Örneğin:\n\nflights tablosundaki carrier, airlines tablosundaki carrier ile eşleştirilir.\nflights tablosundaki dest, airports tablosundaki faa ile eşleştirilir.\n\n\n\n\n\n\n\nNote\n\n\n\nAnahtar Değişken Özellikleri\n\nİki tabloda da aynı bilgiyi temsil eder.\nVeri tipleri uyumlu olmalıdır (örneğin, her ikisi de karakter olmalı).\nTekil veya tekrar eden değerler içerebilir. Tekrarlara göre ilişki türü (1–1, 1–N, N–M) belirlenir.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#join-kavramı-ve-türleri",
    "href": "data_join.html#join-kavramı-ve-türleri",
    "title": "Veri Birleştirme",
    "section": "Join Kavramı ve Türleri",
    "text": "Join Kavramı ve Türleri\n\nJoin Nedir?\nJoin, iki veya daha fazla veri tablosunu ortak bir anahtar üzerinden birleştirme işlemidir. Sonuçta, tablolar tek bir veri çerçevesinde birleştirilir. Join türleri, hangi satırların korunacağına veya eleneceğine göre farklılık gösterir.\n\n\n\n\n\n\n\n\nJoin Türü\nTanım\nTutulan Satırlar\n\n\n\n\nleft_join\nSoldaki tüm satırları korur, sağdan eşleşenleri getirir\nTüm sol tablo\n\n\ninner_join\nHer iki tabloda eşleşen satırları getirir\nOrtak anahtarlar\n\n\nright_join\nSağdaki tüm satırları korur\nTüm sağ tablo\n\n\nfull_join\nHer iki tablodaki tüm satırları birleştirir\nHer iki tablo\n\n\nsemi_join\nSadece sol tablodan, eşleşen satırların alt kümesini getirir\nSol tablo (eşleşenler)\n\n\nanti_join\nSol tablodan, eşleşmeyen satırları getirir\nSol tablo (eşleşmeyenler)\n\n\n\n\n\nKardinalite (İlişki Türü)\nİki tablo arasındaki ilişki, anahtar değişkenlerin yapısına bağlıdır:\n\n\n\n\n\n\n\n\nİlişki Türü\nTanım\nÖrnek\n\n\n\n\n1–1 (bire bir)\nHer anahtar her tabloda bir kez geçer\nT.C. kimlik numarası ↔︎ kişi\n\n\n1–N (bire çok)\nSol tablo tekil, sağ tablo tekrar içerir\nHavayolu ↔︎ Uçuşlar\n\n\nN–M (çoktan çok)\nHer iki tabloda da tekrarlar vardır\nÖğrenci ↔︎ Ders\n\n\n\nBu durum, birleştirme sonrası satır sayısını doğrudan etkiler. Örneğin 1–N ilişkisinde satır sayısı artabilir.\n\n\nR’de Join Yaklaşımları\nR dilinde iki temel yaklaşım vardır:\n\n\n\n\n\n\n\n\nYaklaşım\nFonksiyon\nPaket\n\n\n\n\nBase R\nmerge()\nTemel R\n\n\nTidyverse\nleft_join(), inner_join(), right_join(), full_join(), semi_join(), anti_join()\ndplyr\n\n\n\n\n\n\n\n\n\nNote\n\n\n\ndplyr fonksiyonları daha okunabilir, tutarlı, ve pipe (%&gt;%) yapısı ile çalışmaya uygundur.\nAncak merge() hâlâ birçok eski kodda ve küçük projelerde yaygın biçimde kullanılır.\nBu yüzden bu bölümde her iki yöntemi de göreceğiz.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#left-join",
    "href": "data_join.html#left-join",
    "title": "Veri Birleştirme",
    "section": "Left Join",
    "text": "Left Join\nleft_join() veya merge(..., all.x = TRUE) işlemleri, soldaki tablodaki tüm satırları koruyup, sağdaki tablodan yalnızca eşleşen kayıtları ekler. Bu en sık kullanılan birleştirme türüdür; çünkü genellikle “asıl veri setini” korumak isteriz.\nAmaç: Her uçuşun carrier bilgisine karşılık gelen havayolu adını ekleyelim. Yani flights tablosundaki carrier değişkenini, airlines tablosundaki carrier ile eşleştireceğiz.\nBeklenti\n\nSatır sayısı flights ile aynı kalmalı.\nEşleşmeyen carrier değerleri varsa NA gözükecek.\nSonuçta yeni sütun: name (= havayolu adı).\n\n\n\nfl_joined &lt;- flights %&gt;%\n  left_join(airlines, by = \"carrier\")\n\n# Satır sayısı değişti mi?\ntibble(\n  onceki = nrow(flights),\n  sonraki = nrow(fl_joined)\n)\n\n# A tibble: 1 × 2\n  onceki sonraki\n   &lt;int&gt;   &lt;int&gt;\n1 336776  336776\n\n\nSonuç değişmedi: left_join() soldaki tabloyu (flights) esas alır.\nYeni değişkenleri görelim:\n\nfl_joined %&gt;%\nselect(year, month, day, carrier, name) %&gt;%\ndistinct(carrier, name) %&gt;%\narrange(carrier) %&gt;%\nhead(10)\n\n# A tibble: 10 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n\n\n\n\n\n\n\n\nNote\n\n\n\nBurada name sütunu airlines tablosundan geldi.\nEğer iki tabloda aynı isimli başka sütunlar olsaydı, dplyr otomatik olarak .x ve .y sonekleri eklerdi.\n\n\nBase R ile Aynı İşlem\nBase R’de aynı işlem merge() ile yapılır. all.x = TRUE parametresi, soldan birleştirme anlamına gelir.\n\nfl_joined_base &lt;- merge(\nflights,\nairlines,\nby = \"carrier\",\nall.x = TRUE\n)\n\n# Satır sayısı kontrolü\n\nc(before = nrow(flights), after = nrow(fl_joined_base))\n\nbefore  after \n336776 336776 \n\n\n\nhead(fl_joined_base[c(\"carrier\", \"name\")], 10)\n\n   carrier              name\n1       9E Endeavor Air Inc.\n2       9E Endeavor Air Inc.\n3       9E Endeavor Air Inc.\n4       9E Endeavor Air Inc.\n5       9E Endeavor Air Inc.\n6       9E Endeavor Air Inc.\n7       9E Endeavor Air Inc.\n8       9E Endeavor Air Inc.\n9       9E Endeavor Air Inc.\n10      9E Endeavor Air Inc.\n\n\n\n\n\n\n\n\n\n\nÖzellik\ndplyr::left_join()\nbase::merge()\n\n\n\n\nSözdizimi\nDaha okunaklı (by = \"carrier\")\nUzun, parametre odaklı\n\n\nVarsayılan\nSadece belirttiğin by üzerinden\nEğer by yoksa, ortak isimleri bulup otomatik join yapar (dikkat!)\n\n\nSonekler\n.x ve .y\n.x ve .y veya .1 ve .2\n\n\nPerformans\nGenelde daha hızlı\nBüyük veride yavaş olabilir\n\n\nOkunabilirlik\n👍\n🟡\n\n\n\n\nKüçük Deneme: Eşleşmeyen Anahtar Durumu\nVarsayalım airlines tablosundan bir satırı çıkaralım ve join yapalım; ne olur?\n\nairlines_miss &lt;- airlines %&gt;% filter(carrier != \"UA\")\nfl_test &lt;- flights %&gt;% left_join(airlines_miss, by = \"carrier\")\n\nfl_test %&gt;%\nfilter(is.na(name)) %&gt;%\ndistinct(carrier) %&gt;%\nhead()\n\n# A tibble: 1 × 1\n  carrier\n  &lt;chr&gt;  \n1 UA     \n\n\nSonuçta name = NA olan satırlar, airlines tablosunda karşılığı olmayan taşıyıcılardır.\n\n\n\n\n\n\nNote\n\n\n\nBu tip satırlar veri tutarlılığı açısından önemlidir.\nGerçek analizlerde bu tür durumlar genellikle hatalı veya eksik kod anlamına gelir.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#kısa-özet",
    "href": "data_join.html#kısa-özet",
    "title": "Veri Birleştirme",
    "section": "Kısa Özet",
    "text": "Kısa Özet\n\nleft_join(): soldaki tüm satırları korur.\nmerge(..., all.x = TRUE): aynı işlevi base R’de yapar.\nEşleşmeyen kayıtlar → NA.\nKontrol: satır sayısı değişmemeli.\nKod tabloları eklemek için en güvenli yöntemdir.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#inner-join",
    "href": "data_join.html#inner-join",
    "title": "Veri Birleştirme",
    "section": "Inner Join",
    "text": "Inner Join\ninner_join() veya merge(..., all = FALSE) işlemleri, iki tablodaki ortak anahtar değerlerine sahip satırları getirir. Yani her iki tabloda da eşleşen kayıtlar kalır; eşleşmeyenler atılır.\nAmaç: Yalnızca hem flights hem de airlines tablolarında karşılığı olan havayolu kodlarını içeren satırları tutmak.\nBeklenti\n\nSatır sayısı flights’tan daha az olabilir.\nHer iki tablodan da carrier eşleşmeyenler çıkarılır.\nNA değer olmamalıdır çünkü sadece eşleşenler alınır.\n\n\ndplyr ile Inner Join\n\nfl_inner &lt;- flights %&gt;%\n  inner_join(airlines, by = \"carrier\")\n\ntibble(\n  flights_satir = nrow(flights),\n  inner_join_satir = nrow(fl_inner)\n)\n\n# A tibble: 1 × 2\n  flights_satir inner_join_satir\n          &lt;int&gt;            &lt;int&gt;\n1        336776           336776\n\n\nGörüldüğü gibi satır sayısı azaldıysa, bazı carrier değerleri yalnızca bir tabloda var demektir. Sonuçtan küçük bir örnek:\n\nfl_inner %&gt;%\nselect(year, month, day, carrier, name) %&gt;%\ndistinct(carrier, name) %&gt;%\narrange(carrier) %&gt;%\nhead(10)\n\n# A tibble: 10 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n\n\n\n\n\n\n\n\nTip\n\n\n\ninner_join() genellikle veri kesişimlerini bulmak için kullanılır. Örneğin, yalnızca hem satış listesinde hem stok listesinde bulunan ürünleri görmek istediğinizde.\n\n\nBase R ile Inner Join\nAynı mantık merge() fonksiyonunda varsayılan olarak geçerlidir. Yani all = FALSE (veya hiç yazmazsanız) inner join anlamına gelir.\n\nfl_inner_base &lt;- merge(\nflights,\nairlines,\nby = \"carrier\",\nall = FALSE\n)\n\nc(before = nrow(flights), after = nrow(fl_inner_base))\n\nbefore  after \n336776 336776 \n\n\n\nhead(fl_inner_base[c(\"carrier\", \"name\")], 10)\n\n   carrier              name\n1       9E Endeavor Air Inc.\n2       9E Endeavor Air Inc.\n3       9E Endeavor Air Inc.\n4       9E Endeavor Air Inc.\n5       9E Endeavor Air Inc.\n6       9E Endeavor Air Inc.\n7       9E Endeavor Air Inc.\n8       9E Endeavor Air Inc.\n9       9E Endeavor Air Inc.\n10      9E Endeavor Air Inc.\n\n\n\n\n\n\n\n\n\n\nÖzellik\ndplyr::inner_join()\nbase::merge()\n\n\n\n\nVarsayılan davranış\nYalnızca eşleşenleri tutar\nAynı\n\n\nSatır sayısı\nAzalabilir\nAzalabilir\n\n\nNA değerler\nOluşmaz\nOluşmaz\n\n\nKullanım alanı\nEşleşen kayıtları filtrelemek\nEşleşen kayıtları filtrelemek\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nKısa Hatırlatma:\n\ninner_join() sadece ortak anahtarları getirir. Bir tabloda olup diğerinde olmayan kayıtlar tamamen dışlanır. Bu nedenle veri kaybı olmaması istenen durumlarda left_join() tercih edilmelidir.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#right-join-ve-full-join",
    "href": "data_join.html#right-join-ve-full-join",
    "title": "Veri Birleştirme",
    "section": "Right Join ve Full Join",
    "text": "Right Join ve Full Join\nBu iki join türü, kapsayıcı birleştirmeler olarak adlandırılır.\nAmaç, iki tablodaki tüm bilgileri korumaktır — ancak satırların hangi taraftan korunduğu değişir.\n\nRight Join\nright_join() veya merge(..., all.y = TRUE) işlemleri, sağdaki tablonun tüm satırlarını korur.\nSoldaki tablodan yalnızca eşleşen kayıtlar getirilir.\nAmaç: Tüm airlines kayıtlarını koruyalım, fakat flights tablosundan sadece eşleşenleri alalım. Bu, “sağ tarafı referans alan” bir birleştirmedir.\n\ndplyr ile Right Join\n\nfl_right &lt;- flights %&gt;%\n  right_join(airlines, by = \"carrier\")\n\ntibble(\n  flights_satir = nrow(flights),\n  airlines_satir = nrow(airlines),\n  right_join_satir = nrow(fl_right)\n)\n\n# A tibble: 1 × 3\n  flights_satir airlines_satir right_join_satir\n          &lt;int&gt;          &lt;int&gt;            &lt;int&gt;\n1        336776             16           336776\n\n\n\nfl_right %&gt;%\nselect(carrier, name) %&gt;%\ndistinct(carrier, name)\n\n# A tibble: 16 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 UA      United Air Lines Inc.      \n 2 AA      American Airlines Inc.     \n 3 B6      JetBlue Airways            \n 4 DL      Delta Air Lines Inc.       \n 5 EV      ExpressJet Airlines Inc.   \n 6 MQ      Envoy Air                  \n 7 US      US Airways Inc.            \n 8 WN      Southwest Airlines Co.     \n 9 VX      Virgin America             \n10 FL      AirTran Airways Corporation\n11 AS      Alaska Airlines Inc.       \n12 9E      Endeavor Air Inc.          \n13 F9      Frontier Airlines Inc.     \n14 HA      Hawaiian Airlines Inc.     \n15 YV      Mesa Airlines Inc.         \n16 OO      SkyWest Airlines Inc.      \n\n\n\n\n\n\n\n\nNote\n\n\n\nright_join() işlemi özellikle “kod tablosu” tarafındaki tüm değerlerin korunmasını istediğimiz durumlarda kullanılır.\nÖrneğin: tüm müşteri listesi sağda, yalnızca satış yapanlar soldaysa.\n\n\nBase R ile Right Join\nBase R’de aynı işlem merge(..., all.y = TRUE) parametresiyle yapılır.\n\nfl_right_base &lt;- merge(\nflights,\nairlines,\nby = \"carrier\",\nall.y = TRUE\n)\n\nc(before = nrow(airlines), after = nrow(fl_right_base))\n\nbefore  after \n    16 336776 \n\n\n\nhead(fl_right_base[c(\"carrier\", \"name\")], 10)\n\n   carrier              name\n1       9E Endeavor Air Inc.\n2       9E Endeavor Air Inc.\n3       9E Endeavor Air Inc.\n4       9E Endeavor Air Inc.\n5       9E Endeavor Air Inc.\n6       9E Endeavor Air Inc.\n7       9E Endeavor Air Inc.\n8       9E Endeavor Air Inc.\n9       9E Endeavor Air Inc.\n10      9E Endeavor Air Inc.\n\n\n\n\nFull Join\nfull_join() veya merge(..., all = TRUE) işlemleri, her iki tablodaki tüm anahtar değerlerini birleştirir.\nEşleşmeyen satırların bulunduğu taraflarda NA değerler oluşur.\nAmaç: flights ve airlines tablolarını tüm anahtarlarla birleştirelim. Böylece her iki tarafta olup diğerinde olmayan kayıtlar da görünür.\ndplyr ile Full Join\n\nfl_full &lt;- flights %&gt;%\nfull_join(airlines, by = \"carrier\")\n\ntibble(\nflights_satir = nrow(flights),\nairlines_satir = nrow(airlines),\nfull_join_satir = nrow(fl_full)\n)\n\n# A tibble: 1 × 3\n  flights_satir airlines_satir full_join_satir\n          &lt;int&gt;          &lt;int&gt;           &lt;int&gt;\n1        336776             16          336776\n\n\n\nfl_full %&gt;%\nselect(carrier, name) %&gt;%\ndistinct(carrier, name) %&gt;%\narrange(carrier) %&gt;%\nhead(10)\n\n# A tibble: 10 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n\n\nBase R ile Full Join\nBase R’de all = TRUE kullanıldığında full join elde edilir:\n\nfl_full_base &lt;- merge(\nflights,\nairlines,\nby = \"carrier\",\nall = TRUE\n)\n\nc(before = nrow(flights) + nrow(airlines), after = nrow(fl_full_base))\n\nbefore  after \n336792 336776 \n\n\n\nhead(fl_full_base[c(\"carrier\", \"name\")], 10)\n\n   carrier              name\n1       9E Endeavor Air Inc.\n2       9E Endeavor Air Inc.\n3       9E Endeavor Air Inc.\n4       9E Endeavor Air Inc.\n5       9E Endeavor Air Inc.\n6       9E Endeavor Air Inc.\n7       9E Endeavor Air Inc.\n8       9E Endeavor Air Inc.\n9       9E Endeavor Air Inc.\n10      9E Endeavor Air Inc.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#özet",
    "href": "data_join.html#özet",
    "title": "Veri Birleştirme",
    "section": "Özet",
    "text": "Özet\n\n\n\n\n\n\n\n\n\n\nJoin Türü\ndplyr Fonksiyonu\nBase R Eşdeğeri\nKorunan Taraf\nEşleşmeyenler\n\n\n\n\nLeft Join\nleft_join()\nmerge(..., all.x = TRUE)\nSol tablo\nSağ taraf NA\n\n\nRight Join\nright_join()\nmerge(..., all.y = TRUE)\nSağ tablo\nSol taraf NA\n\n\nFull Join\nfull_join()\nmerge(..., all = TRUE)\nHer iki tablo\nHer iki tarafta da NA olabilir\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nfull_join() verilerin iki farklı kaynaktan geldiği ve birleştirmenin tamlığı kontrol edilmek istendiği durumlarda kullanışlıdır. Örneğin: iki dönem verisini, iki kurum listesini veya iki sürümü birleştirirken.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#filtreleme-türü-joinler-semi-join-ve-anti-join",
    "href": "data_join.html#filtreleme-türü-joinler-semi-join-ve-anti-join",
    "title": "Veri Birleştirme",
    "section": "Filtreleme Türü Join’ler (Semi Join ve Anti Join)",
    "text": "Filtreleme Türü Join’ler (Semi Join ve Anti Join)\nBu iki join türü, tablo yapısını değiştirmez; yalnızca satır seçimi (filtreleme) yapar. Yani semi_join() ve anti_join() yeni sütunlar eklemez, sadece sol tablodan bazı satırları seçer. Bu işlemler SQL’de sırasıyla WHERE EXISTS ve WHERE NOT EXISTS karşılığına denktir.\n\nsemi_join()\nsemi_join() sol tablodaki satırlardan, sağ tablodaki anahtarlarla eşleşenleri tutar. Eşleşmeyen satırlar atılır. Yeni sütun eklenmez, sadece satır sayısı azalabilir.\nAmaç: flights tablosundan, airlines tablosunda karşılığı bulunan carrier kayıtlarını alalım.\n\ndplyr ile Semi Join\n\nfl_semi &lt;- flights %&gt;%\n  semi_join(airlines, by = \"carrier\")\n\ntibble(\n  flights_satir = nrow(flights),\n  semi_join_satir = nrow(fl_semi)\n)\n\n# A tibble: 1 × 2\n  flights_satir semi_join_satir\n          &lt;int&gt;           &lt;int&gt;\n1        336776          336776\n\n\n\nfl_semi %&gt;%\nselect(carrier) %&gt;%\ndistinct(carrier) %&gt;%\narrange(carrier)\n\n# A tibble: 16 × 1\n   carrier\n   &lt;chr&gt;  \n 1 9E     \n 2 AA     \n 3 AS     \n 4 B6     \n 5 DL     \n 6 EV     \n 7 F9     \n 8 FL     \n 9 HA     \n10 MQ     \n11 OO     \n12 UA     \n13 US     \n14 VX     \n15 WN     \n16 YV     \n\n\n\n\n\n\n\n\nNote\n\n\n\nsemi_join() özellikle veri filtreleme veya “kesişimde olan kayıtları koruma” amacıyla kullanılır. Örneğin, sadece aktif müşteriler listesinde bulunan siparişleri görmek istediğinizde.\n\n\nBase R ile Semi Join Benzeri İşlem\nBase R’de doğrudan semi_join() yoktur, ancak aynı etkiyi merge() veya %in% operatörüyle elde edebiliriz.\n\nfl_semi_base &lt;- subset(\nflights,\ncarrier %in% airlines$carrier\n)\n\nunique(fl_semi_base$carrier)\n\n [1] \"UA\" \"AA\" \"B6\" \"DL\" \"EV\" \"MQ\" \"US\" \"WN\" \"VX\" \"FL\" \"AS\" \"9E\" \"F9\" \"HA\" \"YV\"\n[16] \"OO\"\n\n\nYukarıdaki işlemde flights içinden sadece airlines’ta yer alan carrier değerlerine sahip satırlar alındı. Yani bu da semi_join() ile aynı sonucu verir.\n\n\n\n\n\n\n💡 Neden semi_join() Kullanılır?\n\n\n\nBazı durumlarda yalnızca bir tablodaki kayıtların, başka bir tabloda var olup olmadığını kontrol etmek isteriz.\nBu durumda inner_join() gereksiz ek sütunlar üretir, filter() ise özellikle birden fazla anahtar değişken olduğunda karmaşık hale gelir.\nsemi_join() bu iki uç arasında denge kurar ve yalnızca eşleşen satırları döndürür, ama sadece sol tablonun sütunlarını korur.\nBöylece hem daha okunaklı hem de ilişkiselliği koruyan bir filtreleme yapılmış olur.\n\n\n\n\nanti_join()\nanti_join() ise tam tersini yapar: sol tablodaki satırlardan, sağda eşleşmeyenleri getirir. Bu, veri temizliği için çok kullanışlıdır.\nAmaç: flights tablosunda olup airlines tablosunda karşılığı olmayan carrier değerlerini bulalım.\ndplyr ile Anti Join\n\nfl_anti &lt;- flights %&gt;%\n  anti_join(airlines, by = \"carrier\")\n\nfl_anti %&gt;%\nselect(carrier) %&gt;%\ndistinct()\n\n# A tibble: 0 × 1\n# ℹ 1 variable: carrier &lt;chr&gt;\n\n\nBu, flights içinde olup airlines tablosunda bulunmayan carrier kodlarını listeler. Bu, veri kalitesi kontrolünde çok işe yarar. Örneğin, flights verisinde bir carrier kodu geçiyor ama bu kod airlines tablosunda tanımlı değilse, muhtemelen bu kod hatalı ya da eski bir değerdir.\n\n\n\n\n\n\nNote\n\n\n\nanti_join() veri bütünlüğü testleri için güçlü bir araçtır.\nÖrneğin; satış tablosundaki müşteri kodlarından bazıları müşteri kayıt tablosunda yoksa bu durum veri tutarsızlığına işaret eder.\n\n\nBase R ile Anti Join Benzeri İşlem\nAynı mantığı base R’de %in% operatörüyle kurabiliriz:\n\nfl_anti_base &lt;- subset(\nflights,\n!(carrier %in% airlines$carrier)\n)\n\nunique(fl_anti_base$carrier)\n\ncharacter(0)\n\n\n\n\nÖzet\n\n\n\n\n\n\n\n\n\n\nJoin Türü\nAmaç\ndplyr Fonksiyonu\nBase R Yaklaşımı\nDönen Satırlar\n\n\n\n\nSemi Join\nEşleşenleri getirir\nsemi_join()\nsubset(..., %in%)\nSol tablodan, eşleşenler\n\n\nAnti Join\nEşleşmeyenleri getirir\nanti_join()\nsubset(..., !%in%)\nSol tablodan, eşleşmeyenler\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nÖzetle:\nBu iki fonksiyon tabloyu “filtreler”, yeni sütun eklemez.\n\nsemi_join() → ortak kayıtları bulur.\nanti_join() → eksik veya hatalı kayıtları bulur. Özellikle veri temizliği, kalite kontrolü ve kod doğrulama süreçlerinde sıklıkla kullanılır.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_join.html#join-işlemlerinde-anahtar-yönetimi",
    "href": "data_join.html#join-işlemlerinde-anahtar-yönetimi",
    "title": "Veri Birleştirme",
    "section": "Join İşlemlerinde Anahtar Yönetimi",
    "text": "Join İşlemlerinde Anahtar Yönetimi\n\n🔑 Anahtar Değişkenlerin İsimleri Farklıysa\nBazı durumlarda iki tablodaki anahtar sütunların isimleri aynı olmayabilir. Örneğin flights tablosunda dest, airports tablosunda ise faa değişkeni aynı bilgiyi temsil eder. Bu durumda, her iki tabloda da hangi sütunun kullanılacağını by argümanı ile açıkça belirtmemiz gerekir.\n✅ dplyr Örneği\n\nflights %&gt;%\n  left_join(airports, by = c(\"dest\" = \"faa\")) %&gt;%\n  select(dest, name, lat, lon) %&gt;%\n  head()\n\n# A tibble: 6 × 4\n  dest  name                              lat   lon\n  &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;\n1 IAH   George Bush Intercontinental     30.0 -95.3\n2 IAH   George Bush Intercontinental     30.0 -95.3\n3 MIA   Miami Intl                       25.8 -80.3\n4 BQN   &lt;NA&gt;                             NA    NA  \n5 ATL   Hartsfield Jackson Atlanta Intl  33.6 -84.4\n6 ORD   Chicago Ohare Intl               42.0 -87.9\n\n\nBurada \"dest\" = \"faa\" ifadesi:\n\nSol tablodaki (flights) dest sütunu,\nSağ tablodaki (airports) faa sütunu ile eşleştirileceğini belirtir.\n\n✅ Base R Örneği\nBase R’de aynı işlem şu şekilde yapılır:\n\nmerge(\nflights,\nairports,\nby.x = \"dest\",  # sol tablodaki değişken\nby.y = \"faa\",   # sağ tablodaki değişken\nall.x = TRUE\n)[c(\"dest\", \"name\", \"lat\", \"lon\")] %&gt;% head()\n\n  dest                              name      lat       lon\n1  ABQ Albuquerque International Sunport 35.04022 -106.6092\n2  ABQ Albuquerque International Sunport 35.04022 -106.6092\n3  ABQ Albuquerque International Sunport 35.04022 -106.6092\n4  ABQ Albuquerque International Sunport 35.04022 -106.6092\n5  ABQ Albuquerque International Sunport 35.04022 -106.6092\n6  ABQ Albuquerque International Sunport 35.04022 -106.6092\n\n\nEğer iki tabloda anahtar isimleri aynıysa, by = \"carrier\" veya by.x = \"carrier\", by.y = \"carrier\" şeklinde açıkça belirtmek her zaman iyi bir pratiktir. Böylece hem okunabilirlik artar hem de gelecekte değişiklik olduğunda hatalar önlenir.\n\n\n🧩 Birden Fazla Anahtar Değişken ile Join\nBazen iki tabloyu birden fazla değişken üzerinden eşleştirmemiz gerekir. Örneğin flights tablosunu başka bir tabloyla hem yıl, hem ay, hem de havayolu kodu (carrier) üzerinden birleştirmek isteyebiliriz. Bu durumda anahtarları by argümanı içinde bir vektör olarak belirtiriz.\n✅ dplyr Örneği\n\n# Örnek amaçlı küçük bir tablo oluşturalım\nstats &lt;- flights %&gt;%\n  group_by(year, month, carrier) %&gt;%\n  summarise(avg_delay = mean(dep_delay, na.rm = TRUE), .groups = \"drop\")\n\n# Aynı üç değişken üzerinden birleştirme\nfl_enriched &lt;- flights %&gt;%\n  left_join(stats, by = c(\"year\", \"month\", \"carrier\"))\n\nfl_enriched %&gt;% select(year, month, carrier, avg_delay) %&gt;% head()\n\n# A tibble: 6 × 4\n   year month carrier avg_delay\n  &lt;int&gt; &lt;int&gt; &lt;chr&gt;       &lt;dbl&gt;\n1  2013     1 UA           8.33\n2  2013     1 UA           8.33\n3  2013     1 AA           6.93\n4  2013     1 B6           9.49\n5  2013     1 DL           3.85\n6  2013     1 UA           8.33\n\n\n✅ Base R Örneği\n\nfl_enriched_base &lt;- merge(\nflights,\nstats,\nby = c(\"year\", \"month\", \"carrier\"),\nall.x = TRUE\n)\n\nhead(fl_enriched_base[c(\"year\", \"month\", \"carrier\", \"avg_delay\")])\n\n  year month carrier avg_delay\n1 2013     1      9E  16.88251\n2 2013     1      9E  16.88251\n3 2013     1      9E  16.88251\n4 2013     1      9E  16.88251\n5 2013     1      9E  16.88251\n6 2013     1      9E  16.88251\n\n\nBirden fazla değişken kullanmak özellikle panel veriler veya zaman serileri ile çalışırken oldukça yaygındır. Ancak anahtarların her iki tabloda da aynı sırayla ve aynı tipte (örneğin karakter veya sayı) olduğuna emin olun. )\n\n\n🔄 Farklı İsimli Birden Fazla Anahtar Değişken ile Join\nEğer iki tabloda birden fazla anahtar değişken var ve bu değişkenlerin isimleri her iki tabloda aynı değilse,\nher bir çifti eşleştirerek açıkça belirtmemiz gerekir.\n✅ dplyr Örneği\n\n# flights -&gt; other_tbl_keys : sadece anahtarlar, tekilleştirilmiş\nother_tbl_keys &lt;- flights %&gt;%\n  distinct(year, month, day, carrier) %&gt;%\n  rename(yil = year, ay = month, gun = day)\n\nfl_merge &lt;- flights %&gt;%\n  left_join(\n    other_tbl_keys,\n    by = c(\"year\" = \"yil\", \"month\" = \"ay\", \"day\" = \"gun\", \"carrier\" = \"carrier\")\n  )\n\n# Satır sayısı beklenen: flights kadar\ndplyr::tibble(before = nrow(flights), after = nrow(fl_merge))\n\n# A tibble: 1 × 2\n  before  after\n   &lt;int&gt;  &lt;int&gt;\n1 336776 336776\n\n\n✅ Base R Örneği\n\nother_tbl_keys &lt;- flights %&gt;%\n  distinct(year, month, day, carrier) %&gt;%\n  rename(yil = year, ay = month, gun = day)\n\nfl_merge_ok2 &lt;- merge(\n  flights, other_tbl_keys,\n  by.x = c(\"year\",\"month\",\"day\",\"carrier\"),\n  by.y = c(\"yil\",\"ay\",\"gun\",\"carrier\"),\n  all.x = TRUE,\n  sort = FALSE\n)\n\nc(before = nrow(flights), after = nrow(fl_merge_ok2))\n\nbefore  after \n336776 336776 \n\n\n\n\n\n\n\n\n💡 Neden distinct() ile tekilleştirdik? (dplyr + Base R)\n\n\n\nflights’tan türettiğimiz sağ tablolarda (other_tbl_keys) anahtarlar (year, month, day, carrier) tekrar ediyordu.\nBu durumda left_join() / merge() her eşleşen kombinasyonu çarpan şekilde birleştirir.\n→ N–M patlaması: satır sayısı çok büyür, bellek/işlem süresi artar.\nÇözüm: Sağ tabloyu join öncesinde distinct() ile tekilleştir → ilişkiyi N–M’den 1–N’e indir.\nBöylece her anahtar yalnızca bir kez eşleşir; hem hızlı hem mantıksal olarak doğru sonuç alırsın.",
    "crumbs": [
      "Veri Birleştirme"
    ]
  },
  {
    "objectID": "data_analysis.html",
    "href": "data_analysis.html",
    "title": "Keşifçi Veri Analizi",
    "section": "",
    "text": "Veri ile Tanışma\nKeşifçi Veri Analizi (Exploratory Data Analysis veya kısaca EDA), veri setinizi anlamak, içindeki örüntüleri ve ilişkileri belirlemek ve olası sorunları tanımlamak amacıyla veriye yakından bakmanızı sağlayan bir veri analizi yaklaşımıdır. EDA, verileri tanımanıza veya verilerdeki olası özellikler ve ilişkiler hakkında daha derin bir anlayış kazanmanıza yardımcı olabilir. EDA, yeni bir şey değildir, ancak EDA, birkaç nedenden dolayı yakın geçmişte önemli ölçüde büyümüştür:\nEDA, verilerinizin nihai analizi açısından genellikle istatistiksel değildir, ancak EDA’nın geçiş süreci olarak düşünülmesi gerekir. EDA’dan öğrendikleriniz modellemenize rehberlik edecek ve istatistiksel araçlar hakkında verdiğiniz kararları doğrudan bilgilendirecektir. R gibi programlama dilleri ve istatistiksel araçlar, EDA sürecini kolaylaştırmak ve verileri görselleştirmek için kullanışlıdır. EDA, veri madenciliği ve veri bilimi projelerinin başlangıcında sıklıkla kullanılır ve aşağıdaki adımları içerir:\nEDA, veri analizi sürecinin önemli bir parçasıdır çünkü veriyi daha iyi anlamanızı ve daha ileri analizler için yol haritasını belirlemenizi sağlar. Aynı zamanda veri setinizdeki hataları veya tutarsızlıkları tespit etmenize ve düzeltmenize de yardımcı olur.\nVeri analizinin başlangıç aşamasında, verinin yapısına, ne tür değişkenler içerdiğine, çeşitli özet istatistiklerine bakmak ve gerekli ise ne tür dönüşümler yapmak gerektiğini bilmek önemlidir. Bu süreçler daha derin analizlere daha kolay devam edebilmek için de önemlidir. Bunları gerçekleştirmek için hem özet tablolar hem de grafikler yardımıyla verileri tanımak gerekmektedir.\nTek ve iki değişkenli olarak sayısal ve kategorik veri analizi mpg verisi kullanılarak yapılacaktır. Bu veri setinde 38 farklı aracın yakıt verileri bulunmaktadır.\n# mpg verisi ggplot2 paketinde olduğundan paketi çağırıyoruz\nlibrary(ggplot2)\n\nhead(mpg)\n\n# A tibble: 6 × 11\n  manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class \n  &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; \n1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…\n2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…\n3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…\n4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…\n5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…\n6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…\n\nnrow(mpg)\n\n[1] 234\n\nncol(mpg)\n\n[1] 11\n\nstr(mpg)\n\ntibble [234 × 11] (S3: tbl_df/tbl/data.frame)\n $ manufacturer: chr [1:234] \"audi\" \"audi\" \"audi\" \"audi\" ...\n $ model       : chr [1:234] \"a4\" \"a4\" \"a4\" \"a4\" ...\n $ displ       : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ...\n $ year        : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ...\n $ cyl         : int [1:234] 4 4 4 4 6 6 6 4 4 4 ...\n $ trans       : chr [1:234] \"auto(l5)\" \"manual(m5)\" \"manual(m6)\" \"auto(av)\" ...\n $ drv         : chr [1:234] \"f\" \"f\" \"f\" \"f\" ...\n $ cty         : int [1:234] 18 21 20 21 16 18 18 18 16 20 ...\n $ hwy         : int [1:234] 29 29 31 30 26 26 27 26 25 28 ...\n $ fl          : chr [1:234] \"p\" \"p\" \"p\" \"p\" ...\n $ class       : chr [1:234] \"compact\" \"compact\" \"compact\" \"compact\" ...\n\ncolnames(mpg)\n\n [1] \"manufacturer\" \"model\"        \"displ\"        \"year\"         \"cyl\"         \n [6] \"trans\"        \"drv\"          \"cty\"          \"hwy\"          \"fl\"          \n[11] \"class\"       \n\nsummary(mpg)\n\n manufacturer          model               displ            year     \n Length:234         Length:234         Min.   :1.600   Min.   :1999  \n Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999  \n Mode  :character   Mode  :character   Median :3.300   Median :2004  \n                                       Mean   :3.472   Mean   :2004  \n                                       3rd Qu.:4.600   3rd Qu.:2008  \n                                       Max.   :7.000   Max.   :2008  \n      cyl           trans               drv                 cty       \n Min.   :4.000   Length:234         Length:234         Min.   : 9.00  \n 1st Qu.:4.000   Class :character   Class :character   1st Qu.:14.00  \n Median :6.000   Mode  :character   Mode  :character   Median :17.00  \n Mean   :5.889                                         Mean   :16.86  \n 3rd Qu.:8.000                                         3rd Qu.:19.00  \n Max.   :8.000                                         Max.   :35.00  \n      hwy             fl               class          \n Min.   :12.00   Length:234         Length:234        \n 1st Qu.:18.00   Class :character   Class :character  \n Median :24.00   Mode  :character   Mode  :character  \n Mean   :23.44                                        \n 3rd Qu.:27.00                                        \n Max.   :44.00                                        \n\ndf &lt;- mpg\n\n# class değişkenini faktöre çevirip, kategorilerine bakalım\ndf$class &lt;- factor(df$class)\nlevels(df$class)\n\n[1] \"2seater\"    \"compact\"    \"midsize\"    \"minivan\"    \"pickup\"    \n[6] \"subcompact\" \"suv\"       \n\ndplyr::glimpse(df)\n\nRows: 234\nColumns: 11\n$ manufacturer &lt;chr&gt; \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"…\n$ model        &lt;chr&gt; \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4 quattro\", \"…\n$ displ        &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.…\n$ year         &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200…\n$ cyl          &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, …\n$ trans        &lt;chr&gt; \"auto(l5)\", \"manual(m5)\", \"manual(m6)\", \"auto(av)\", \"auto…\n$ drv          &lt;chr&gt; \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"4\", \"4\", \"4\", \"4\", \"4…\n$ cty          &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1…\n$ hwy          &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2…\n$ fl           &lt;chr&gt; \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p…\n$ class        &lt;fct&gt; compact, compact, compact, compact, compact, compact, com…",
    "crumbs": [
      "Keşifçi Veri Analizi"
    ]
  },
  {
    "objectID": "data_analysis.html#sürekli-değişkenler",
    "href": "data_analysis.html#sürekli-değişkenler",
    "title": "Keşifçi Veri Analizi",
    "section": "Sürekli Değişkenler",
    "text": "Sürekli Değişkenler\nVeri analizi, birçok farklı değişken türünün incelenmesini gerektirir. Bu değişkenler arasında sürekli değişkenler özellikle önemlidir. Sürekli değişkenler, belirli bir aralıktaki değerleri alabilen ve sonsuz sayıda mümkün değer içeren değişkenlerdir. Örnek olarak, yaş, gelir, sıcaklık gibi değerler sürekli değişkenlere örnektir. Sürekli değişkenlerin analizi, verileri anlamak ve içindeki örüntüleri keşfetmek için kullanılır. Bu analiz, genellikle aşağıdaki adımları içerir:\n\nVeri Görselleştirme:Sürekli değişkenlerin analizine başlamak için verilerinizi görselleştirmek önemlidir. Histogramlar, kutu grafikleri, yoğunluk grafikleri ve saçılım grafikleri gibi grafikler, veri dağılımını ve örüntülerini görsel olarak incelemenize yardımcı olur. Bu grafikler, veri setinizin merkezi eğilimini (ortalama veya medyan), yayılımını ve aykırı değerleri hızla görmeye yardımcı olur.\nMerkezi Eğilim ve Dağılım Ölçüleri: Sürekli değişkenlerin merkezi eğilimini ve dağılımını hesaplamak verileri özetlemenin önemli bir yoludur. Bu ölçümler, veri setinin merkezi noktasını ve veri noktalarının nasıl dağıldığını anlamamıza yardımcı olur. Örnek olarak, ortalama (mean), medyan (median), standart sapma (standard deviation) ve varyans (variance) gibi ölçümler bu aşamada kullanılır.\nKorelasyon Analizi: Eğer birden fazla sürekli değişken arasındaki ilişkiyi anlamak istiyorsanız, korelasyon analizi yapabilirsiniz. Korelasyon, iki değişken arasındaki ilişkinin gücünü ve yönünü ölçer. Korelasyon katsayısı, bu ilişkiyi değerlendirmek için kullanılır. Pozitif bir korelasyon, iki değişkenin aynı yönde değiştiğini, negatif bir korelasyon ise iki değişkenin ters yönde değiştiğini gösterir.\nHipotez Testleri: Sürekli değişkenler arasındaki farklılıkları değerlendirmek için hipotez testleri kullanılabilir. Örneğin, iki grup arasındaki ortalama değerlerin istatistiksel olarak anlamlı bir farklılık gösterip göstermediğini belirlemek için t-testleri veya ANOVA analizi kullanılabilir.\nGüven Aralıkları: Sürekli değişkenlerin analizi sırasında, belirli bir parametre (örneğin, ortalama) hakkında güven aralıkları hesaplanabilir. Bu güven aralıkları, parametrenin belirli bir güven düzeyinde bulunduğu aralığı gösterir. Bu, parametrenin tahmini kesinliğini değerlendirmek için kullanışlıdır.\n\nSürekli değişkenlerin analizi, verileri anlama ve kararlarınızı destekleme sürecinin önemli bir parçasıdır. İyi bir analiz, veri setinizdeki örüntüleri ve ilişkileri açığa çıkarmanıza yardımcı olur ve bilinçli kararlar almanıza yardımcı olur. Bu nedenle, sürekli değişkenlerin analizi yaparken yukarıda belirtilen adımları takip etmek önemlidir.\n\n# cty ve hwy değişkenlerini inceleyelim. \n# cty şehiriçi, hwy şehirarasını ifade ediyor.\n\nsummary(df$cty)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   9.00   14.00   17.00   16.86   19.00   35.00 \n\nvar(df$cty)\n\n[1] 18.11307\n\nmean(df$cty)\n\n[1] 16.85897\n\nsummary(df$hwy)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  12.00   18.00   24.00   23.44   27.00   44.00 \n\nvar(df$hwy)\n\n[1] 35.45778\n\nmean(df$hwy)\n\n[1] 23.44017\n\n# 1 mile= 1.609 km\n# 1 galon = 3.79 lt\n\n# litre başına km hesaplama\ngalonmil_to_ltkm &lt;- function(x){\n  \n  km &lt;- x * 1.609/3.79\n  return(km)\n}\n\ndf$cty_ltkm &lt;- galonmil_to_ltkm(df$cty)\ndf$hwy_ltkm &lt;- galonmil_to_ltkm(df$hwy)\nquantile(df$cty_ltkm) \n\n       0%       25%       50%       75%      100% \n 3.820844  5.943536  7.217150  8.066227 14.858839 \n\n# şehiriçi araçların % 75'i 1 lt ile 8.06 km den az yol alıyor.\nquantile(df$hwy_ltkm)\n\n       0%       25%       50%       75%      100% \n 5.094459  7.641689 10.188918 11.462533 18.679683 \n\n# şehirlerarası araçların % 75'i 1 lt ile 11.46 km den az yol alıyor.\n\n\n# değişken dağılımı için histogram grafiği kullanılabilir.\nhist(df$cty_ltkm,freq = FALSE,col = \"red\",border = \"blue\")\nlines(density(df$cty_ltkm), col = \"black\", lwd = 2,)\n\n\n\n\n\n\n\nhist(df$hwy_ltkm,xlim = c(4,20), ylim = c(0,60), breaks = 10)\n\n\n\n\n\n\n\n# Boxplot\nboxplot(df$cty_ltkm, main = \"Boxplot cty\")\n\n\n\n\n\n\n\nfivenum(df$cty_ltkm) # minimum, Q1, median, Q3, maximum\n\n[1]  3.820844  5.943536  7.217150  8.066227 14.858839\n\n# outliers \nboxplot(df$cty_ltkm)$out\n\n\n\n\n\n\n\n\n[1] 11.88707 11.88707 14.00976 14.85884 12.31161\n\n# outliers hangi sıralarda\nwhich(df$cty_ltkm %in% boxplot(df$cty_ltkm)$out)\n\n[1] 100 197 213 222 223\n\nboxplot(df$hwy_ltkm, main = \"Boxplot cty\")\n\n\n\n\n\n\n\nfivenum(df$hwy_ltkm) # minimum, Q1, median, Q3, maximum\n\n[1]  5.094459  7.641689 10.188918 11.462533 18.679683\n\nboxplot(hwy_ltkm ~ cyl, data = df, xlab = \"Silindir Sayısı\",\n   ylab = \"Litre Başına KM\", main = \"Mileage Data\")\n\n\n\n\n\n\n\nboxplot(hwy_ltkm ~ cyl, data = df, \n   xlab = \"Silindir Sayısı\",\n   ylab = \"Litre Başına KM\", \n   main = \"Mileage Data\",\n   notch = TRUE, \n   varwidth = TRUE, \n   col = c(\"green\",\"yellow\",\"purple\",\"blue\"),\n   names = c(\"2 Silindir\",\"4 Silindir\",\"6 Silindir\",\"8 Silindir\")\n)\n\nWarning in (function (z, notch = FALSE, width = NULL, varwidth = FALSE, : some\nnotches went outside hinges ('box'): maybe set notch=FALSE\n\n\n\n\n\n\n\n\n# Sürekli iki değişken incelemek istersek;\n\n# displ ve cty_ltkm değişkenlerini inceleyelim\n# displ motor hacmini ifade ediyor\n\nsummary(df$displ)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.600   2.400   3.300   3.472   4.600   7.000 \n\nwith(df,cor(displ,cty_ltkm))\n\n[1] -0.798524\n\n# motor hacmi ile lt başına km ters ilişkili\n\nplot(df$displ,df$cty_ltkm, \n     main = \"Motor Hacmi- Yakıt Tüketimi Saçılım Grafiği\",\n     col=\"red\",\n     xlab = \"Motor Hacmi\",\n     ylab = \"Yakıt Tüketimi\")\n\n\n\n\n\n\n\n# birden fazla değişkenin saçılım grafiği\npairs(~hwy_ltkm+cty_ltkm+displ+cyl,data = df,main = \"Scatterplot Matrix\")",
    "crumbs": [
      "Keşifçi Veri Analizi"
    ]
  },
  {
    "objectID": "data_analysis.html#kategorik-değişkenler",
    "href": "data_analysis.html#kategorik-değişkenler",
    "title": "Keşifçi Veri Analizi",
    "section": "Kategorik Değişkenler",
    "text": "Kategorik Değişkenler\nVeri analizi sürecinde, kategorik değişkenler (veya gruplar) genellikle çok önemli bir rol oynar. Kategorik değişkenler, belirli bir sınıfı veya kategoriyi temsil eden değişkenlerdir ve tipik olarak metin veya sembollerle ifade edilirler. Örnek olarak, cinsiyet, eğitim seviyesi, ürün kategorileri gibi değişkenler kategorik değişkenlere örnektir. Kategorik değişkenlerin analizi, bu değişkenlerin içindeki örüntüleri, dağılımları ve ilişkileri anlamamıza yardımcı olur. Aşağıda, kategorik değişkenlerin analizi için izlenebilecek temel adımları bulabilirsiniz:\n\nFrekans Tabloları ve Görselleştirme: Kategorik değişkenlerin frekans tablolarını ve grafiklerini oluşturarak, her kategori veya sınıfın veri setinde ne kadar sık görüldüğünü anlayabilirsiniz. Örneğin, bar grafikleri, pasta grafikleri veya çubuk grafikleri kullanarak kategori frekanslarını görselleştirebilirsiniz. summary() ve table() gibi R fonksiyonları ile bu verileri inceleyebilirsiniz.\nİlişkileri İnceleme: Kategorik değişkenler arasındaki ilişkileri anlamak önemlidir. İki kategorik değişken arasındaki ilişkiyi değerlendirmek için çapraz tablolar (cross-tabulation) ve ki-kare (chi-squared) istatistiksel testleri kullanabilirsiniz. Bu testler, iki değişken arasındaki bağımlılığı değerlendirmek için kullanılır.\nİstatistiksel Testler: Kategorik değişkenlerin analizi sırasında, gruplar arasındaki farkları değerlendirmek için hipotez testleri kullanabilirsiniz. İki kategorik değişken arasındaki ilişkinin istatistiksel olarak anlamlı olup olmadığını belirlemek için ki-kare testi veya Fisher’in kesin testi gibi testler kullanabilirsiniz. Ayrıca ANOVA gibi testler, bir kategorik değişkenin birden fazla grup üzerindeki etkisini değerlendirmek için kullanılabilir.\nVeri Görselleştirme: Kategorik değişkenlerin analizinde, gruplar arasındaki farkları daha iyi anlamak için grafikler kullanabilirsiniz. Bar grafikleri, grupların frekanslarını görselleştirmek için sıklıkla kullanılırken, gruplar arasındaki ilişkiyi anlamak için mozaik grafikleri veya heatmap’leri de kullanabilirsiniz.\n\nKategorik değişkenlerin analizi, veri setinizin içindeki desenleri ve ilişkileri anlamanıza yardımcı olur. Bu analiz, kararlarınızı desteklemek ve veriyi daha iyi anlamak için önemlidir. R programlama dili, kategorik değişkenlerin analizi için bir dizi kullanışlı fonksiyon ve paket sunar. Bu adımları takip ederek, veri analiz projelerinizde kategorik değişkenleri etkili bir şekilde analiz edebilirsiniz.\n\n# class ve trans değişkenlerine bakalım\n# class araç sınıfı, trans ise vites türünü ifade ediyor.\n\nsummary(df$class)\n\n   2seater    compact    midsize    minivan     pickup subcompact        suv \n         5         47         41         11         33         35         62 \n\ntable(df$class)\n\n\n   2seater    compact    midsize    minivan     pickup subcompact        suv \n         5         47         41         11         33         35         62 \n\nxtabs(~class,data=df)\n\nclass\n   2seater    compact    midsize    minivan     pickup subcompact        suv \n         5         47         41         11         33         35         62 \n\ntable(df$trans)\n\n\n  auto(av)   auto(l3)   auto(l4)   auto(l5)   auto(l6)   auto(s4)   auto(s5) \n         5          2         83         39          6          3          3 \n  auto(s6) manual(m5) manual(m6) \n        16         58         19 \n\nprop.table(table(df$class))\n\n\n   2seater    compact    midsize    minivan     pickup subcompact        suv \n0.02136752 0.20085470 0.17521368 0.04700855 0.14102564 0.14957265 0.26495726 \n\ntab &lt;- table(df$class)\nbarplot(tab,col=\"blue\",border=\"red\")\n\n\n\n\n\n\n\npie(tab)\n\n\n\n\n\n\n\npar(mfrow = c(1, 2))\nbarplot(tab)\npie(tab)\n\n\n\n\n\n\n\n# Kategorik iki değişken incelemek istersek;\n\nxtabs(~trans+class,data=df)\n\n            class\ntrans        2seater compact midsize minivan pickup subcompact suv\n  auto(av)         0       2       3       0      0          0   0\n  auto(l3)         0       1       0       1      0          0   0\n  auto(l4)         1       8      14       8     12         11  29\n  auto(l5)         0       4       5       0      8          4  18\n  auto(l6)         0       0       0       2      0          0   4\n  auto(s4)         0       2       1       0      0          0   0\n  auto(s5)         0       2       0       0      0          0   1\n  auto(s6)         1       5       6       0      0          1   3\n  manual(m5)       0      18       9       0      8         16   7\n  manual(m6)       3       5       3       0      5          3   0\n\nprop.table(table(df$year,df$class),1) # satır toplamları 1' eşittir\n\n      \n          2seater    compact    midsize    minivan     pickup subcompact\n  1999 0.01709402 0.21367521 0.17094017 0.05128205 0.13675214 0.16239316\n  2008 0.02564103 0.18803419 0.17948718 0.04273504 0.14529915 0.13675214\n      \n              suv\n  1999 0.24786325\n  2008 0.28205128\n\nprop.table(table(df$year,df$class),2) # sütun toplamları 1' eşittir\n\n      \n         2seater   compact   midsize   minivan    pickup subcompact       suv\n  1999 0.4000000 0.5319149 0.4878049 0.5454545 0.4848485  0.5428571 0.4677419\n  2008 0.6000000 0.4680851 0.5121951 0.4545455 0.5151515  0.4571429 0.5322581\n\nproportions(xtabs(~ manufacturer + year, data = df), 1)\n\n            year\nmanufacturer      1999      2008\n  audi       0.5000000 0.5000000\n  chevrolet  0.3684211 0.6315789\n  dodge      0.4324324 0.5675676\n  ford       0.6000000 0.4000000\n  honda      0.5555556 0.4444444\n  hyundai    0.4285714 0.5714286\n  jeep       0.2500000 0.7500000\n  land rover 0.5000000 0.5000000\n  lincoln    0.6666667 0.3333333\n  mercury    0.5000000 0.5000000\n  nissan     0.4615385 0.5384615\n  pontiac    0.6000000 0.4000000\n  subaru     0.4285714 0.5714286\n  toyota     0.5882353 0.4117647\n  volkswagen 0.5925926 0.4074074\n\n# araç sınıfı ile drv değişkenine birlikte bakalım\n# f = front-wheel drive (önden çekiş), \n# r = rear wheel drive (arkadan çekiş), \n# 4 = 4wd (4 çeker)\n\nplot(class ~ factor(drv), data = df)\n\n\n\n\n\n\n\n\nEğer hem sürekli hem de kategorik değişkenleri incelemek istersek, benzer şekilde görselleştirme ve kategoriler arasında merkezi eğilim ölçüleri hesaplanabilir. Bunlar dışında uygun istatistiksel testler de gerçekleştirilebilir.\n\n# Silindir düzeyinde yakıt tüketimi \ntapply(df$cty_ltkm, df$cyl, mean)\n\n       4        5        6        8 \n8.920545 8.703034 6.883968 5.337052 \n\n# Same using aggregate()\naggregate(cty_ltkm ~ cyl, data = df, FUN = mean)\n\n  cyl cty_ltkm\n1   4 8.920545\n2   5 8.703034\n3   6 6.883968\n4   8 5.337052\n\nboxplot(cty_ltkm ~ cyl, data = df)",
    "crumbs": [
      "Keşifçi Veri Analizi"
    ]
  },
  {
    "objectID": "data_analysis.html#zaman-serileri",
    "href": "data_analysis.html#zaman-serileri",
    "title": "Keşifçi Veri Analizi",
    "section": "Zaman Serileri",
    "text": "Zaman Serileri\nR programlama dili, zaman serileri analizi için kapsamlı bir dizi fonksiyon ve paket sunar. Zaman serileri analizi, zaman içindeki veri noktalarının örüntülerini ve trendlerini incelemeyi amaçlar. R’de zaman serileri ile çalışmak için ts (time series) nesnesi kullanılır. Bu nesne, zaman serisi verilerini zaman dilimleri (örneğin aylar, yıllar) veya tarihler ile ilişkilendirerek işlem yapmanıza olanak tanır.\n\nAirPassengers\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949 112 118 132 129 121 135 148 148 136 119 104 118\n1950 115 126 141 135 125 149 170 170 158 133 114 140\n1951 145 150 178 163 172 178 199 199 184 162 146 166\n1952 171 180 193 181 183 218 230 242 209 191 172 194\n1953 196 196 236 235 229 243 264 272 237 211 180 201\n1954 204 188 235 227 234 264 302 293 259 229 203 229\n1955 242 233 267 269 270 315 364 347 312 274 237 278\n1956 284 277 317 313 318 374 413 405 355 306 271 306\n1957 315 301 356 348 355 422 465 467 404 347 305 336\n1958 340 318 362 348 363 435 491 505 404 359 310 337\n1959 360 342 406 396 420 472 548 559 463 407 362 405\n1960 417 391 419 461 472 535 622 606 508 461 390 432\n\nclass(AirPassengers)\n\n[1] \"ts\"\n\ndiff(AirPassengers) # fark alma\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n1949         6   14   -3   -8   14   13    0  -12  -17  -15   14\n1950   -3   11   15   -6  -10   24   21    0  -12  -25  -19   26\n1951    5    5   28  -15    9    6   21    0  -15  -22  -16   20\n1952    5    9   13  -12    2   35   12   12  -33  -18  -19   22\n1953    2    0   40   -1   -6   14   21    8  -35  -26  -31   21\n1954    3  -16   47   -8    7   30   38   -9  -34  -30  -26   26\n1955   13   -9   34    2    1   45   49  -17  -35  -38  -37   41\n1956    6   -7   40   -4    5   56   39   -8  -50  -49  -35   35\n1957    9  -14   55   -8    7   67   43    2  -63  -57  -42   31\n1958    4  -22   44  -14   15   72   56   14 -101  -45  -49   27\n1959   23  -18   64  -10   24   52   76   11  -96  -56  -45   43\n1960   12  -26   28   42   11   63   87  -16  -98  -47  -71   42\n\nstats::lag(AirPassengers,-1) # 1. gecikmesini alma\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949     112 118 132 129 121 135 148 148 136 119 104\n1950 118 115 126 141 135 125 149 170 170 158 133 114\n1951 140 145 150 178 163 172 178 199 199 184 162 146\n1952 166 171 180 193 181 183 218 230 242 209 191 172\n1953 194 196 196 236 235 229 243 264 272 237 211 180\n1954 201 204 188 235 227 234 264 302 293 259 229 203\n1955 229 242 233 267 269 270 315 364 347 312 274 237\n1956 278 284 277 317 313 318 374 413 405 355 306 271\n1957 306 315 301 356 348 355 422 465 467 404 347 305\n1958 336 340 318 362 348 363 435 491 505 404 359 310\n1959 337 360 342 406 396 420 472 548 559 463 407 362\n1960 405 417 391 419 461 472 535 622 606 508 461 390\n1961 432                                            \n\nplot(AirPassengers,type = \"p\", col = \"red\") # points\n\n\n\n\n\n\n\nplot(AirPassengers,type = \"l\", col = \"red\") # line\n\n\n\n\n\n\n\nplot(AirPassengers,type = \"o\", col = \"red\") # points and line\n\n\n\n\n\n\n\nplot(log(AirPassengers),type = \"l\", col = \"red\") # line\n\n\n\n\n\n\n\nplot(diff(AirPassengers),type = \"l\", col = \"red\") # line\n\n\n\n\n\n\n\nplot(diff(log(AirPassengers)),type = \"l\", col = \"red\") # line\n\n\n\n\n\n\n\n# çoklu zaman serisi\nts &lt;- ts(rnorm(length(AirPassengers),250,100),start = c(1949,1),frequency=12)\nts\n\n           Jan       Feb       Mar       Apr       May       Jun       Jul\n1949 379.44502 291.41628 366.13389 257.74715 284.22410 137.27976 257.28253\n1950 360.95662 251.63095 364.61479 172.23420 315.18529 281.17738 359.64334\n1951  52.45391 290.08050 228.55554 358.40702 241.72118 163.39030 294.45143\n1952 292.22817 301.56788 191.77509 268.76531 411.85588 328.90398 216.86409\n1953 263.19884 159.37917 175.20740 348.33730 339.35949 246.79821  93.11617\n1954 230.36339 297.04708 157.33337 104.03686 428.05227 301.71475 134.68330\n1955 262.89086 344.27931 275.26503 367.46901 159.17212 254.82049 352.51707\n1956 102.37068 275.20447 269.59850 210.82647 336.88566 308.80840 268.24249\n1957 285.72011  23.19215 312.33653 210.88933 200.05299 399.57244  27.94297\n1958 248.28246 209.83887 126.45481 176.28159 264.99415 372.68287 245.10401\n1959 322.80496 200.66539 274.16565 246.84656 310.59873 179.57203 232.82080\n1960 179.21477 312.19728 244.06011 321.19790 255.87123 310.85755 137.51181\n           Aug       Sep       Oct       Nov       Dec\n1949 262.09556 253.47834 192.88025 167.05500 394.02207\n1950 155.69419 395.03647 385.58823 174.66755 174.82325\n1951 520.03845 322.50362 272.98792 137.60888  35.33984\n1952 218.92506 117.18323 285.58981 337.58970 117.88529\n1953 252.59597 102.15643 205.74071 258.16626 310.40166\n1954 118.36493 368.35721 206.38769 268.10042 161.72377\n1955  96.82095 126.09921 256.12542 264.60091 161.89080\n1956 289.03812 220.36139 274.77540 120.94684 279.76260\n1957 247.22380 316.42102 253.60501 411.39514 320.21453\n1958 261.02516 228.18197 458.88663 202.12957 393.29238\n1959 253.39989 357.45025 272.28746 171.28255 332.53625\n1960 219.04179 195.29147 389.41816 155.66004 401.39643\n\nplot(AirPassengers,type = \"l\",col = \"red\")\nlines(ts, type = \"l\", col = \"blue\")\n\n\n\n\n\n\n\n# yüzde değişim\ngrowth &lt;- AirPassengers/stats::lag(AirPassengers,-1)*100-100\ngrowth\n\n             Jan         Feb         Mar         Apr         May         Jun\n1949               5.3571429  11.8644068  -2.2727273  -6.2015504  11.5702479\n1950  -2.5423729   9.5652174  11.9047619  -4.2553191  -7.4074074  19.2000000\n1951   3.5714286   3.4482759  18.6666667  -8.4269663   5.5214724   3.4883721\n1952   3.0120482   5.2631579   7.2222222  -6.2176166   1.1049724  19.1256831\n1953   1.0309278   0.0000000  20.4081633  -0.4237288  -2.5531915   6.1135371\n1954   1.4925373  -7.8431373  25.0000000  -3.4042553   3.0837004  12.8205128\n1955   5.6768559  -3.7190083  14.5922747   0.7490637   0.3717472  16.6666667\n1956   2.1582734  -2.4647887  14.4404332  -1.2618297   1.5974441  17.6100629\n1957   2.9411765  -4.4444444  18.2724252  -2.2471910   2.0114943  18.8732394\n1958   1.1904762  -6.4705882  13.8364780  -3.8674033   4.3103448  19.8347107\n1959   6.8249258  -5.0000000  18.7134503  -2.4630542   6.0606061  12.3809524\n1960   2.9629630  -6.2350120   7.1611253  10.0238663   2.3861171  13.3474576\n             Jul         Aug         Sep         Oct         Nov         Dec\n1949   9.6296296   0.0000000  -8.1081081 -12.5000000 -12.6050420  13.4615385\n1950  14.0939597   0.0000000  -7.0588235 -15.8227848 -14.2857143  22.8070175\n1951  11.7977528   0.0000000  -7.5376884 -11.9565217  -9.8765432  13.6986301\n1952   5.5045872   5.2173913 -13.6363636  -8.6124402  -9.9476440  12.7906977\n1953   8.6419753   3.0303030 -12.8676471 -10.9704641 -14.6919431  11.6666667\n1954  14.3939394  -2.9801325 -11.6040956 -11.5830116 -11.3537118  12.8078818\n1955  15.5555556  -4.6703297 -10.0864553 -12.1794872 -13.5036496  17.2995781\n1956  10.4278075  -1.9370460 -12.3456790 -13.8028169 -11.4379085  12.9151292\n1957  10.1895735   0.4301075 -13.4903640 -14.1089109 -12.1037464  10.1639344\n1958  12.8735632   2.8513238 -20.0000000 -11.1386139 -13.6490251   8.7096774\n1959  16.1016949   2.0072993 -17.1735242 -12.0950324 -11.0565111  11.8784530\n1960  16.2616822  -2.5723473 -16.1716172  -9.2519685 -15.4013015  10.7692308\n\nplot(growth,type = \"l\", col = \"red\")",
    "crumbs": [
      "Keşifçi Veri Analizi"
    ]
  },
  {
    "objectID": "data_analysis.html#veri-analizi-bazı-paketler",
    "href": "data_analysis.html#veri-analizi-bazı-paketler",
    "title": "Keşifçi Veri Analizi",
    "section": "Veri Analizi Bazı Paketler",
    "text": "Veri Analizi Bazı Paketler\nVeri analizi için skimr paketi de kullanılabilir. skimr, R programlama dilinde veri setlerinin hızlı bir şekilde özetlenmesini sağlayan bir pakettir. Veri setlerinin yapısını, özelliklerini ve bazı istatistiksel özetlerini görsel ve açıklayıcı bir şekilde sunar. Bu paket, veri keşfi aşamasında veri setinin genel özelliklerini anlamak için kullanılır.\nskimr paketi, veri setinizdeki değişkenlerin türlerine göre istatistiksel özetler sunar. Örneğin, sayısal değişkenler için merkezi eğilim ölçüleri (ortalama, medyan), dağılım (standart sapma, min-max değerleri), faktör değişkenleri için sınıf sayısı, en sık rastlanan sınıf ve eksik veri durumları gibi bilgileri sunar.\nBu paket, veri setinin yapısını hızlıca anlamak ve önemli özelliklerini keşfetmek için kullanılır. Özellikle veri setlerinin keşfedilmesi, temizlenmesi ve analiz edilmesi aşamalarında oldukça faydalıdır. Bu, veri analiz sürecinde veriye daha derinlemesine bakmayı ve hangi analiz tekniklerinin kullanılacağına dair daha iyi bir anlayış geliştirmeyi sağlar.\nBunun yanında, modelsummary paketi de, R programlama dili için geliştirilmiş olan bir pakettir ve istatistiksel modellerin özetlenmesi, karşılaştırılması ve görselleştirilmesi için kullanılır. Bu paket, farklı türdeki modellerin çıktılarını standartlaştırarak, bunları karşılaştırmak ve analiz etmek için kullanıcıya kolaylık sağlar.\nBu paket genellikle doğrusal regresyon, lojistik regresyon, karar ağaçları, destek vektör makineleri gibi çeşitli istatistiksel ve makine öğrenimi modellerinin özet istatistiklerini, katsayılarını, belirlilik ölçülerini, hata ölçümlerini ve diğer önemli çıktıları sunar. Bunların yanı sıra, çıktıları tablolar halinde gösterir ve görselleştirmeler yaparak model performansını karşılaştırmak için grafikler oluşturabilir.\nBu paket, araştırmacılar, veri bilimcileri veya istatistikçilerin farklı modelleri anlamak, karşılaştırmak ve raporlamak için verimli bir araç sunar. Model sonuçlarını görselleştirme ve karşılaştırma açısından kullanışlıdır. Paket, model özetlerinin ötesinde, veri kümesine genel bakış, korelasyon matrisleri, (çok seviyeli) çapraz tablolar ve denge tabloları gibi son derece esnek veri özet tabloları üretmek için bir dizi araç da içerir.\n\n# Paketin birkaç özelliğine bakalım\n\nlibrary(modelsummary)\n\n# kategorik verilere hızlı bir bakış\ndatasummary_skim(mpg, type = \"categorical\")\n\n\n\n    \n\n    \n    \n      \n        \n        \n              \n                 \n                  \n                N\n                %\n              \n        \n        \n        \n                \n                  manufacturer\n                  audi\n                  18\n                  7.7\n                \n                \n                  \n                  chevrolet\n                  19\n                  8.1\n                \n                \n                  \n                  dodge\n                  37\n                  15.8\n                \n                \n                  \n                  ford\n                  25\n                  10.7\n                \n                \n                  \n                  honda\n                  9\n                  3.8\n                \n                \n                  \n                  hyundai\n                  14\n                  6.0\n                \n                \n                  \n                  jeep\n                  8\n                  3.4\n                \n                \n                  \n                  land rover\n                  4\n                  1.7\n                \n                \n                  \n                  lincoln\n                  3\n                  1.3\n                \n                \n                  \n                  mercury\n                  4\n                  1.7\n                \n                \n                  \n                  nissan\n                  13\n                  5.6\n                \n                \n                  \n                  pontiac\n                  5\n                  2.1\n                \n                \n                  \n                  subaru\n                  14\n                  6.0\n                \n                \n                  \n                  toyota\n                  34\n                  14.5\n                \n                \n                  \n                  volkswagen\n                  27\n                  11.5\n                \n                \n                  model\n                  4runner 4wd\n                  6\n                  2.6\n                \n                \n                  \n                  a4\n                  7\n                  3.0\n                \n                \n                  \n                  a4 quattro\n                  8\n                  3.4\n                \n                \n                  \n                  a6 quattro\n                  3\n                  1.3\n                \n                \n                  \n                  altima\n                  6\n                  2.6\n                \n                \n                  \n                  c1500 suburban 2wd\n                  5\n                  2.1\n                \n                \n                  \n                  camry\n                  7\n                  3.0\n                \n                \n                  \n                  camry solara\n                  7\n                  3.0\n                \n                \n                  \n                  caravan 2wd\n                  11\n                  4.7\n                \n                \n                  \n                  civic\n                  9\n                  3.8\n                \n                \n                  \n                  corolla\n                  5\n                  2.1\n                \n                \n                  \n                  corvette\n                  5\n                  2.1\n                \n                \n                  \n                  dakota pickup 4wd\n                  9\n                  3.8\n                \n                \n                  \n                  durango 4wd\n                  7\n                  3.0\n                \n                \n                  \n                  expedition 2wd\n                  3\n                  1.3\n                \n                \n                  \n                  explorer 4wd\n                  6\n                  2.6\n                \n                \n                  \n                  f150 pickup 4wd\n                  7\n                  3.0\n                \n                \n                  \n                  forester awd\n                  6\n                  2.6\n                \n                \n                  \n                  grand cherokee 4wd\n                  8\n                  3.4\n                \n                \n                  \n                  grand prix\n                  5\n                  2.1\n                \n                \n                  \n                  gti\n                  5\n                  2.1\n                \n                \n                  \n                  impreza awd\n                  8\n                  3.4\n                \n                \n                  \n                  jetta\n                  9\n                  3.8\n                \n                \n                  \n                  k1500 tahoe 4wd\n                  4\n                  1.7\n                \n                \n                  \n                  land cruiser wagon 4wd\n                  2\n                  0.9\n                \n                \n                  \n                  malibu\n                  5\n                  2.1\n                \n                \n                  \n                  maxima\n                  3\n                  1.3\n                \n                \n                  \n                  mountaineer 4wd\n                  4\n                  1.7\n                \n                \n                  \n                  mustang\n                  9\n                  3.8\n                \n                \n                  \n                  navigator 2wd\n                  3\n                  1.3\n                \n                \n                  \n                  new beetle\n                  6\n                  2.6\n                \n                \n                  \n                  passat\n                  7\n                  3.0\n                \n                \n                  \n                  pathfinder 4wd\n                  4\n                  1.7\n                \n                \n                  \n                  ram 1500 pickup 4wd\n                  10\n                  4.3\n                \n                \n                  \n                  range rover\n                  4\n                  1.7\n                \n                \n                  \n                  sonata\n                  7\n                  3.0\n                \n                \n                  \n                  tiburon\n                  7\n                  3.0\n                \n                \n                  \n                  toyota tacoma 4wd\n                  7\n                  3.0\n                \n                \n                  trans\n                  auto(av)\n                  5\n                  2.1\n                \n                \n                  \n                  auto(l3)\n                  2\n                  0.9\n                \n                \n                  \n                  auto(l4)\n                  83\n                  35.5\n                \n                \n                  \n                  auto(l5)\n                  39\n                  16.7\n                \n                \n                  \n                  auto(l6)\n                  6\n                  2.6\n                \n                \n                  \n                  auto(s4)\n                  3\n                  1.3\n                \n                \n                  \n                  auto(s5)\n                  3\n                  1.3\n                \n                \n                  \n                  auto(s6)\n                  16\n                  6.8\n                \n                \n                  \n                  manual(m5)\n                  58\n                  24.8\n                \n                \n                  \n                  manual(m6)\n                  19\n                  8.1\n                \n                \n                  drv\n                  4\n                  103\n                  44.0\n                \n                \n                  \n                  f\n                  106\n                  45.3\n                \n                \n                  \n                  r\n                  25\n                  10.7\n                \n                \n                  fl\n                  c\n                  1\n                  0.4\n                \n                \n                  \n                  d\n                  5\n                  2.1\n                \n                \n                  \n                  e\n                  8\n                  3.4\n                \n                \n                  \n                  p\n                  52\n                  22.2\n                \n                \n                  \n                  r\n                  168\n                  71.8\n                \n                \n                  class\n                  2seater\n                  5\n                  2.1\n                \n                \n                  \n                  compact\n                  47\n                  20.1\n                \n                \n                  \n                  midsize\n                  41\n                  17.5\n                \n                \n                  \n                  minivan\n                  11\n                  4.7\n                \n                \n                  \n                  pickup\n                  33\n                  14.1\n                \n                \n                  \n                  subcompact\n                  35\n                  15.0\n                \n                \n                  \n                  suv\n                  62\n                  26.5\n                \n        \n      \n    \n\n\n# nümerik verilere hızlı bir bakış\ndatasummary_skim(mpg, type = \"numeric\")\n\n\n\n    \n\n    \n    \n      \n        \n        \n              \n                 \n                Unique\n                Missing Pct.\n                Mean\n                SD\n                Min\n                Median\n                Max\n                Histogram\n              \n        \n        \n        \n                \n                  displ\n                  35\n                  0\n                  3.5\n                  1.3\n                  1.6\n                  3.3\n                  7.0\n                  \n                \n                \n                  year\n                  2\n                  0\n                  2003.5\n                  4.5\n                  1999.0\n                  2003.5\n                  2008.0\n                  \n                \n                \n                  cyl\n                  4\n                  0\n                  5.9\n                  1.6\n                  4.0\n                  6.0\n                  8.0\n                  \n                \n                \n                  cty\n                  21\n                  0\n                  16.9\n                  4.3\n                  9.0\n                  17.0\n                  35.0\n                  \n                \n                \n                  hwy\n                  27\n                  0\n                  23.4\n                  6.0\n                  12.0\n                  24.0\n                  44.0",
    "crumbs": [
      "Keşifçi Veri Analizi"
    ]
  },
  {
    "objectID": "data_preprocess.html",
    "href": "data_preprocess.html",
    "title": "Veri Ön İşleme",
    "section": "",
    "text": "Eksik Veriler\nVeri ön işleme; istatistiksel modeller kurulmadan önce veri seti üzerinde yapılan bir takım düzeltme, eksik veriyi tamamlama, tekrarlanan verileri kaldırma, dönüştürme, bütünleştirme, temizleme, normalleştirme, boyut indirgeme vb. işlemlerdir. Bu aşamada ister istemez veri üzerinde bilgi keşfi yapılmış olur. Veri önişleme istatistiksel bir modelleme sürecinin büyük kısmını oluşturmaktadır. Kesin bir rakam olmamakla birlikte modelleme sürecinin yarısından fazlasının bu aşamada harcandığını ifade edebiliriz. Veri ön işleme temel anlamda 4 aşamadan oluşmaktadır. Bunlar sırasıyla şu şekildedir:\nBu dokümanda eksik veriler (missing values), aykırı değerler (outliers) ve veri normalleştirme işlemleri R uygulamları ile anlatılacaktır.\nEksik veriler, bir veri setinde belirli gözlemlerde veya değişkenlerde eksik veya boş değerler içeren durumlardır. Eksik veriler, ölçüm hatası, veri toplama sürecindeki problemler veya rasgele olaylar nedeniyle ortaya çıkabilir. Sistematik bir kayıp gözlem durumu yoksa ortada ciddi bir sorun yoktur. Ama rastgele olmayan bir hata varsa tüm kitleye dair yanlılık olacağı için bu durum göz ardı edilemez.\nEksik Verilerin Türleri:\nEksik veriler için daha fazla örnek aşağıda yer almaktadır:\nHer bir örnek, eksik verilerin farklı nedenlere dayanabileceğini ve bu nedenlere bağlı olarak başa çıkma stratejilerinin belirlenmesi gerektiğini göstermektedir. Eksik verilerin türlerini anlamak, başa çıkma stratejilerini belirlemede önemlidir çünkü stratejiler eksik verilerin nasıl oluştuğuna bağlı olarak farklılık gösterebilir. MCAR durumu, basit bir ortalama atama stratejisinin kullanılmasını daha kabul edilebilir kılabilirken, MAR ve MNAR durumları daha sofistike yöntemleri gerektirebilir.\n# Örnek veri seti oluşturalım\n# üreteç sabitlenir\nset.seed(123)\ndata &lt;- data.frame(\n  ID = 1:10,\n  Age = c(25, 30, NA, 22, 35, 40, NA, 28, NA, 32),\n  Income = c(50000, 60000, 75000, NA, 80000, 90000, 70000, NA, 65000, 75000),\n  Score = c(80, 85, 90, 78, NA, 88, 92, 85, 80, NA)\n)\n\n# veride hiç NA var mı? \n# TRUE tabloda en az bir tane NA olduğu anlamına gelir \nanyNA(data)\n\n[1] TRUE\n\n# eksik verilerin sorgulanması\nis.na(data) \n\n         ID   Age Income Score\n [1,] FALSE FALSE  FALSE FALSE\n [2,] FALSE FALSE  FALSE FALSE\n [3,] FALSE  TRUE  FALSE FALSE\n [4,] FALSE FALSE   TRUE FALSE\n [5,] FALSE FALSE  FALSE  TRUE\n [6,] FALSE FALSE  FALSE FALSE\n [7,] FALSE  TRUE  FALSE FALSE\n [8,] FALSE FALSE   TRUE FALSE\n [9,] FALSE  TRUE  FALSE FALSE\n[10,] FALSE FALSE  FALSE  TRUE\n\n# toplam eksik veri sayısını tespit etmek\nsum(is.na(data))\n\n[1] 7\n\n# değişken düzeyinde eksik veri sayısını tespit etmek\ncolSums(is.na(data)) \n\n    ID    Age Income  Score \n     0      3      2      2",
    "crumbs": [
      "Veri Ön İşleme"
    ]
  },
  {
    "objectID": "data_preprocess.html#eksik-veriler",
    "href": "data_preprocess.html#eksik-veriler",
    "title": "Veri Ön İşleme",
    "section": "",
    "text": "Rasgele Eksiklik (MCAR - Missing Completely At Random): Eksiklik, gözlemler arasında tamamen rastgele ve bağımsız bir şekilde meydana gelir. Örneğin, bir anket çalışması yapıyorsunuz ve bazı katılımcılar, bilgisayar hatası nedeniyle rastgele seçilmiş sorulara cevap verememişlerdir. Bu durumda, eksiklik rastgele olarak oluştu ve diğer değişkenlerle ilişkili değildir.\nRastgele Eksiklik (MAR - Missing At Random): Eksiklik, diğer değişkenlerin değerlerine bağlı olarak meydana gelir, ancak eksik veri değeri eksik olduğu değişkenle ilgili değildir. Örneğin, bir sağlık çalışması yapılıyor ve bazı katılımcılar, yaşlarına bağlı olarak belirli testlere katılamıyorlar. Bu durumda, eksiklik yaşa bağlıdır, ancak test sonuçlarından bağımsız olarak rastgele olarak meydana gelmiştir.\nSistematik Eksiklik (MNAR - Missing Not At Random): Eksiklik, eksik olan değerlerin değerlere bağlı olarak ortaya çıktığı bir modeli takip eder. Bu durum, eksik verilerin diğer değişkenlerle ilişkili olduğu anlamına gelir. Örneğin, bir maaş anketi yapılıyor ve yüksek maaş alan katılımcılar, maaşlarını ifşa etme konusundaki isteksizlikleri nedeniyle maaş sorularına cevap vermiyorlar. Bu durumda, eksiklik maaş seviyesi ile ilişkilidir ve bu durum MNAR olarak kabul edilir.\n\n\n\nMevcut Olmayan Bilgi (Not Stated - NS): Bir anketin bir bölümünde “Cinsiyet” sorusu vardır ve bazı katılımcılar bu soruya cevap vermez veya “Belirtmek İstemiyorum” seçeneğini işaretler. Bu durum, cinsiyet bilgisinin eksik olduğu ve bu eksikliğin katılımcıların cinsiyetiyle ilgili olup olmadığını anlamak zordur. Bu durum MCAR veya MAR olarak değerlendirilebilir.\nZamanla Değişen Eksiklik (Time-Dependent Missingness): Bir panel veri setinde her yıl yapılan bir ankette, bazı katılımcılar belirli bir yıl için bazı sorulara cevap vermemiş olabilir. Bu durumda eksiklik, zamanla değişen bir yapıya sahiptir ve belirli bir yıla özgüdür. Bu tür eksiklik zaman serileri analizinde önemli olabilir.\nSeçimli Eksiklik (Selective Missingness): Bir çalışma, belirli bir tedavi grubuna katılan katılımcıların tedaviye yanıtını ölçen bir değişkenle ilgili eksik verilere sahiptir. Tedavi grubuna dahil olan katılımcılar bu değişkeni ölçmeyi reddetmiş olabilir veya ölçüm yapılmamış olabilir. Bu durum, eksiklik belirli bir grupla sınırlıdır ve bu grupla ilgili özelliklere bağlıdır, bu da durumu MNAR yapar.\nSosyal İsteksizlik (Social Desirability Bias): Bir anket, katılımcılara kişisel gelirlerini belirtmelerini istemektedir. Ancak, bazı katılımcılar gelirlerini abartma eğilimindedir çünkü yüksek gelir bildirmek sosyal olarak daha kabul edilebilir bir durum olarak görülmektedir. Bu durumda, eksiklik sosyal etkileşim ve katılımcıların isteğine bağlıdır, bu da durumu MAR veya MNAR yapabilir.",
    "crumbs": [
      "Veri Ön İşleme"
    ]
  },
  {
    "objectID": "data_preprocess.html#imputasyon",
    "href": "data_preprocess.html#imputasyon",
    "title": "Veri Ön İşleme",
    "section": "İmputasyon",
    "text": "İmputasyon\nİmputasyon terimi, eksik verilerin yerine konulması veya doldurulması işlemine atıfta bulunur. Eksik veriler, bir veri setinde belirli gözlemler veya değişkenler için eksik veya bilinmeyen değerler içeren durumlardır. İstatistiksel analiz yaparken eksik verilerle başa çıkmak önemlidir çünkü eksik veriler, sonuçları yanıltabilir veya analizleri etkileyebilir.\nİmputasyon, eksik verileri doldurmak veya tahmin etmek için kullanılan çeşitli istatistiksel yöntemleri ifade eder. İmputasyon işlemi, eksik verileri analizde kullanılabilir hale getirmek amacıyla yapılır. İmputasyon yöntemleri, veri setinin yapısına ve eksik verilerin nedenlerine bağlı olarak değişebilir. Yaygın olarak kullanılan bazı imputasyon yöntemleri ve eksik verilerle başa çıkma stratejileri aşağıda verilmiştir:\n\nSilme (Deletion):\n\nListwise Deletion (Tamamen Eksik Gözlemleri Silme): Eksik veri içeren gözlemleri veri setinden tamamen çıkarır. Ancak, bu yöntem veri kaybına neden olabilir ve analizin güvenilirliğini azaltabilir.\nPairwise Deletion (Çiftler Arası Silme): Her analizde eksik verisi olan değişkenleri dışlamadan eksik verilerle çalışmayı sağlar.\n\nBasit Değer Atama (Single Imputation):\n\nOrtalama, Medyan veya Mod Atama: Eksik değerlere ortalama, medyan veya mod değerleri atanabilir. Ancak, bu yöntem veri dağılımını etkileyebilir. Ortalama ile atama, eksik verilerin diğer gözlemlerdeki ortalama değerlere benzer olduğu varsayımına dayanır. Medyan ile atama ise, verilerdeki aşırı değerlerden etkilenmeyeceği için ortalama değere göre daha dayanıklı bir seçenek olarak tercih edilebilir.\nDoldurma (Interpolation): Zaman serisi verilerinde kullanılan bir yöntemdir. Mevcut değerlere dayanarak eksik değerleri tahmin eder.\n\nÇoklu Değer Atama (Multiple Imputation):\n\nBirden fazla kez eksik verileri doldurur ve her birini farklı bir “tamamlanmış” veri seti olarak ele alır. Bu, belirsizlikle başa çıkma avantajına sahiptir.\n\nModel Tabanlı Yöntemler:\n\nİleri düzey istatistiksel modeller veya makine öğrenimi algoritmaları kullanarak eksik değerleri tahmin edebilir. KNN (K Nearest Neighbor-En Yakın Komşu), regresyon analizi ve karar ağaçları bu tür yöntemlere örnektir.\n\n\nİmputasyon yöntemi, veri setinin özelliklerine, eksik verilerin miktarına ve verilerin doğasına bağlı olarak seçilir. Her yöntemin avantajları ve dezavantajları vardır, bu nedenle doğru yöntemi seçmek, analizin doğruluğunu ve güvenilirliğini etkileyebilir. İmputasyonun amacı, eksik verilerin doğru ve güvenilir bir şekilde doldurulmasıdır, böylece analiz sonuçları daha kesin ve anlamlı olur.\n\nEksik Verilerin Silinmesi\nEksik verilerin silinmesi, bir analizde kullanılan veri setinden eksik değerlere sahip olan gözlemlerin veya değişkenlerin tamamen çıkarılması anlamına gelir. Ancak, bu strateji her zaman uygun değildir, çünkü veri kaybına neden olabilir ve analizin güvenilirliğini azaltabilir. Bu nedenle, dikkatlice düşünülmesi gereken bir yöntemdir.\n\n# Eksik verilere sahip gözlemleri sil\ndata_no_missing &lt;- na.omit(data)\n\n# Sonucu göster\nprint(data_no_missing)\n\n  ID Age Income Score\n1  1  25  50000    80\n2  2  30  60000    85\n6  6  40  90000    88\n\n\nBu örnekte, “Age”, “Income” ve “Score” değişkenlerinde eksik verilere sahip olan bir veri seti oluşturuldu. Ardından, na.omit() fonksiyonu kullanılarak eksik verilere sahip gözlemler silindi. Ancak, bu işlemle birlikte bazı gözlemler tamamen silinmiş oldu.\n\n# complete.cases ile eksik verilere sahip gözlemleri filtrele\ncomplete_data &lt;- data[complete.cases(data), ]\n\n# Sonucu göster\nprint(complete_data)\n\n  ID Age Income Score\n1  1  25  50000    80\n2  2  30  60000    85\n6  6  40  90000    88\n\n\ncomplete.cases(data) ifadesi, veri setindeki tamamen eksiksiz olan gözlemleri belirleyerek TRUE ve FALSE değerlerinden oluşan bir mantıksal vektör oluşturur. Daha sonra, bu mantıksal vektör kullanılarak sadece tamamen eksiksiz olan gözlemleri içeren yeni bir veri seti oluşturulur.\nEksik verilerin silinmesi avantajlı olabilir çünkü veri seti daha temiz hale gelir ve analiz daha basitleşir. Ancak, bu yaklaşımın dezavantajı, silinen gözlemler nedeniyle veri setindeki genel örüntülerin ve ilişkilerin değişebileceğidir. Ayrıca, eksik veri durumunun mevcut olduğu durumlarda analiz yapılamayabilir. Bu nedenle, eksik verilerin silinmesi stratejisini kullanmadan önce eksik verilerin neden kaynaklandığını anlamak ve analizin amacını dikkate almak önemlidir.\n\n\nEksik Değerlere Basit Değer Atama\nEksik değerlere basit değer atama, eksik değerlere sabit bir değer, ortalama, medyan veya mod gibi basit bir istatistiksel ölçüt atanması anlamına gelir. Bu, eksik verilerin tahmin edilmesinde basit ancak yaygın bir yöntemdir.\nEksik değerlere basit bir değer atamak için, örneğin, Age değişkenindeki eksik değerlere ortalama değeri atayabiliriz:\n\n# Age değişkenindeki eksik değerlere ortalama değeri atama\ndata$Age[is.na(data$Age)] &lt;- mean(data$Age, na.rm = TRUE)\n\n# Değişiklikleri göster\nprint(data)\n\n   ID      Age Income Score\n1   1 25.00000  50000    80\n2   2 30.00000  60000    85\n3   3 30.28571  75000    90\n4   4 22.00000     NA    78\n5   5 35.00000  80000    NA\n6   6 40.00000  90000    88\n7   7 30.28571  70000    92\n8   8 28.00000     NA    85\n9   9 30.28571  65000    80\n10 10 32.00000  75000    NA\n\n\nBu örnekte, is.na(data$Age) ifadesi, Age değişkenindeki eksik değerlere TRUE, eksik olmayan değerlere FALSE döndüren bir mantıksal vektör oluşturur. Ardından, mean(data$Age, na.rm = TRUE) ifadesi ile Age değişkeninin ortalama değeri hesaplanır ve eksik değerlere bu ortalama değer atanır.\nAynı yöntem, diğer basit istatistiksel ölçütlerle de uygulanabilir. Örneğin, eksik değerlere medyan veya belirli bir sabit değer atanabilir.\n\n# Income değişkenindeki eksik değerlere medyan değeri atama\ndata$Income[is.na(data$Income)] &lt;- median(data$Income, na.rm = TRUE)\n\n# Score değişkenindeki eksik değerlere sabit bir değer (örneğin, 75) atama\ndata$Score[is.na(data$Score)] &lt;- 75\n\n# Değişiklikleri göster\nprint(data)\n\n   ID      Age Income Score\n1   1 25.00000  50000    80\n2   2 30.00000  60000    85\n3   3 30.28571  75000    90\n4   4 22.00000  72500    78\n5   5 35.00000  80000    75\n6   6 40.00000  90000    88\n7   7 30.28571  70000    92\n8   8 28.00000  72500    85\n9   9 30.28571  65000    80\n10 10 32.00000  75000    75\n\n\nEksik değerlere çoklu olarak basit değer atama yapmak için sapply fonksiyonu kullanılabilir. Bu fonksiyon, bir liste veya vektör üzerinde bir işlemi tekrarlamak için kullanılır.\n\n# Örnek veri seti yeniden oluşturalım\n# Çünkü önceki örneklerde farklı yöntemlerle değer atadık.\n# üreteç sabitlenir\nset.seed(123)\ndata &lt;- data.frame(\n  ID = 1:10,\n  Age = c(25, 30, NA, 22, 35, 40, NA, 28, NA, 32),\n  Income = c(50000, 60000, 75000, NA, 80000, 90000, 70000, NA, 65000, 75000),\n  Score = c(80, 85, 90, 78, NA, 88, 92, 85, 80, NA)\n)\n\n\n# Sapply ile eksik değerlere ortalama değeri atama\nsapply(data, function(x)\n  ifelse(is.na(x), mean(x, na.rm = TRUE), x))\n\n      ID      Age Income Score\n [1,]  1 25.00000  50000 80.00\n [2,]  2 30.00000  60000 85.00\n [3,]  3 30.28571  75000 90.00\n [4,]  4 22.00000  70625 78.00\n [5,]  5 35.00000  80000 84.75\n [6,]  6 40.00000  90000 88.00\n [7,]  7 30.28571  70000 92.00\n [8,]  8 28.00000  70625 85.00\n [9,]  9 30.28571  65000 80.00\n[10,] 10 32.00000  75000 84.75\n\n\nEksik değerleri doldurmak için zoo paketinde bulunan na.locf, na.approx ve na.spline fonksiyonları oldukça kullanışlıdır. Bu fonksiyonlar, sırasıyla bir önceki değeri kullanma (last observation carried forward), doğrusal interpolasyon ve spline interpolasyon yöntemlerini içerir.\nna.locf, na.approx, ve na.spline fonksiyonları, zaman serisi verilerinde eksik değerleri doldurmak için özellikle kullanışlıdır. Bu fonksiyonlar, zaman içinde belirli bir düzeni takip eden verilerdeki eksik değerleri tahmin etmek için tasarlanmıştır. İşte bu fonksiyonlar ve uygun oldukları senaryoların kısa bir açıklaması:\nna.locf (Last Observation Carried Forward): Zaman serisi verilerinde, gözlemler arasındaki sürekli düzeni korumak istediğiniz durumlar. Önceki gözlemin değeri, sonraki eksik gözlemin değeri olarak kabul edilir.\n\nlibrary(zoo)\n# carry forward\n# eksik değerler bir önceki gözlemin değeriyle doldurulur.\nsapply(data, function(x) ifelse(is.na(x), na.locf(x), x ))\n\n      ID Age Income Score\n [1,]  1  25  50000    80\n [2,]  2  30  60000    85\n [3,]  3  30  75000    90\n [4,]  4  22  75000    78\n [5,]  5  35  80000    78\n [6,]  6  40  90000    88\n [7,]  7  40  70000    92\n [8,]  8  28  70000    85\n [9,]  9  28  65000    80\n[10,] 10  32  75000    80\n\n\nna.approx (Linear Approximation): Zaman serisi verilerinde, eksik değerleri doğrusal bir eğilimle doldurmak istediğiniz durumlar. Ancak, doğrusal interpolasyon, verilerde gerçekten doğrusal bir ilişki olduğu durumları varsayar.\n\n# linear interpolation\n# eksik değerler doğrusal interpolasyon yöntemiyle doldurulur.\nsapply(data, function(x) ifelse(is.na(x), na.approx(x), x ))\n\n      ID Age Income Score\n [1,]  1  25  50000    80\n [2,]  2  30  60000    85\n [3,]  3  26  75000    90\n [4,]  4  22  77500    78\n [5,]  5  35  80000    83\n [6,]  6  40  90000    88\n [7,]  7  34  70000    92\n [8,]  8  28  67500    85\n [9,]  9  30  65000    80\n[10,] 10  32  75000    80\n\n\nna.spline (Spline Approximation): Zaman serisi verilerinde, eksik değerleri spline interpolasyon yöntemi ile doldurmak istediğiniz durumlar. Spline interpolasyon, veriler arasında daha karmaşık ve eğri bir ilişki olduğu durumları ele alabilir.\n\n# spline interpolation\n# eksik değerler spline interpolasyon yöntemiyle doldurulur.\nsapply(data, function(x) ifelse(is.na(x), na.spline(x), x ))\n\n      ID      Age   Income    Score\n [1,]  1 25.00000 50000.00 80.00000\n [2,]  2 30.00000 60000.00 85.00000\n [3,]  3 23.21344 75000.00 90.00000\n [4,]  4 22.00000 76900.97 78.00000\n [5,]  5 35.00000 80000.00 78.50000\n [6,]  6 40.00000 90000.00 88.00000\n [7,]  7 35.43173 70000.00 92.00000\n [8,]  8 28.00000 60112.53 85.00000\n [9,]  9 24.58413 65000.00 80.00000\n[10,] 10 32.00000 75000.00 90.91549\n\n\nBu fonksiyonlar, özellikle zamana bağlı değişen veri setlerinde eksik değerleri doldurmak için kullanılır. Ancak, kullanmadan önce dikkat edilmesi gereken önemli bir nokta, interpolasyonun verilerdeki gerçek ilişkileri ne kadar doğru yansıttığıdır. Doğru bir doldurma stratejisi seçilirken, eksik değerlerin neden kaynaklandığını ve veri setinin özelliklerini anlamak önemlidir.\n\n\nEn Yakın Komşu Yöntemi (KNN) ile Değer Atama\nEn yakın komşu yöntemi (K-Nearest Neighbors, KNN) eksik değerleri doldurmak için kullanılan bir yöntemdir. Temel fikir, bir gözlemin sınıfını veya değerini belirlemek için, o gözleme en yakın komşularının etkisini kullanmaktır. Bu yöntem, eksik değeri olan bir gözlemi, benzer diğer gözlemlerin değerleriyle doldurmayı amaçlar. KNN, benzerlik ya da uzaklık ölçüsüne dayalı olarak en yakın k komşuyu belirleyerek eksik değeri doldurur. Uzaklık ise bu yakınlığın ölçüsünü ifade eder. Uzaklık metrikleri, gözlemler veya özellik vektörleri arasındaki benzerlik veya farklılık düzeyini belirlemek için kullanılır.\nKNN’de yaygın olarak kullanılan uzaklık metrikleri şunlardır:\n\nEuclidean Distance (Öklidyen Uzaklık): İki nokta arasındaki doğrusal mesafeyi ölçer. 2-boyutlu uzayda, iki nokta \\((x_1,y_1)\\) ve \\((x_2,y_2)\\) arasındaki öklidyen uzaklık formülü şu şekildedir:\n\\[\nUzaklık=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\n\\]\nBu formül genelleştirilebilir ve çok boyutlu uzaylarda kullanılabilir.\nManhattan Distance (Manhattan Uzaklığı veya L1 Uzaklığı): İki nokta arasındaki “şehir blokları” tarzında mesafeyi ölçer. Özellik vektörlerindeki farklar toplanır. 2-boyutlu uzayda, iki nokta \\((x_1,y_1)\\) ve \\((x_2,y_2)\\) arasındaki Manhattan uzaklık formülü şu şekildedir:\n\\[\nUzaklık=|x_2-x_1|+|y_2-y_1|\n\\]\nChebyshev Distance (Chebyshev Uzaklığı veya L∞ Uzaklığı): İki nokta arasındaki maksimum farkı ölçer. Özellik vektörlerindeki farkların mutlak değerlerinden en büyüğünü seçer.\nMinkowski Distance: Minkowski uzaklığı, öklidyen, Manhattan ve Chebyshev uzaklıklarını içeren genel bir formülü ifade eder. Bu formül şu şekildedir:\n\\[\nUzaklık=(\\sum_{i=1}^n |x_{i2}-x_{i1}|^p)^{1/p}\n\\]\nBurada \\(p\\) parametresi, uzaklık ölçüsünün tipini belirler. \\(p=2\\) öklidyen uzaklığı, \\(p=1\\) Manhattan uzaklığı, \\(p=\\infty\\) Chebyshev uzaklığını temsil eder.\n\nUzaklık, KNN algoritmasında önemlidir çünkü bu algoritma komşuluk temeline dayalı çalışır. Bir gözlemin sınıfını veya değerini belirlerken, o gözleme en yakın komşularının etkisini alır. Bu nedenle, doğru uzaklık metrikinin seçimi, modelin performansını etkiler. Veri setinin özelliklerine, dağılımına ve problemin niteliğine bağlı olarak en uygun uzaklık metriğinin seçilmesi önemlidir.\nR ile örnek bir uygulama yapmak için DMwR2 paketini kullanabiliriz. DMwR2 paketi, “Data Mining with R: Learning with Case Studies” kitabının örnekleri üzerine dayanarak, eksik verilerle başa çıkmak için kullanılan bir pakettir. Bu paket, özellikle eksik değerleri tahmin etmek ve doldurmak amacıyla bazı yöntemleri içermektedir.\nAşağıda, DMwR2 paketi kullanılarak K-Nearest Neighbors (KNN) algoritması ile eksik değer doldurma işlemi için bir örnek bulunmaktadır. Bu örnekte, DMwR2 paketi ile knnImputation fonksiyonu kullanılarak bir veri setindeki eksik değerler doldurulmuştur.\n\nlibrary(DMwR2)\n\n# KNN ile eksik değerleri doldur\n# k parametresi, verilen bir noktaya en yakın komşuların sayısıdır. \n# Bu örnekte uzaklığa (öklit) göre en yakın 3 komşu belirlenir\n# Dah sonra mesafenin ağırlıklı ortalaması hesaplanır.\n# Ağırlıklandırma, her komşuya 1 / d ağırlığının verilmesini içerir.\n# d komşuya olan uzaklıktır.\ndata_imputed &lt;- knnImputation(data, k = 3)\n\n# Sonucu göster\nprint(data_imputed)\n\n   ID      Age   Income    Score\n1   1 25.00000 50000.00 80.00000\n2   2 30.00000 60000.00 85.00000\n3   3 33.74673 75000.00 90.00000\n4   4 22.00000 55135.54 78.00000\n5   5 35.00000 80000.00 86.50176\n6   6 40.00000 90000.00 88.00000\n7   7 34.97289 70000.00 92.00000\n8   8 28.00000 68186.84 85.00000\n9   9 31.87227 65000.00 80.00000\n10 10 32.00000 75000.00 86.13467\n\n\nBu örnekte, knnImputation fonksiyonu, K-Nearest Neighbors algoritmasını kullanarak eksik değerleri doldurur. k parametresi, her bir eksik değeri doldurmak için kullanılacak olan komşu sayısını belirler. Bu örnekte k = 3 olarak seçildi.\nBu örnekte, KNN algoritması kullanılarak eksik değerlerin doldurulduğu bir senaryoyu görmüş olduk. Ancak, KNN’nin avantajlarına rağmen, kullanılan algoritmanın ve komşuluk sayısının seçimi, problem bağlamına bağlı olarak değişebilir. Eksik değer doldurma stratejilerini seçerken, veri setinin yapısı, eksik değerlerin neden kaynaklandığı ve analizin amacı göz önüne alınmalıdır.\n\n\n\n\n\n\nTavsiye\n\n\n\nEksik verilerin analiz edilmesi ve imputasyon konusunda R içerisinde çeşitli kütühaneler bulunmaktadır. Bunlardan en çok bilinenleri mice, VIM, missForest, imputation, mi, Amelia ve Hmisc paketleridir.",
    "crumbs": [
      "Veri Ön İşleme"
    ]
  },
  {
    "objectID": "data_preprocess.html#aykırı-değer-analizi",
    "href": "data_preprocess.html#aykırı-değer-analizi",
    "title": "Veri Ön İşleme",
    "section": "Aykırı Değer Analizi",
    "text": "Aykırı Değer Analizi\nAykırı değer, diğer gözlemlerden uzak olan, yani diğer veri noktalarından önemli ölçüde farklı olan bir veri noktası olan bir değer veya gözlemdir. Bu dokümanda, tanımlayıcı istatistikler (minimum, maksimum, histogram, kutu grafiği ve yüzdelikler dahil) gibi basit teknikler ve Z-Skoru ile aykırı değer analizi anlatılacaktır.\n\nMinumum ve Maximum\n\nlibrary(ggplot2)\n\n# mpg verisindeki hwy değişkeni üzerinden inceleyelim\nsummary(mpg$hwy)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  12.00   18.00   24.00   23.44   27.00   44.00 \n\nmin(mpg$hwy)\n\n[1] 12\n\nmax(mpg$hwy)\n\n[1] 44\n\n\n\n\nHistogram\n\n# grafiğin sağ tarafında kalan gözlemler şüpheli görünüyor.\nggplot(mpg) +\n  aes(x = hwy) +\n  geom_histogram(bins = 20, fill = \"blue\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\nBoxplot\nBoxplot, beş konum ölçüsü kullanarak verilerin grafiksel bir sunumunu verir: en küçük değer (min), birinci çeyreklik (\\(Q_1\\)) , medyan, üçüncü çeyreklik (\\(Q_3\\)) en büyük değer. Kutunun farklı bölümleri arasındaki boşluk, verilerdeki dağılım (yayılma) ve çarpıklık derecesini gösterir. Bir boxplot grafiği, çeyrekler arası aralık (IQR) kriteri kullanılarak şüpheli bir aykırı değer olarak sınıflandırılan herhangi bir gözlemi görüntüleyerek nicel bir değişkeni görselleştirmeye yardımcı olur.\n\\(I = [Q_1-1.5 * IQR ; Q_3 + 1.5 * IQR]\\)\n\n\n\n\n\nIQR ise üçüncü ve birinci çeyrek arasındaki farktır. R içerisindeki IQR() fonksiyonu bu amaçla kullanılabilir.\n\n# temel istatistiklere erişim\nsummary(mpg$hwy)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  12.00   18.00   24.00   23.44   27.00   44.00 \n\nfivenum(mpg$hwy)\n\n[1] 12 18 24 27 44\n\nggplot(mpg) +\n  aes(x = \"\", y = hwy) +\n  geom_boxplot(fill = \"blue\") +\n  theme_minimal()\n\n\n\n\n\n\n\n# outlier değerlerine erişim\nboxplot.stats(mpg$hwy)$out\n\n[1] 44 44 41\n\n# outier olarak görülen değerlerin konumları\nhwy_out &lt;- boxplot.stats(mpg$hwy)$out\nhwy_out_sira &lt;- which(mpg$hwy %in% c(hwy_out))\nhwy_out_sira\n\n[1] 213 222 223\n\n# outlier olarak görülen satırlar\nmpg[hwy_out_sira, ]\n\n# A tibble: 3 × 11\n  manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n  &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n1 volkswagen   jetta        1.9  1999     4 manua… f        33    44 d     comp…\n2 volkswagen   new beetle   1.9  1999     4 manua… f        35    44 d     subc…\n3 volkswagen   new beetle   1.9  1999     4 auto(… f        29    41 d     subc…\n\n\n\n\nYüzdelikler (Percentiles)\nBu aykırı değer tespiti yöntemi, yüzdelik dilimlere dayalıdır. Yüzdelikler yöntemiyle, 2,5 ve 97,5 yüzdelik dilimlerin oluşturduğu aralığın dışında kalan tüm gözlemler potansiyel aykırı değerler olarak kabul edilecektir. Aralığı oluşturmak için 1 ve 99 veya 5 ve 95 yüzdelikler gibi diğer yüzdelikler de düşünülebilir.\n\nalt_sinir &lt;- quantile(mpg$hwy, 0.025)\nalt_sinir\n\n2.5% \n  14 \n\nust_sinir &lt;- quantile(mpg$hwy, 0.975)\nust_sinir\n\n 97.5% \n35.175 \n\n# Bu yönteme göre, 14'ün altındaki ve 35.175'in üzerindeki tüm gözlemler,\n# potansiyel aykırı değerler olarak kabul edilecektir.\n\noutlier_sira &lt;- which(mpg$hwy &lt; alt_sinir | mpg$hwy &gt; ust_sinir)\noutlier_sira\n\n [1]  55  60  66  70 106 107 127 197 213 222 223\n\n# Bu yönteme göre 11 adet outlier bulunmuştur.\nmpg[outlier_sira,]\n\n# A tibble: 11 × 11\n   manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n 1 dodge        dakota pi…   4.7  2008     8 auto… 4         9    12 e     pick…\n 2 dodge        durango 4…   4.7  2008     8 auto… 4         9    12 e     suv  \n 3 dodge        ram 1500 …   4.7  2008     8 auto… 4         9    12 e     pick…\n 4 dodge        ram 1500 …   4.7  2008     8 manu… 4         9    12 e     pick…\n 5 honda        civic        1.8  2008     4 auto… f        25    36 r     subc…\n 6 honda        civic        1.8  2008     4 auto… f        24    36 c     subc…\n 7 jeep         grand che…   4.7  2008     8 auto… 4         9    12 e     suv  \n 8 toyota       corolla      1.8  2008     4 manu… f        28    37 r     comp…\n 9 volkswagen   jetta        1.9  1999     4 manu… f        33    44 d     comp…\n10 volkswagen   new beetle   1.9  1999     4 manu… f        35    44 d     subc…\n11 volkswagen   new beetle   1.9  1999     4 auto… f        29    41 d     subc…\n\n# Sınırları biraz daha küçültelim\nalt_sinir &lt;- quantile(mpg$hwy, 0.01)\nust_sinir &lt;- quantile(mpg$hwy, 0.99)\n\noutlier_sira &lt;- which(mpg$hwy &lt; alt_sinir | mpg$hwy &gt; ust_sinir)\n\nmpg[outlier_sira, ]\n\n# A tibble: 3 × 11\n  manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n  &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n1 volkswagen   jetta        1.9  1999     4 manua… f        33    44 d     comp…\n2 volkswagen   new beetle   1.9  1999     4 manua… f        35    44 d     subc…\n3 volkswagen   new beetle   1.9  1999     4 auto(… f        29    41 d     subc…\n\n# Buna göre IQR ile elde edildiği gibi 3 adet outlier bulundu.\n\n\n\nZ-Skor Yöntemi\nAykırı değerlerin tespitinde ortalama ve standart sapmanın kulllanıldığı en bilinen yöntemlerdendir ve aşağıdaki şekilde hesaplanır.\n\\[\nZ_i = \\frac{(X_1-\\mu)}{\\sigma}\n\\]\n\n\n\n\n\n\nstd_z &lt;- function(x){\n  \n  z=(x-mean(x))/sd(x)\n  return(z)\n}\n\nmpg$hwy_std &lt;- std_z(mpg$hwy)\nmpg[,c(\"hwy\",\"hwy_std\")]\n\n# A tibble: 234 × 2\n     hwy hwy_std\n   &lt;int&gt;   &lt;dbl&gt;\n 1    29   0.934\n 2    29   0.934\n 3    31   1.27 \n 4    30   1.10 \n 5    26   0.430\n 6    26   0.430\n 7    27   0.598\n 8    26   0.430\n 9    25   0.262\n10    28   0.766\n# ℹ 224 more rows\n\n# -3 ve +3 sapma dışında kalanları aykırı değer olarak kabul ediyoruz.\noutliers_zskor &lt;- which(mpg$hwy_std &lt; -3 | mpg$hwy_std &gt; +3)\noutliers_zskor\n\n[1] 213 222\n\nmpg[outliers_zskor,c() ]\n\n# A tibble: 2 × 0\n\n# bu yönteme göre 2 adet aykırı değer bulunmuştur.",
    "crumbs": [
      "Veri Ön İşleme"
    ]
  },
  {
    "objectID": "data_preprocess.html#veri-normalleştirme",
    "href": "data_preprocess.html#veri-normalleştirme",
    "title": "Veri Ön İşleme",
    "section": "Veri Normalleştirme",
    "text": "Veri Normalleştirme\nDeğişkenler farklı ölçeklerde ölçüldüğünde, genellikle analize eşit katkıda bulunmazlar. Örneğin, bir değişkenin değerleri 0 ile 100.000 arasında ve başka bir değişkenin değerleri 0 ile 100 arasında değişiyorsa, daha büyük aralığa sahip değişkene analizde daha büyük bir ağırlık verilecektir. Değişkenleri normalleştirerek, her bir değişkenin analize eşit katkı sağladığından emin olabiliriz. Değişkenleri normalleştirmek için (veya ölçeklendirmek) genellikle min-max ya da z dönüşümü yöntemleri kullanılır.\n\n# min-max dönüşümleri\n\n# 0 ile 1 arasi dönüşüm\nstd_0_1 &lt;- function(x) {\n  (x - min(x)) / (max(x) - min(x))\n}\n\n#-1 ile +1 arası dönüşüm \nstd_1_1 &lt;- function(x) {\n  ((x - mean(x)) / max(abs(x - mean(x))))\n}\n\n# a ile b arası dönüşüm \nstd_min_max &lt;- function(x,a,b) {\n  # a min değer\n  # b max değer\n  (a + ((x - min(x)) * (b - a)) / (max(x) - min(x)))\n}\n\n# dat isimli yeni bir tablo üretelim\nset.seed(12345)\ndat &lt;- data.frame(x = rnorm(20, 10, 3),\n                  y = rnorm(20, 30, 8),\n                  z = rnorm(20, 25, 5))\ndat\n\n           x        y        z\n1  11.756586 36.23698 30.64255\n2  12.128398 41.64628 13.09821\n3   9.672090 24.84537 19.69867\n4   8.639508 17.57490 29.68570\n5  11.817662 17.21832 29.27226\n6   4.546132 44.44078 32.30365\n7  11.890296 26.14682 17.93451\n8   9.171448 34.96304 27.83702\n9   9.147521 34.89699 27.91594\n10  7.242034 28.70151 18.46601\n11  9.651257 36.49499 22.29807\n12 15.451936 47.57467 34.73846\n13 11.111884 46.39352 25.26795\n14 11.560649 43.05957 26.75831\n15  7.748404 32.03417 21.64512\n16 12.450700 33.92951 26.38977\n17  7.340927 27.40731 28.45586\n18  9.005267 16.70360 29.11898\n19 13.362138 44.14187 35.72533\n20 10.896171 30.20641 13.26528\n\nsummary(dat)\n\n       x                y               z        \n Min.   : 4.546   Min.   :16.70   Min.   :13.10  \n 1st Qu.: 8.914   1st Qu.:27.09   1st Qu.:21.16  \n Median :10.284   Median :34.41   Median :27.30  \n Mean   :10.230   Mean   :33.23   Mean   :25.53  \n 3rd Qu.:11.836   3rd Qu.:42.00   3rd Qu.:29.38  \n Max.   :15.452   Max.   :47.57   Max.   :35.73  \n\napply(dat, 2, std_0_1)\n\n              x          y           z\n [1,] 0.6611575 0.63274053 0.775368144\n [2,] 0.6952505 0.80796300 0.000000000\n [3,] 0.4700211 0.26373477 0.291705877\n [4,] 0.3753393 0.02822392 0.733080320\n [5,] 0.6667578 0.01667340 0.714808256\n [6,] 0.0000000 0.89848463 0.848779748\n [7,] 0.6734179 0.30589231 0.213738973\n [8,] 0.4241150 0.59147416 0.651378062\n [9,] 0.4219211 0.58933460 0.654866001\n[10,] 0.2471988 0.38864587 0.237228478\n[11,] 0.4681108 0.64109819 0.406585628\n[12,] 1.0000000 1.00000000 0.956385878\n[13,] 0.6020419 0.96173940 0.537838847\n[14,] 0.6431912 0.85374322 0.603705080\n[15,] 0.2936301 0.49659993 0.377728555\n[16,] 0.7248037 0.55799517 0.587417289\n[17,] 0.2562668 0.34672297 0.678727553\n[18,] 0.4088772 0.00000000 0.708033996\n[19,] 0.8083774 0.88880212 1.000000000\n[20,] 0.5822623 0.43739366 0.007383637\n\nlibrary(dplyr)\n\ndat %&gt;% mutate_all(std_0_1) %&gt;% summary()\n\n       x                y                z         \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.4005   1st Qu.:0.3365   1st Qu.:0.3562  \n Median :0.5261   Median :0.5737   Median :0.6275  \n Mean   :0.5211   Mean   :0.5354   Mean   :0.5492  \n 3rd Qu.:0.6684   3rd Qu.:0.8194   3rd Qu.:0.7194  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n\ndat %&gt;% mutate_all(std_1_1) %&gt;% summary()\n\n       x                   y                  z          \n Min.   :-1.000000   Min.   :-1.00000   Min.   :-1.0000  \n 1st Qu.:-0.231502   1st Qu.:-0.37143   1st Qu.:-0.3514  \n Median : 0.009603   Median : 0.07154   Median : 0.1426  \n Mean   : 0.000000   Mean   : 0.00000   Mean   : 0.0000  \n 3rd Qu.: 0.282624   3rd Qu.: 0.53057   3rd Qu.: 0.3098  \n Max.   : 0.918881   Max.   : 0.86789   Max.   : 0.8207  \n\ndat %&gt;% mutate_all(std_min_max, a = -2, b = 2) %&gt;% summary()\n\n       x                  y                 z          \n Min.   :-2.00000   Min.   :-2.0000   Min.   :-2.0000  \n 1st Qu.:-0.39803   1st Qu.:-0.6539   1st Qu.:-0.5751  \n Median : 0.10457   Median : 0.2947   Median : 0.5102  \n Mean   : 0.08455   Mean   : 0.1415   Mean   : 0.1970  \n 3rd Qu.: 0.67369   3rd Qu.: 1.2776   3rd Qu.: 0.8775  \n Max.   : 2.00000   Max.   : 2.0000   Max.   : 2.0000  \n\ndat %&gt;% mutate_all(std_z) %&gt;% summary()\n\n       x                  y                 z          \n Min.   :-2.27173   Min.   :-1.7088   Min.   :-1.9165  \n 1st Qu.:-0.52591   1st Qu.:-0.6347   1st Qu.:-0.6735  \n Median : 0.02182   Median : 0.1223   Median : 0.2732  \n Mean   : 0.00000   Mean   : 0.0000   Mean   : 0.0000  \n 3rd Qu.: 0.64204   3rd Qu.: 0.9067   3rd Qu.: 0.5937  \n Max.   : 2.08745   Max.   : 1.4831   Max.   : 1.5729  \n\n# Yapılan dönüşümler verinin dağılımını değiştirmemektedir.\npar(mfrow=c(2,1))\nhist(dat$x,main=\"original data\",col=\"blue\")\nhist(std_0_1(dat$x),main=\"normalize data\",col=\"red\")",
    "crumbs": [
      "Veri Ön İşleme"
    ]
  },
  {
    "objectID": "statistics.html",
    "href": "statistics.html",
    "title": "R ile Temel İstatistik",
    "section": "",
    "text": "Merkezi Eğilim Ölçüleri\nİstatistik; amacın belirlenmesi, çalışmanın planlanması, verilerin toplanması, değerlendirilmesi ve karara varılması sürecini içeren bir bilim dalıdır. İstatistik bilimi içinde örneklemden elde edilen bilgileri kitlelere genelleme, tahminler yapma, değişkenler arasındaki ilişkileri ortaya çıkarma gibi konular yer almaktadır.\nUygulamalı istatistikler iki alana ayrılabilir: tanımlayıcı istatistikler ve çıkarımsal istatistikler. Tanımlayıcı istatistikler, tabloları, grafikleri ve özet ölçüleri kullanarak verileri düzenleme, görüntüleme ve tanımlama yöntemlerinden oluşur. Buna karşılık çıkarımsal istatistikler, bir popülasyon hakkında kararlar veya tahminler yapmak için örnek sonuçlarını kullanan yöntemlerden oluşur.\nTanımlayıcı istatistik, bir dizi değeri veya bir veri kümesini özetlemeyi, tanımlamayı ve sunmayı amaçlayan bir istatistik dalıdır. Tanımlayıcı istatistikler genellikle herhangi bir istatistiksel analizin ilk adımı ve önemli bir parçasıdır. Verilerin kalitesini kontrol etmeyi sağlar ve net bir genel bakışa sahip olarak verileri anlamaya yardımcı olur. Tanımlayıcı istatistikler, merkezi eğilim ölçüleri ve dağılım ölçüleri olmak üzere ikiye ayrılır.\nDağılımın konumu hakkında bilgi veren ölçümlerdir. Aritmetik ortalama, geometrik ortalama, harmonik ortalama, düzeltilmiş ortalama, ortanca, çeyrekler, yüzdelikler konum ölçülerine örnek olarak verilebilir.",
    "crumbs": [
      "R ile Temel İstatistik"
    ]
  },
  {
    "objectID": "statistics.html#merkezi-eğilim-ölçüleri",
    "href": "statistics.html#merkezi-eğilim-ölçüleri",
    "title": "R ile Temel İstatistik",
    "section": "",
    "text": "Aritmetik Ortalama\n\nGünlük hayatta en sık kullanılan merkezi eğilim ölçüsüdür.\nÜzerinde inceleme yapılan veri setindeki elemanların toplanıp incelenen eleman sayısına bölünmesiyle elde edilir.\nKonum olarak verilerin en çok hangi değer etrafında toplandığının ya da yoğunlaştığının sayısal bir ölçüsüdür.\nHem kitle hem de örneklem için hesaplanır.\nDağılışların yerinin belirlenmesinde en çok kullanılan yer ölçüsü aritmetik ortalamadır; ve tek başına ortalama sözcüğünden aritmetik ortalama anlaşılır.\nAritmetik ortalama bütün değerlerin ağırlığını eşit kabul ettiğinden dağılımı her zaman en iyi şekilde temsil etmeyebilir. Ayrıca aritmetik ortalama, veri kümesindeki aşırı değerlerden çok kolay etkilenir.\n\n\\[ \\mu = \\frac{1}{N}\\sum_{i=1}^NX_i \\]\n\nmean(airquality$Wind)\n\n[1] 9.957516\n\nmean(airquality$Ozone, na.rm = TRUE) # NA'ler kaldırılarak ortalama hesaplanır\n\n[1] 42.12931\n\n\n\n\nGeometrik Ortalama\n\nPeriyodik artışlar veya azalmalar (değişim oranları) içeren enflasyon veya nüfus değişiklikleri gibi konuları incelerken, geometrik ortalama, incelenen tüm dönem boyunca ortalama değişikliği bulmak için daha uygundur.\nEğer veriler sıfır ya da negatif değerler içeriyorsa geometrik ortalama hesaplanamaz.\nGeometrik ortalama, uç değerlerden aritmetik ortalamaya göre daha az etkilenmektedir.\nGeometrik Ortalama &lt;= Aritmetik Ortalama\n\n\\[ G.O. = ^n\\sqrt{\\prod_{i=1}^{n}X_i} \\]\n\n# R programında hazır geometrik ortalama fonksiyonu yoktur.\n# 1. yol\ngeo_mean &lt;- function(x){\n  x &lt;- na.omit(x)\n  (prod(x))^(1/length(x))\n}\n\nround(geo_mean(airquality$Wind),3)\n\n[1] 9.273\n\nround(geo_mean(airquality$Ozone),3)\n\n[1] 30.524\n\n# 2. yol\nlibrary(psych)\n\nWarning: package 'psych' was built under R version 4.4.3\n\nround(geometric.mean(airquality$Wind),3)\n\n[1] 9.273\n\nround(geometric.mean(airquality$Ozone),3)\n\n[1] 30.524\n\n\n\n\nMedyan (Ortanca)\n\nGözlem değerleri küçükten büyüğe sıralandığında ortada kalan gözlem değeridir.\nBir seride yer alan gözlemlerin tümünün hesaba katılmadığı ortalamalardan biridir.\nBasit serilerde seri tek sayıda gözlemden oluşuyorsa serinin gözlem değerleri küçükten büyüğe sıralandığında tam ortada yer alan gözlem değeridir.\nSeri çift sayıda gözlemden oluşuyorsa ortada kalan iki gözlem değerinin aritmetik ortalaması medyandır.\nMedyan, ölçümlerin %50’sinin üzerinde, %50’sinin aşağısında yer aldığı merkezi değerdir.\nDağılımdaki aşırı değerlerden etkilenmez.\nAritmetik ortalamaya kıyasla daha tutarlı bir sonuç elde edilir.\nHer bir veri seti için bir tek medyan söz konusudur.\nMedyanın zayıf tarafı serideki bütün değerleri dikkate almaması sebebi ile matematik işlemlere elverişli değildir.\nGözlem sayısı (n) tek ise , \\(\\widetilde{X} = X_{\\frac{n+1}{2}}\\)\nGözlem sayısı (n) çift ise , \\(\\widetilde{X} = \\frac{X_\\frac{n}{2}+X_{\\frac{n+1}{2}}}{2}\\)\n\n\nmedian(airquality$Wind)\n\n[1] 9.7\n\nmedian(airquality$Ozone,na.rm = TRUE)\n\n[1] 31.5\n\n\n\n\nMod (Tepe değeri)\n\nEn sık ortaya çıkan (en yüksek frekanslı) ölçümdür.\nDağılımdaki aşırı değerlerden etkilenmez\nHer dağılımda tepe değeri bulunmayabilir.\nBazı dağılımlarda birden fazla tepe değeri bulunabilir.\nTepe değeri aritmetik işlemler için elverişli değildir.\nTüm veri değerlerini göz önünde bulundurmadığı için tutarlı olmayan bir merkezi eğilim ölçüsüdür.\nGözlem sayısı az olduğunda tepe değer güvenilir bir ölçü değildir.\n\n\n\n\n\n\n\n# R programında hazır mod fonksiyonu yoktur.\n\nlibrary(DescTools)\n\nWarning: package 'DescTools' was built under R version 4.4.3\n\nMode(airquality$Wind)\n\n[1] 11.5\nattr(,\"freq\")\n[1] 15\n\nMode(airquality$Solar.R,na.rm = TRUE)\n\n[1] 238 259\nattr(,\"freq\")\n[1] 4\n\n\n\n\nÇeyreklikler\n\nBirinci Bölen ilk yüzde 25 nci noktadır ve verinin ¼ kadarı birinci bölen içerisinde kalır.\nİkinci Bölen ilk yüzde 50 nci noktadır ve verinin yarısı bu noktanın altında kalır( ½) aynı zamanda ikinci bölen medyan olarak ta bilinir.\nÜçüncü Bölen ilk yüzde 75 nci veri kümesidir ve bütün verinin ¾ kadarı bu noktanın altında kalır.\nGözlem sayısı (n) tek ise , \\(Q_1 = X_{\\frac{n+1}{4}}\\)\nGözlem sayısı (n) çift ise , \\(Q_1 = \\frac{X_\\frac{n}{4}+X_{\\frac{n}{4}+1}}{2}\\)\nGözlem sayısı (n) tek ise , \\(Q_3 = X_{\\frac{3(n+1)}{4}}\\)\nGözlem sayısı (n) çift ise , \\(Q_3 = \\frac{X_\\frac{3n}{4}+X_{\\frac{3n}{4}+1}}{2}\\)\n\n\n\n\n\n\n\nquantile(airquality$Wind,na.rm = TRUE)\n\n  0%  25%  50%  75% 100% \n 1.7  7.4  9.7 11.5 20.7 \n\nmedian(airquality$Wind,na.rm = TRUE)\n\n[1] 9.7\n\nquantile(airquality$Wind,na.rm = TRUE,probs = 0.75) #Q3\n\n 75% \n11.5 \n\nquantile(airquality$Wind,na.rm = TRUE,probs = 0.25) #Q1\n\n25% \n7.4 \n\nquantile(airquality$Wind,na.rm = TRUE,probs = c(0.20,0.50,0.80)) # %20,%50,%80\n\n  20%   50%   80% \n 6.90  9.70 12.96 \n\nquantile(airquality$Solar.R,na.rm = TRUE)\n\n    0%    25%    50%    75%   100% \n  7.00 115.75 205.00 258.75 334.00 \n\nmedian(airquality$Solar.R,na.rm = TRUE)\n\n[1] 205",
    "crumbs": [
      "R ile Temel İstatistik"
    ]
  },
  {
    "objectID": "statistics.html#dağılım-ölçüleri",
    "href": "statistics.html#dağılım-ölçüleri",
    "title": "R ile Temel İstatistik",
    "section": "Dağılım Ölçüleri",
    "text": "Dağılım Ölçüleri\nOrtalama, medyan ve mod gibi merkezi eğilim ölçüleri, bir veri setinin dağılımının bütün resmini ortaya koymaz. Aynı ortalamaya sahip iki veri seti tamamen farklı yayılımlara sahip olabilir. Bir veri seti için gözlem değerleri arasındaki farklılık, diğer veri seti için olduğundan çok daha büyük veya daha küçük olabilir. Bu nedenle, ortalama, medyan veya mod tek başına genellikle bir veri kümesinin dağılımının şeklini ortaya çıkarmak için yeterli bir ölçü değildir. Bu yüzden veri değerleri arasındaki varyasyon hakkında bazı bilgiler sağlayabilecek bir ölçülere de ihtiyaç vardır. Bu ölçülere dağılım (yayılım) ölçüleri denir. Birlikte ele alınan merkezi eğilim ve dağılım ölçüleri, tek başına merkezi eğilim ölçülerinden ziyade bir veri setinin daha iyi bir resmini verir. Değişim aralığı, çeyrekler arası genişlik, varyans, standart sapma, basıklık, çarpıklık, min, max başlıca dağılım ölçüleri arasındadır.\n\nDeğişim Aralığı (Açıklık)\n\nVeri setindeki en büyük değer ile en küçük değer arasındaki farktır.\nEn basit dağılım ölçüsü olmakla birlikte uç ve aykırı değerlerden etkilenmesi olumsuz yönüdür.\nSerinin sadece 2 gözlemine bağlı olarak hesaplanan bu ölçü değişkenliğin şekli hakkında çok fazla bilgi vermediğinden diğer değişkenlik ölçüleri kadar sık kullanılmaz.\n\n\\[D.A = max(X)-min(X)\\]\n\n# 1. yol\nmax(airquality$Ozone,na.rm = TRUE)-min(airquality$Ozone,na.rm = TRUE)\n\n[1] 167\n\n# 2. yol\nrange(airquality$Ozone,na.rm = TRUE)\n\n[1]   1 168\n\nrange(airquality$Ozone,na.rm = TRUE)[2]-range(airquality$Ozone,na.rm = TRUE)[1]\n\n[1] 167\n\n\n\n\nÇeyrekler Arası Genişlik\n\nDağılımdaki verilerin ortadaki % 50’sinin yer aldığı aralığı belirlemek için kullanılır.\nAşırı uç değerlerden etkilenmez. Çünkü çeyreklikler arası genişlik dağılımdaki değerlerin merkezdeki %50’si ile ilgilenir.\nÇeyrekler arası bir genişlik, değerlerin büyük kısmının nerede olduğunu gösteren bir ölçüdür.\nÇeyrek Sapma 3. çeyrek ile 1. çeyrek arasındaki farktır.\nIQR (Interquartile Range) olarak ifade edilir.\n\n\\[IQR=Q_3-Q1\\]\n\n# 1.yol\nq3 &lt;- quantile(airquality$Wind,na.rm = TRUE,probs = 0.75) #Q3\nq1 &lt;- quantile(airquality$Wind,na.rm = TRUE,probs = 0.25) #Q1\nq3-q1\n\n75% \n4.1 \n\n# 2. yol\nIQR(airquality$Wind,na.rm = TRUE)\n\n[1] 4.1\n\n\n\n\nVaryans ve Standart Sapma\nGözlem değerlerinin aritmetik ortalamadan sapmaları dikkate alınarak farklı değişkenlik ölçüleri geliştirilebilir. Ancak gözlemlerin aritmetik ortalamadan sapmalarının her zaman sıfıra eşittir. Bu sorunu ortadan kaldırmak için gözlemlerin aritmetik ortalamadan olan sapmalarının karelerinin toplamının gözlem sayısına oranı değişkenlik ölçüsü olarak yorumlanabilir. Bu ölçü varyans olarak adlandırılır.\n\nBir dağılımda değerler aritmetik ortalamadan uzaklaştıkça dağılımın yaygınlığı artar.\nVaryansın karekökü standart sapmadır. Genel olarak, bir veri kümesi için standart sapmanın daha düşük bir değeri, o veri kümesinin değerlerinin ortalama etrafında nispeten daha küçük bir aralığa yayıldığını gösterir. Buna karşılık, bir veri kümesi için standart sapmanın daha büyük bir değeri, o veri kümesinin değerlerinin, ortalama etrafında nispeten daha geniş bir aralığa yayıldığını gösterir.\nKitle varyansı \\(\\sigma^2\\) ile standart sapma ise \\(\\sigma\\) ile gösterilmektedir. Örneklem standart sapması ise \\(s\\) ile ifade edilir.\n\n\\[s= \\sqrt{\\sum_{i=1}^N\\frac{(x_i-\\bar{x})^2}{n-1}}\\]\n\nvar(airquality$Wind,na.rm=TRUE)\n\n[1] 12.41154\n\nsd(airquality$Wind,na.rm=TRUE)\n\n[1] 3.523001\n\nvar(airquality$Solar.R,na.rm=TRUE)\n\n[1] 8110.519\n\nsd(airquality$Solar.R,na.rm=TRUE)\n\n[1] 90.05842\n\n\n\n\nDeğişim Katsayısı\n\nFarklı serilerin değişkenliklerinin karşılaştırılmasında, farklı birimlerle ölçülmüş veri setleri söz konusu olduğundan standart sapma kullanışlı değildir.\nBunun yerine ilgili serilerin standart sapmaları serilerin ortalama değerinin yüzdesi olarak ifade edilir ve gözlem değerlerinin büyüklüklerinden kaynaklanan farklılık ortadan kalkmış olur.\nElde edilen bu yeni değişkenlik ölçüsü kullanılarak serilerin birbirlerine göre daha değişken ya da daha homojen oldukları konusunda yorum yapılabilir.\nBu değer ne kadar küçükse dağılım o kadar homojendir, değişkenlik azdır. Yüzdesel olarak ifade edilir.\nDeğişim Katsayısı standart sapmanın aritmetik ortalamaya bölünüp 100 ile çarpılmasıyla elde edilir.\n\n\\[D.K. = \\frac{S}{\\bar{X}}\\times{100}\\]\n\ndk_wind &lt;- sd(airquality$Wind,na.rm=TRUE)/mean(airquality$Wind,na.rm=TRUE)\ndk_wind\n\n[1] 0.3538032\n\ndk_solar &lt;- sd(airquality$Solar.R,na.rm=TRUE)/mean(airquality$Solar.R,na.rm=TRUE)\ndk_solar\n\n[1] 0.4843634\n\n\n\n\nÇarpıklık ve Basıklık\n\nBir dağılımın normal dağılıma göre çarpık olup olmadığını belirlemede kullanılır. Simetrik dağılımlarda ortalama, ortanca ve tepe değeri birbirine eşittir.\nÇarpıklık katsayısı 0 ise dağılım simetriktir, 0’dan küçük ise sola çarpıktır (negatif çarpıklık), 0’dan büyük ise sağa çarpıktır (pozitif çarpıklık).\nPozitif çarpıklıkta sağ kuyruk daha uzun iken negatif çarpıklıkta sol kuyruk daha uzundur.\nAritmetik Ortalama, Medyan ve Mod arasındaki ilişkilere göre de çarpıklık belirlenebilir.\n\nMod &lt; Medyan &lt; Ortalama ise, dağılım sağa-çarpık yani (+) yöne eğilimli dağılımdır.\nOrtalama &lt; Medyan &lt; Mod ise, dağılım sola-çarpık yani (-) yöne eğilimli dağılımdır.\nOrtalama = Mod = Medyan ise, dağılım simetrik dağılımdır.\n\n\n\n\n\n\n\n\nBir dağılımın normal dağılıma göre basık olup olmadığını belirlemede kullanılır.\nBasıklık katsayısı sıfırdan büyükse normal dağılıma göre daha sivri, küçük ise daha basıktır.\nBasıklık katsayısı 3’e eşit ise seri normal dağılıma (mesokurtic) sahiptir. Eğer3’ten küçük ise, bir platykurtik dağılımı gösterir (daha kısa kuyruklu normal dağılımdan daha düz). Eğer 3’ten büyük ise, bir leptokurtik dağılımı gösterir (daha uzun kuyruklu normal dağılımdan daha doruğa).\nİki veya daha fazla simetrik dağılım karşılaştırıldığında aralarındaki fark basıklık ile incelenir.\n\n\n\n\n\n\n\nlibrary(moments)\nskewness(airquality$Ozone,na.rm = TRUE) # sağa çarpık\n\n[1] 1.225681\n\nkurtosis(airquality$Ozone,na.rm = TRUE) # sivri\n\n[1] 4.184071\n\nhist(airquality$Ozone,freq = FALSE)\nlines(density(airquality$Ozone,na.rm = TRUE),col = 2, lwd = 2)\n\n\n\n\n\n\n\nskewness(airquality$Solar.R,na.rm = TRUE) # sola çarpık\n\n[1] -0.4236342\n\nkurtosis(airquality$Solar.R,na.rm = TRUE) # sivri\n\n[1] 2.023567\n\nhist(airquality$Solar.R,freq = FALSE)\nlines(density(airquality$Solar.R,na.rm = TRUE),col = 2, lwd = 2)\n\n\n\n\n\n\n\n# normal dağılımdan veri üretelim\nnorm_vec &lt;- rnorm(1000,10,5)\nskewness(norm_vec) # sola çarpık\n\n[1] -0.1865362\n\nkurtosis(norm_vec) # sivri\n\n[1] 2.867664\n\nhist(norm_vec,freq = FALSE,col=\"#116AF3\") # renk kodları da kullanılabilir.\nlines(density(norm_vec),col = \"#F33011\", lwd = 2)",
    "crumbs": [
      "R ile Temel İstatistik"
    ]
  },
  {
    "objectID": "statistics.html#ilişki-ölçüleri",
    "href": "statistics.html#ilişki-ölçüleri",
    "title": "R ile Temel İstatistik",
    "section": "İlişki Ölçüleri",
    "text": "İlişki Ölçüleri\nÖnceki bölümlerde, bir dağılımı tanımlayan ve özet istatistikleri hesaplayan tek bir değişkene odaklanmıştık. Tek bir değişkeni tanımlayan istatistiklere tek değişkenli istatistikler denir. İki değişken arasındaki ilişkiyi incelersek, iki değişkenli istatistiklere atıfta bulunuruz. Birkaç değişken arasındaki ilişkiler aynı anda incelenirse, çok değişkenli istatistiklere atıfta bulunuruz. İlişki ölçüleri, iki değişken arasındaki ilişkinin boyutunu özetlemek için araçlar sağlar.\nİlişkiyi ölçmek için birçok araç türü olmasına rağmen, kovaryans ve Pearson korelasyon katsayıları “sayısal” veri türü için en bilinen ve yaygın araçlardır. Kovaryans ve korelasyon arasındaki temel fark, kovaryans, değerin işaretine (+’ve veya -’ve) bağlı olarak ilişkinin yönünü gösterir. Ancak korelasyon, değişkenler arasındaki “doğrusal” ilişkinin gücünü gösterir.\nKategorik veriler için ki-kare testi kullanılmkatadır. Spearman rho ve Kendall Tau korelasyon katsayıları da vardır ancak bunlar parametrik olmayan testlerdir ve yaygın olarak kullanılmazlar.\nDeğişkenler arasındaki ilişkiyi çizgi veya saçılım grafiği çizerek de incelenebilir. Ancak, bu grafiklere bakarak ilişkiden emin olmak her zaman mümkün olmayabilir. İstatistikte testler her zaman görsel araçlardan daha güçlüdür. Görsel araçlar fikir verir, testler ise fikirleri doğrular.\n\nKovaryans\nKovaryans, iki değişkenin ortak değişkenliğinin bir ölçüsüdür. Kovaryans (−∞,∞) aralığında herhangi bir değer alabilir. Bir değişkenin büyük/küçük değerleri esas olarak diğer değişkenin daha büyük/küçük değerlerine karşılık geliyorsa kovaryans pozitiftir. Değişkenler zıt davranış gösterme eğilimindeyse kovaryans negatiftir. Kovaryans \\(s_{xy}\\) ile gösterilir ve aşağıdaki şekilde hesaplanır.\n\\[{s}_{xy} = \\frac{\\sum_{i=1}^n(x_i - \\bar{x})(y_i - \\bar{y})}{n-1}\\]\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\ncov(iris$Sepal.Length,iris$Petal.Length) # pozitif ilişki var\n\n[1] 1.274315\n\ncov(iris$Sepal.Length,iris$Sepal.Length)\n\n[1] 0.6856935\n\n\n\n\nKorelasyon\nKorelasyon, nicel değişkenler arasındaki ilişkiyi incelemek için yaygın olarak kullanılan bir yöntemdir. Karl Pearson’ın Pearson moment korelasyon katsayısı olarak da bilinen doğrusal korelasyon katsayısı r’dir. Doğrusal korelasyon katsayısı, iki değişken arasındaki doğrusal ilişkinin gücünü ölçer.\n\n\n\n\n\n\nKorelasyon, kovaryansın standartlaştırılmış halidir.\nStandartlaştırmadan kaynaklanan bilgi kaybı vardır.\nStandartlaştırılmış olduğu için korelasyonun birimi yoktur, birimsizdir.\nKorelasyon -1 ve +1 arasında değer alır.\nKorelasyon , ±1’e yakınsa, iki değişken yüksek oranda ilişkilidir ve bir saçılım grafiği üzerinde çizilirse, veri noktaları bir çizgi etrafında kümelenir.\nKorelasyon , ±1’den uzaksa, veri noktaları daha geniş bir alana dağılır.\nKorelasyon 0’a yakınsa, veri noktaları esasen yatay bir çizgi etrafında dağılır ve bu, değişkenler arasında neredeyse hiçbir doğrusal ilişki olmadığını gösterir.\nr=1 ise değişkenler arasında pozitif yönlü tam bir doğrusal ilişki vardır.\nr=-1 ise değişkenler arasında negatif (ters) yönlü tam bir doğrusal ilişki vardır.\nr=0 ise değişkenler arasında doğrusal ilişki yoktur.\nKorelasyon nedensel ilişki değildir.\nKorelasyon değişkenler arasındaki sebep sonuç ilişkilerini açıklamaz.\nKorelasyon matematiksel ilişkidir.\n\n\\[ r=\\frac{\\sum_{i=1}^n(x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^n(x_i-\\bar{x})^2}\\sqrt{\\sum_{i=1}^n(y_i-\\bar{y})^2}} = \\frac{s_{xy}}{s_xs_y} \\]\nİki değişken arasındaki doğrusal ilişkinin miktarı için açık bir sınıflandırma kuralı yoktur. Bununla birlikte, aşağıdaki tablo, Pearson çarpım momenti korelasyon katsayısının sayısal değerlerinin nasıl ele alınacağı konusunda temel bir fikir verebilir.\n\n\n\nKorelasyon Katsayısı (r)\nİlişkinin Derecesi\n\n\n\n\n\\(r &gt; 0.90\\)\nÇok kuvvetli\n\n\n\\(0.70 &lt; r\\le 0.90\\)\nKuvvetli\n\n\n\\(0.50 &lt; r\\le 0.70\\)\nOrta\n\n\n\\(0.30 &lt; r\\le 0.50\\)\nDüşük\n\n\n\\(r &lt; 0.30\\)\nZayıf\n\n\n\n\ncor(iris$Sepal.Length,iris$Petal.Length) # kuvvetli ilişki vardır.\n\n[1] 0.8717538\n\nplot(iris$Sepal.Length,iris$Petal.Length,\n     col=\"blue\",\n     xlab = \"Sepal\",\n     ylab = \"Petal\",\n     main = \"Sepal vs Petal Saçılım Grafiği\")\n\n\n\n\n\n\n\n\n\n\nKontenjans Katsayısı\nKontenjans katsayısı C, kategorik veriler için \\(\\chi 2\\) tabanlı bir ilişki ölçüsüdür. Bağımsızlık için \\(\\chi 2\\) testine dayanır. \\(\\chi 2\\) istatistiği, kontenjans durum tablolarındaki (iki yönlü tablo, çapraz tablo tablosu veya çapraz tablolar olarak da bilinir) değişkenler arasında istatistiksel bir ilişki olup olmadığını değerlendirmeyi sağlar. Bu tür tablolarda değişkenlerin dağılımı matris formatında gösterilir. İki nominal (kategorik) değişken arasında anlamlı bir ilişki olup olmadığını belirlemek için kullanılır.\n\\[ \\chi 2=\\sum\\frac{(G-B)^2}{B} \\]\nBurada G gözlemlenen frekansı ve B ise beklenen frekansı temsil eder . Ki-kare test istatistiği ile iki kategorik değişken arasında ilişki olup olmadığı araştırılır. Hipotez aşağıdaki gibi kurulur:\n\\(H_0:\\) Değişkenler arasında ilişki yoktur.\n\\(H_1:\\) Değişkenler arasında ilişki vardır.\nKontenjans katsayısı ise şu şekilde elde edilir:\n\\[ C=\\sqrt{\\frac{\\chi2}{n+\\chi2}} \\]\nBurada n satır ve sütun toplamlarını ifade eder. C katsayısı 0 ile 1 arasında bir değer alır. C=0 olması iki değişken arasında ilişki olmadığına, C=1 olması ile tam ilişkili olduğu anlamına gelir.\n\n# öğrencilerin sigara içme alışkanlığının egzersiz düzeyi ile ilişkili\n# olup olmadığını inceleyelim.\n\nlibrary(MASS)\nhead(survey)\n\n     Sex Wr.Hnd NW.Hnd W.Hnd    Fold Pulse    Clap Exer Smoke Height      M.I\n1 Female   18.5   18.0 Right  R on L    92    Left Some Never 173.00   Metric\n2   Male   19.5   20.5  Left  R on L   104    Left None Regul 177.80 Imperial\n3   Male   18.0   13.3 Right  L on R    87 Neither None Occas     NA     &lt;NA&gt;\n4   Male   18.8   18.9 Right  R on L    NA Neither None Never 160.00   Metric\n5   Male   20.0   20.0 Right Neither    35   Right Some Never 165.00   Metric\n6 Female   18.0   17.7 Right  L on R    64   Right Some Never 172.72 Imperial\n     Age\n1 18.250\n2 17.583\n3 16.917\n4 20.333\n5 23.667\n6 21.000\n\nnrow(survey)\n\n[1] 237\n\ntbl &lt;-  table(survey$Smoke, survey$Exer) \ntbl\n\n       \n        Freq None Some\n  Heavy    7    1    3\n  Never   87   18   84\n  Occas   12    3    4\n  Regul    9    1    7\n\n# 1.yol\nchisq.test(tbl) \n\nWarning in chisq.test(tbl): Chi-squared approximation may be incorrect\n\n\n\n    Pearson's Chi-squared test\n\ndata:  tbl\nX-squared = 5.4885, df = 6, p-value = 0.4828\n\n# 0.4828 p değeri .05 anlamlılık düzeyinden büyük olduğu için sigara \n# içme alışkanlığının öğrencilerin egzersiz düzeyinden bağımsız olduğu \n# sıfır hipotezini reddedemeyiz.\n\n# 2.yol\nsummary(tbl)\n\nNumber of cases in table: 236 \nNumber of factors: 2 \nTest for independence of all factors:\n    Chisq = 5.489, df = 6, p-value = 0.4828\n    Chi-squared approximation may be incorrect",
    "crumbs": [
      "R ile Temel İstatistik"
    ]
  },
  {
    "objectID": "regresyon.html",
    "href": "regresyon.html",
    "title": "Doğrusal Regresyon",
    "section": "",
    "text": "Basit doğrusal regresyon, iki nicel değişken arasındaki doğrusal ilişkiyi değerlendirmeye izin veren istatistiksel bir yaklaşımdır. Daha doğrusu, ilişkinin nicelleştirilmesini ve öneminin değerlendirilmesini sağlar. Çoklu doğrusal regresyon, bu yaklaşımın bir yanıt değişkeni (nicel) ile birkaç açıklayıcı değişken (nicel veya nitel) arasındaki doğrusal ilişkileri değerlendirmeyi mümkün kılması anlamında, basit doğrusal regresyonun bir genellemesidir.\nGerçek dünyada, çoklu doğrusal regresyon, basit doğrusal regresyondan daha sık kullanılır. Bu çoğunlukla böyledir çünkü, Çoklu doğrusal regresyon, diğer değişkenlerin etkisini kontrol ederken (yani etkiyi ortadan kaldırırken) iki değişken arasındaki ilişkiyi değerlendirmeye izin verir. Veri toplamanın da kolaylaşmasıyla, veriler analiz edilirken daha fazla değişken dahil edilebilir ve dikkate alınabilir.\nBasit doğrusal regresyon, iki değişken arasında doğrusal bir ilişkinin varlığını değerlendirmeye ve bu bağlantıyı nicelleştirmeye izin verir. Doğrusallığın, iki değişkenin doğrusal olarak bağımlı olup olmadığını test etmesi ve ölçmesi anlamında doğrusal regresyonda güçlü bir varsayım olduğuna dikkat etmek gerekmektedir.\nDoğrusal regresyonu güçlü bir istatistiksel araç yapan şey, açıklayıcı/bağımsız değişken bir birim arttığında yanıtın/bağımlı değişkenin hangi nicelikle değiştiğini ölçmeye izin vermesidir. Bu kavram doğrusal regresyonda anahtardır ve aşağıda verilen türde soruları yanıtlamaya yardımcı olur:\n\nReklama harcanan miktar ile belirli bir dönemdeki satışlar arasında bir bağlantı var mı?\nTütün vergilerindeki artış tüketimini azaltır mı?\nBölgeye bağlı olarak bir konutun en olası fiyatı nedir?\nBir kişinin bir uyarana tepki verme süresi cinsiyete bağlı mıdır?\n\nBasit doğrusal regresyon analizinde, bağımlı değişken y ile bağımsız değişken x arasındaki ilişki doğrusal bir denklem şeklinde verilir.\n\\[ y=\\beta_0+\\beta_1x \\]\nBurada, \\(\\beta_0\\) sayısına kesme noktası denir ve regresyon doğrusu ile y ekseninin (x=0) kesişme noktasını tanımlar. \\(\\beta_1\\) sayısına regresyon katsayısı denir. Regresyon doğrusu eğiminin bir ölçüsüdür. Böylece \\(\\beta_1\\), x değeri 1 birim arttığında y değerinin ne kadar değiştiğini gösterir. Model, x ve y arasında kesin bir ilişki verdiği için deterministik bir model olarak kabul edilir.\nAncak birçok durumda, iki değişken x ve y arasındaki ilişki kesin değildir. Bunun nedeni, bağımlı değişken y’nin, tahmin değişkeni x tarafından tam olarak yakalanmayan diğer bilinmeyen ve/veya rastgele süreçlerden etkilenmesidir. Böyle bir durumda veri noktaları düz bir çizgi üzerinde sıralanmaz. Bununla birlikte, veriler hala temeldeki doğrusal bir ilişkiyi takip edebilir. Bu bilinmeyenleri dikkate almak için lineer model denklemine \\(\\varepsilon\\) ile gösterilen rastgele bir hata terimi eklenir, böylece yukarıdaki deterministik modelin aksine olasılıklı bir model elde edilir.\n\\[ y=\\beta_0+\\beta_1x+\\varepsilon \\]\nBurada hata terimi \\(\\varepsilon_i\\)’nin bağımsız normal dağılımlı değerlerden oluştuğu varsayılır, \\(e_i\\)~\\(N(0,\\sigma^2)\\).\nDoğrusal regresyon modeli hakkında aşağıdaki varsayımlar yapılır:\n\nBağımlı değişken tesadüfi bir değişkendir ve normal dağılım göstermektedir.\nTahmin hataları tesadüfidir ve normal dağılım gösterirler.\nHatalar birbirinden bağımsızdır (otokorelasyon yoktur).\nHata varyansı sabittir ve veriler arasında hiç değişmediği varsayılır (eşit varyanslılık-homoscedasticity).\nEğer çoklu regresyon analizi yapılıyorsa, bağımsız değişkenlerin birbirleri ile bağlantısının olmaması gereklidir. Buna çoklu bağlantı (multicollinearity) olmaması varsayımı adı verilir.\nBağımlı değişken ile bağımsız değişkenler arasında doğrusal bir ilişki olmalıdır.\nGözlem sayısı parametre sayısından büyük olmalıdır.\n\n\n\n\n\n\n\nlibrary(gapminder)\n\nWarning: package 'gapminder' was built under R version 4.4.3\n\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# gapminder veri setine bakalım\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   &lt;fct&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\n# kişi başına milli gelir ile yaşam beklentisi değişkenlerini görselleştirelim.\n\nggplot(gapminder, aes(gdpPercap, lifeExp)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(gapminder, aes(gdpPercap, lifeExp)) +\n  geom_point() + \n  geom_smooth(method = \"lm\",se=TRUE)\n\n\n\n\n\n\n\n# regresyon modeli kuralım\n\nmodel1 &lt;- lm(lifeExp ~ gdpPercap, data = gapminder)\nmodel1\n\n\nCall:\nlm(formula = lifeExp ~ gdpPercap, data = gapminder)\n\nCoefficients:\n(Intercept)    gdpPercap  \n  5.396e+01    7.649e-04  \n\n\n\n\n\n\n\n\nYorum\n\n\n\nYani burada söyleyebileceğimiz şey, GSYH’daki her 1 artış için, yaşam beklentisinde 0.0007649 yıllık bir artış görmeyi bekleyebiliriz. Modelimizi daha iyi anlayabilmek için model üzerinde summary() fonksiyonunu kullanabiliriz. Ayrıca artıkların normalliğini de bakmak da fayda var.\n\n\nsummary fonksiyonu ile modelimizin verilere ne kadar iyi uyduğu hakkında biraz daha bilgi alıyoruz. Genel modelimiz ve her değişken için p-değerlerini görebiliriz. \\(R^2\\) değeri, veri kümenizdeki varyansın ne kadarının modeliniz tarafından açıklanabileceğini temel olarak, modelinizin verilere ne kadar iyi uyduğunu gösterir. Bu değer 0 ile 1 arasında değişir ve büyük olması beklenir. Genel olarak, modelinizde kaç değişken kullandığınızı telafi eden düzeltilmiş \\(R^2\\)’yi kullanırız. Aksi halde başka bir değişken eklemek her zaman \\(R^2\\)’yi artırır.\n\nsummary(model1)\n\n\nCall:\nlm(formula = lifeExp ~ gdpPercap, data = gapminder)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-82.754  -7.758   2.176   8.225  18.426 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 5.396e+01  3.150e-01  171.29   &lt;2e-16 ***\ngdpPercap   7.649e-04  2.579e-05   29.66   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 10.49 on 1702 degrees of freedom\nMultiple R-squared:  0.3407,    Adjusted R-squared:  0.3403 \nF-statistic: 879.6 on 1 and 1702 DF,  p-value: &lt; 2.2e-16\n\n\nModele gdp değişkenin logaritmasını alarak ve continent (kıta) ve year (yıl) değişkenlerini de ekleyerek çoklu regresyon analizi sonuçlarına bakalım.\n\nmodel2 &lt;- lm(lifeExp ~ log(gdpPercap) + continent + year, data = gapminder)\nsummary(model2)\n\n\nCall:\nlm(formula = lifeExp ~ log(gdpPercap) + continent + year, data = gapminder)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-25.0433  -3.2175   0.3482   3.6657  15.1321 \n\nCoefficients:\n                    Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       -4.659e+02  1.667e+01  -27.94   &lt;2e-16 ***\nlog(gdpPercap)     5.024e+00  1.595e-01   31.50   &lt;2e-16 ***\ncontinentAmericas  8.926e+00  4.630e-01   19.28   &lt;2e-16 ***\ncontinentAsia      7.063e+00  3.959e-01   17.84   &lt;2e-16 ***\ncontinentEurope    1.251e+01  5.097e-01   24.54   &lt;2e-16 ***\ncontinentOceania   1.275e+01  1.275e+00   10.00   &lt;2e-16 ***\nyear               2.416e-01  8.586e-03   28.14   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.813 on 1697 degrees of freedom\nMultiple R-squared:  0.7982,    Adjusted R-squared:  0.7975 \nF-statistic:  1119 on 6 and 1697 DF,  p-value: &lt; 2.2e-16\n\n\n\n\n\n\n\n\nYorum\n\n\n\nBu sonuçlara göre \\(R^2\\) değeri 0.79’a yükselmiştir. Değişken sayısını artırmak model başarısını artırmış görünüyor. Ayrıca katsayıların hepsinin de anlamlı çıktığı göz ardı edilmemelidir.\nAfrika kıtası haricinde, veri kümemizdeki kıtaların her biri için bir satır var. Bunun sebebi Afrika kıtası referans kıta olarak burada belirlenmesinden kaynaklanmaktadır. Yani kıtalara göre verileri yorumlarken Afirika kıtasına göre değerlendirme yapılacaktır. Örneğin Avrupa’da olmak ortalama olarak, Afrika’da olmaktan 12.51 yıl daha fazla yaşam beklentisine sahip olmak anlamına gelmektedir.\n\n\n\n\n\n\n\n\nTavsiye\n\n\n\nModel sonuçlarının daha güzel ve temiz (tidy) bir formatta görünmesi için broom paketi kullanılabilir.\n\n\n\nlibrary(broom)\n\n# gözlem düzeyinde sonuçlar\naugment(model2)\n\n# A tibble: 1,704 × 10\n   lifeExp `log(gdpPercap)` continent  year .fitted .resid    .hat .sigma\n     &lt;dbl&gt;            &lt;dbl&gt; &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1    28.8             6.66 Asia       1952    46.3  -17.5 0.00470   5.80\n 2    30.3             6.71 Asia       1957    47.8  -17.5 0.00425   5.80\n 3    32.0             6.75 Asia       1962    49.2  -17.2 0.00393   5.80\n 4    34.0             6.73 Asia       1967    50.3  -16.3 0.00380   5.80\n 5    36.1             6.61 Asia       1972    50.9  -14.8 0.00399   5.80\n 6    38.4             6.67 Asia       1977    52.4  -14.0 0.00393   5.81\n 7    39.9             6.89 Asia       1982    54.7  -14.9 0.00367   5.80\n 8    40.8             6.75 Asia       1987    55.2  -14.4 0.00422   5.80\n 9    41.7             6.48 Asia       1992    55.1  -13.4 0.00529   5.81\n10    41.8             6.45 Asia       1997    56.2  -14.4 0.00588   5.80\n# ℹ 1,694 more rows\n# ℹ 2 more variables: .cooksd &lt;dbl&gt;, .std.resid &lt;dbl&gt;\n\n#model düzeyinde sonuçlar\nglance(model2)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic p.value    df logLik    AIC    BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1     0.798         0.797  5.81     1119.       0     6 -5414. 10843. 10887.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;",
    "crumbs": [
      "Doğrusal Regresyon"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Programlama",
    "section": "",
    "text": "Önsöz\nR programlama dili, veri bilimi dünyasında vazgeçilmez bir araç haline geldi. Bu kitap, veri manipülasyonundan görselleştirmeye, keşifçi veri analizinden temel istatistik konularına kadar geniş bir yelpazede R dilini kullanarak veri analizi becerilerinizi güçlendirmenize odaklanıyor.\nKitabımız, R programlama dilini temel seviyeden başlayarak adım adım öğrenmek isteyen herkes için tasarlandı. İlk bölümlerde R dilinin temellerini kavrayacak ve dplyr gibi güçlü paketler aracılığıyla veri manipülasyonunun inceliklerini keşfedeceksiniz. Veri analizinin görselleştirme aşamasında ggplot2 paketiyle nasıl etkileyici grafikler oluşturabileceğinizi adım adım öğrenecek ve veri setlerinizin hikayesini çarpıcı görsellerle anlatacaksınız.\nKitabımız, keşifçi veri analizi sürecinde size rehberlik ederken, veri işleme tekniklerini ve önemli istatistik kavramlarını pratik örneklerle ele alacak. Temel istatistik kolları üzerine odaklanarak, veri setlerinizdeki deseni anlamak ve çözümlemek için gerekli araçları edineceksiniz. Ayrıca doğrusal regresyon gibi önemli modelleme tekniklerini R dilinde nasıl uygulayabileceğinizi adım adım öğreneceksiniz.\nBu kitabın amacı, R programlama dilini veri analizi süreçlerinizde güvenle kullanmanıza yardımcı olmak ve veri odaklı kararlar almanızı desteklemektir. Bilgi birikiminizi genişletirken öğrendiklerinizi uygulamaya dökme şansına sahip olacaksınız. Umarım bu kitap, veri analizi yolculuğunuzda size rehberlik eder ve R dilini kullanarak veriyle olan etkileşiminizi daha da derinleştirir.",
    "crumbs": [
      "Önsöz"
    ]
  },
  {
    "objectID": "r_about.html",
    "href": "r_about.html",
    "title": "R Programlama Hakkında",
    "section": "",
    "text": "R Programı ile Neler Yapılabilir\nR programlama, veri analizi, istatistiksel ve ekonometrik hesaplamalar, veri görselleştirme ve veri madenciliği gibi istatistiksel ve veri analitiği işlemleri için kullanılan bir programlama dilidir. İlk olarak 1990 yılında Ross Ihaka ve Robert Gentleman tarafından geliştirilmeye başlanmıştır ve o zamandan bu yana istatistiksel analiz alanında çok popüler bir araç haline gelmiştir. Yazılım ismini yazarların isimlerinin baş harflerinden almaktadır.\nR, açık kaynaklı bir programlama dili ve yazılım ortamıdır, bu da onu geniş bir kullanıcı topluluğu tarafından desteklenen ve geliştirilen bir platform yapar. R ile yapılabilecek başlıca işler şunlardır:",
    "crumbs": [
      "R Programlama Hakkında"
    ]
  },
  {
    "objectID": "r_about.html#r-programı-ile-neler-yapılabilir",
    "href": "r_about.html#r-programı-ile-neler-yapılabilir",
    "title": "R Programlama Hakkında",
    "section": "",
    "text": "Veri Analizi: R, veri çerçeveleri ve veri setleri üzerinde işlem yapmak için bir dizi fonksiyon ve araç sunar. Veri temizleme, dönüştürme, özeti alma ve analiz etme işlemleri R ile kolayca gerçekleştirilebilir.\nVeri Görselleştirme: R, ggplot2 gibi grafik paketleri ile verilerinizi görselleştirmenize olanak tanır. Çeşitli grafik türleri (çizgi grafikleri, sütun grafikleri, dağılım grafikleri vb.) oluşturabilirsiniz.\nİstatistiksel Analiz: R, istatistiksel modelleri oluşturmak, hipotez testleri yapmak ve regresyon analizi gibi istatistiksel analizler gerçekleştirmek için zengin bir araç seti sunar. Ayrıca zaman serisi analizi ve kümeleme gibi konularda da kullanılır.\nVeri Madenciliği: R, veri madenciliği uygulamaları için kullanılabilir. Makine öğrenimi algoritmaları uygulamak ve veri madenciliği projeleri geliştirmek için paketler içerir.\nRaporlama: R Markdown kullanarak veri analizi ve sonuçlarını raporlama için kullanılır. Bu, anlamlı ve formatlı raporlar oluşturmanıza yardımcı olur.\nPaketler ve Genişletilebilirlik: R, kullanıcıların işlevselliği genişletmek için paketler ekleyebileceği bir sistem sunar. CRAN (Comprehensive R Archive Network) gibi kaynaklar, binlerce paketi içeren bir depo sağlar.\n\n\n\n\n\n\n\nNot\n\n\n\nR programlama özellikle istatistik, veri bilimi ve akademik araştırmalar alanlarında çok kullanılır, ancak endüstriyel uygulamalarda da giderek daha fazla kullanılmaktadır. R’nin açık kaynaklı olması ve geniş bir kullanıcı topluluğuna sahip olması, bu dilin popülerliğini artırmıştır. R ile çalışmak için temel programlama bilgisine sahip olmak yararlı olacaktır, ancak öğrenmesi oldukça erişilebilir bir dildir ve çevrimiçi kaynaklar ve kurslar mevcuttur.",
    "crumbs": [
      "R Programlama Hakkında"
    ]
  },
  {
    "objectID": "r_about.html#r-programlama-ile-ilgili-faydalı-kaynaklar",
    "href": "r_about.html#r-programlama-ile-ilgili-faydalı-kaynaklar",
    "title": "R Programlama Hakkında",
    "section": "R Programlama ile ilgili Faydalı Kaynaklar",
    "text": "R Programlama ile ilgili Faydalı Kaynaklar\nR programlamayı öğrenmek ve geliştirmek için bir dizi faydalı kaynak bulunmaktadır. R programlamaya başlamak veya ilerlemek için kullanabileceğiniz bazı kaynaklar:\n\nResmi R Web Sitesi: R’nin resmi web sitesi (https://www.r-project.org/) R programlamaya başlamak için temel kaynaktır. Burada R’nin indirilmesi, kurulumu ve temel belgelendirme bilgilerine erişebilirsiniz.\nRStudio: R programlama için yaygın olarak kullanılan RStudio IDE’si (Entegre Geliştirme Ortamı), R kodlarını yazmak, çalıştırmak ve yönetmek için güçlü bir araçtır. RStudio’nun resmi web sitesi (https://www.rstudio.com/) RStudio’nun indirilmesi ve kullanımı hakkında bilgi sunar.\nR Dersleri ve Kurslar: İnternette birçok ücretsiz R dersi ve kursu bulabilirsiniz. Coursera, edX, Udemy ve DataCamp gibi platformlar, R programlamayı öğrenmek için çeşitli kurslar sunmaktadır.\nR Belgeleri: R’nin resmi belgeleme (https://cran.r-project.org/manuals.html) kaynakları, R dilinin temellerini ve paketlerini öğrenmek için çok faydalıdır. R’deki komutlar ve fonksiyonlar hakkında ayrıntılı bilgi içerirler.\nKitaplar: R programlamayı öğrenmek için yazılmış birçok kitap bulunmaktadır. Örnek olarak, R for Data Science (Hadley Wickham ve Garrett Grolemund), Advanced R (Hadley Wickham) gibi kitaplar önerilebilir.\nStack Overflow: Programlama sorunları ve hatalarıyla karşılaştığınızda, Stack Overflow gibi forumlarda R ile ilgili sorular sormak ve cevaplamak için topluluktan yardım alabilirsiniz.\nGitHub: R ile ilgili açık kaynaklı projeleri incelemek ve kendi projelerinizi paylaşmak için GitHub gibi platformları kullanabilirsiniz. GitHub’da R kodlarını içeren birçok depo bulunmaktadır.\nBloglar ve Videolar: R ile ilgili bloglar ve YouTube kanalları, öğrenmek ve güncel kalmak için harika kaynaklardır. RStudio Blog (https://posit.co/blog/) ve YouTube’da R ile ilgili videoları bulabileceğiniz RStudio’nun resmi kanalı bunlara örnektir.\n\n\n\n\n\n\n\nTavsiye\n\n\n\nR programlamayı öğrenmek ve geliştirmek için sürekli olarak yeni kaynaklar ve materyaller üretilmektedir. İhtiyacınıza ve seviyenize uygun kaynakları seçmek için zaman ayırın ve kendi hızınıza göre öğrenmeye devam edin.",
    "crumbs": [
      "R Programlama Hakkında"
    ]
  },
  {
    "objectID": "r_about.html#r-ve-rstudionun-bilgisayara-kurulması",
    "href": "r_about.html#r-ve-rstudionun-bilgisayara-kurulması",
    "title": "R Programlama Hakkında",
    "section": "R ve RStudio’nun Bilgisayara Kurulması",
    "text": "R ve RStudio’nun Bilgisayara Kurulması\nR’ın internet sitesinden işletim sisteminize uygun programı indirip kurabilirsiniz. Linux, Mac OS ve Windows işletim sistemleri için sürümleri mevcuttur.\nWindows İşletim Sistemi İçin R Kurulumu\n\nR programını indirmek için R resmi web sitesini ziyaret edin: https://cran.r-project.org/\nSayfanın üst kısmında “Download R for Windows” başlığını bulun ve tıklayın.\n\nİndirilen sayfada “base” sekmesine tıklayın.\n\nAçılan sayfada “Download R 4.3.1 for Windows” linkine tıklayın ve dosyayı indirin.\n\n\n\n\n\n\n\nDikkat\n\n\n\nSayfayı ziyaret ettiğiniz tarihlerde farklı sürümlerin olabileceğine dikkat edin. Örneğin ileri bir tarihte bu sayfayı ziyaret ettiğinizde R programının yeni sürümü ile karşılabilirsiniz. O yüzden sürüm bilgisi değişkenlik gösterebilir.\n\n\nİndirilen dosyayı çift tıklayarak çalıştırın ve yükleyiciyi başlatın.\nYükleyici, R’nin temel sürümünü yüklemek için sizi yönlendirecektir. Varsayılan ayarları genellikle kabul edebilirsiniz.\nKurulum tamamlandığında, R’yi çalıştırmak için masaüstünüzde veya Başlat menüsünde “R” simgesini bulabilirsiniz.\n\nWindows İşletim Sistemi İçin R Studio Kurulumu\nR editörü grafiksel bir arayüz olmayıp eski tip bir yazılım konsoludur. R Studio, R programlama dili için geliştirilmiş entegre bir geliştirme ortamı (IDE) ve arayüzüdür. R Studio, R kodlarını daha verimli bir şekilde yazmanıza, çalıştırmanıza ve yönetmenize olanak tanıyan daha modern ve kullanışlı bir arayüz sunmaktadır. Ayrıca veri analizi, görselleştirme ve raporlama işlemleri için güçlü bir platform sunar. R Studio, açık kaynak bir projedir ve ücretsiz olarak kullanılabilir.\nR Studio’nun kurulumu aşağıdaki adımlarla gerçekleştirilebilir:\n\nR Studio’nun en son sürümünü indirmek için aşağıdaki bağlantıyı kullanın: https://www.rstudio.com/products/rstudio/download/\nSayfada “Download RStudio Desktop for Windows” kısmına tıklayın ve indirmeyi başlatın.\n\nİndirilen dosyayı çift tıklayarak çalıştırın ve kurulumu başlatın. Kurulum sırasında varsayılan ayarları genellikle kabul edebilirsiniz.\nKurulum tamamlandığında, R Studio’yu başlatmak için masaüstünüzde veya Başlat menüsünde “RStudio” simgesini bulabilirsiniz.",
    "crumbs": [
      "R Programlama Hakkında"
    ]
  },
  {
    "objectID": "r_about.html#r-studio-kişiselleştirme",
    "href": "r_about.html#r-studio-kişiselleştirme",
    "title": "R Programlama Hakkında",
    "section": "R Studio Kişiselleştirme",
    "text": "R Studio Kişiselleştirme\n\nRStudio, kullanıcıların ihtiyaçlarına göre kişiselleştirilebilen bir entegre geliştirme ortamı (IDE) sunar. RStudio’yu kişiselleştirmek için aşağıdaki yolları kullanabilirsiniz:\n\nR Studio Arayüzündeki Alanları Değiştirme: Resimde görüldüğü gibi yeni bir R Script açıldığı takdirde arayüzde 4 farklı alan görülmektedir. Bu alanlar isteğe göre yer değiştirilebilmektedir. Bunun için “Tools” (Araçlar) menüsünden “Global Options” (Genel Ayarlar) sekmesi açılır. Buradan “Pane Layout” kısmından istenilen ayarlar yapılabilir.\nTemayı ve Editör Stilini Değiştirme: RStudio’nun görünümünü değiştirmek için birçok tema ve editör stilini seçebilirsiniz. Bu, yazılım geliştirme ortamınızın daha hoş veya kullanışlı olmasını sağlar. “Tools” (Araçlar) menüsünden “Global Options” (Genel Ayarlar) sekmesini seçerek bu ayarları değiştirebilirsiniz.\nKlavye Kısayollarını Kişiselleştirme: RStudio’da kullanılan klavye kısayollarını özelleştirebilirsiniz. “Tools” (Araçlar) menüsünden “Modify Keyboard Shortcuts” (Klavye Kısayollarını Düzenle) seçeneğini kullanarak klavye kısayollarını tanımlayabilir veya değiştirebilirsiniz.\nEklentileri ve Paketleri Kullanma: RStudio, kullanıcıların işlevselliği genişletmek için eklentileri ve R paketlerini kullanmalarını sağlar. Bu paketler, kod otomatik tamamlama, kod görselleştirme, proje yönetimi gibi birçok işlemi kolaylaştırabilir. R Studio’nun sol üst köşesindeki “Tools” (Araçlar) menüsünden “Install Packages” (Paketleri Yükle) seçeneği ile yeni paketleri yükleyebilirsiniz.\nR Markdown Belgelerini Özelleştirme: R Markdown belgeleri, raporlar ve belgeler oluşturmak için kullanılır. Bu belgeleri kişiselleştirebilirsiniz. R Markdown belgelerinin başlık, stil, tablo düzeni ve grafikler gibi birçok yönünü özelleştirebilirsiniz.\nProje Ayarlarını Yapılandırma: RStudio’da projeler kullanmak, projelerinizi daha düzenli ve etkili bir şekilde yönetmenize yardımcı olabilir. “File” (Dosya) menüsünden “New Project” (Yeni Proje) seçeneği ile yeni projeler oluşturabilir ve projelerinizi kişiselleştirebilirsiniz.\nKod Tarayıcı ve Çalışma Ortamını Özelleştirme: RStudio’nun sağ tarafında bulunan “Environment” (Çalışma Ortamı) ve “Files” (Dosyalar) sekmelerini özelleştirebilirsiniz. Bu sekmeleri dilediğiniz gibi düzenleyebilirsiniz.\nAddins Kullanma: RStudio’nun “Addins” (Eklentiler) menüsü, kullanıcıların özel işlevleri ekleyebileceği bir bölümdür. Bu sayede belirli işlemleri hızlıca gerçekleştirebilirsiniz.\n\nRStudio’nun bu kişiselleştirme seçenekleri, kullanıcıların kendi ihtiyaçlarına ve tercihlerine göre IDE’yi özelleştirmelerine olanak tanır. Bu şekilde, RStudio’yu daha verimli ve kişiselleştirilmiş bir şekilde kullanabilirsiniz. RStudio’nun ana bileşenleri ve temel özellikleri ise şunlardır:\n\nScript Editörü: RStudio’nun sol üst kısmında yer alan bu bölüm, R kodlarını yazmak, düzenlemek ve çalıştırmak için kullanılır. Renk vurguları, otomatik tamamlama ve hata işaretleme gibi birçok yazılım geliştirme özelliği içerir.\nEnvironment (Çalışma Ortamı) : Sağ üst köşede bulunan “Çalışma Ortamı” sekmesi, çalışan nesneleri ve değişkenleri görüntülemenizi sağlar. “Files” sekmesi ise projenizdeki dosyaları ve klasörleri görüntülemenize yardımcı olur.\nConsole: Alt sol köşede bulunan bu bölüm, R kodlarını anlık olarak çalıştırmanıza ve sonuçları görmesinize olanak tanır. R komutlarını doğrudan konsola yazabilir ve çalıştırabilirsiniz.\nDiğer Sekmeler : RStudio, çeşitli grafikler ve görselleştirmeler oluşturmanıza olanak tanır. R koduyla çizilen grafikler, “Plots” sekmesinde görüntülenir. Bunu yanısıra “Help” kısmında fonksiyonlar ile ilgili bilgi alınabilir,”Packages” kısmından ise paket yükleme vb. işler yapılabilir.",
    "crumbs": [
      "R Programlama Hakkında"
    ]
  }
]